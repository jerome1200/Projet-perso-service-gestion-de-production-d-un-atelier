
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Borne
 * 
 */
export type Borne = $Result.DefaultSelection<Prisma.$BornePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Piece
 * 
 */
export type Piece = $Result.DefaultSelection<Prisma.$PiecePayload>
/**
 * Model SousAssemblage
 * 
 */
export type SousAssemblage = $Result.DefaultSelection<Prisma.$SousAssemblagePayload>
/**
 * Model SousSousAssemblage
 * 
 */
export type SousSousAssemblage = $Result.DefaultSelection<Prisma.$SousSousAssemblagePayload>
/**
 * Model Kit
 * 
 */
export type Kit = $Result.DefaultSelection<Prisma.$KitPayload>
/**
 * Model SousAssemblagePiece
 * 
 */
export type SousAssemblagePiece = $Result.DefaultSelection<Prisma.$SousAssemblagePiecePayload>
/**
 * Model SousSousAssemblagePiece
 * 
 */
export type SousSousAssemblagePiece = $Result.DefaultSelection<Prisma.$SousSousAssemblagePiecePayload>
/**
 * Model SousAssemblageSousSousAssemblage
 * 
 */
export type SousAssemblageSousSousAssemblage = $Result.DefaultSelection<Prisma.$SousAssemblageSousSousAssemblagePayload>
/**
 * Model KitPiece
 * 
 */
export type KitPiece = $Result.DefaultSelection<Prisma.$KitPiecePayload>
/**
 * Model StockLog
 * 
 */
export type StockLog = $Result.DefaultSelection<Prisma.$StockLogPayload>
/**
 * Model TaskTemplate
 * 
 */
export type TaskTemplate = $Result.DefaultSelection<Prisma.$TaskTemplatePayload>
/**
 * Model Production
 * 
 */
export type Production = $Result.DefaultSelection<Prisma.$ProductionPayload>
/**
 * Model ProductionLine
 * 
 */
export type ProductionLine = $Result.DefaultSelection<Prisma.$ProductionLinePayload>
/**
 * Model ProductionTask
 * 
 */
export type ProductionTask = $Result.DefaultSelection<Prisma.$ProductionTaskPayload>
/**
 * Model ProductionTaskLog
 * 
 */
export type ProductionTaskLog = $Result.DefaultSelection<Prisma.$ProductionTaskLogPayload>
/**
 * Model TaskTemplatePiece
 * 
 */
export type TaskTemplatePiece = $Result.DefaultSelection<Prisma.$TaskTemplatePiecePayload>
/**
 * Model TaskTemplateSousAssemblage
 * 
 */
export type TaskTemplateSousAssemblage = $Result.DefaultSelection<Prisma.$TaskTemplateSousAssemblagePayload>
/**
 * Model TaskTemplateSousSousAssemblage
 * 
 */
export type TaskTemplateSousSousAssemblage = $Result.DefaultSelection<Prisma.$TaskTemplateSousSousAssemblagePayload>
/**
 * Model TaskTemplateLog
 * 
 */
export type TaskTemplateLog = $Result.DefaultSelection<Prisma.$TaskTemplateLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TaskEventType: {
  CREATED: 'CREATED',
  ASSIGNED: 'ASSIGNED',
  STARTED: 'STARTED',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  REOPENED: 'REOPENED'
};

export type TaskEventType = (typeof TaskEventType)[keyof typeof TaskEventType]


export const ProductionStatus: {
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE',
  CANCELED: 'CANCELED'
};

export type ProductionStatus = (typeof ProductionStatus)[keyof typeof ProductionStatus]


export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  DEFAULT: 'DEFAULT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const StockOperation: {
  ADD: 'ADD',
  REMOVE: 'REMOVE'
};

export type StockOperation = (typeof StockOperation)[keyof typeof StockOperation]


export const PieceType: {
  COMMERCE: 'COMMERCE',
  ELEC: 'ELEC',
  PIECE_3D: 'PIECE_3D',
  CABLE_SM: 'CABLE_SM',
  TOLERIE: 'TOLERIE',
  OUTIL: 'OUTIL',
  SSA: 'SSA',
  SA: 'SA',
  KITS: 'KITS'
};

export type PieceType = (typeof PieceType)[keyof typeof PieceType]


export const PieceEtat: {
  RD: 'RD',
  PRODUCTION: 'PRODUCTION',
  MAINTENANCE: 'MAINTENANCE'
};

export type PieceEtat = (typeof PieceEtat)[keyof typeof PieceEtat]

}

export type TaskEventType = $Enums.TaskEventType

export const TaskEventType: typeof $Enums.TaskEventType

export type ProductionStatus = $Enums.ProductionStatus

export const ProductionStatus: typeof $Enums.ProductionStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type StockOperation = $Enums.StockOperation

export const StockOperation: typeof $Enums.StockOperation

export type PieceType = $Enums.PieceType

export const PieceType: typeof $Enums.PieceType

export type PieceEtat = $Enums.PieceEtat

export const PieceEtat: typeof $Enums.PieceEtat

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bornes
 * const bornes = await prisma.borne.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bornes
   * const bornes = await prisma.borne.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.borne`: Exposes CRUD operations for the **Borne** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bornes
    * const bornes = await prisma.borne.findMany()
    * ```
    */
  get borne(): Prisma.BorneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.piece`: Exposes CRUD operations for the **Piece** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pieces
    * const pieces = await prisma.piece.findMany()
    * ```
    */
  get piece(): Prisma.PieceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sousAssemblage`: Exposes CRUD operations for the **SousAssemblage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SousAssemblages
    * const sousAssemblages = await prisma.sousAssemblage.findMany()
    * ```
    */
  get sousAssemblage(): Prisma.SousAssemblageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sousSousAssemblage`: Exposes CRUD operations for the **SousSousAssemblage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SousSousAssemblages
    * const sousSousAssemblages = await prisma.sousSousAssemblage.findMany()
    * ```
    */
  get sousSousAssemblage(): Prisma.SousSousAssemblageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kit`: Exposes CRUD operations for the **Kit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kits
    * const kits = await prisma.kit.findMany()
    * ```
    */
  get kit(): Prisma.KitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sousAssemblagePiece`: Exposes CRUD operations for the **SousAssemblagePiece** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SousAssemblagePieces
    * const sousAssemblagePieces = await prisma.sousAssemblagePiece.findMany()
    * ```
    */
  get sousAssemblagePiece(): Prisma.SousAssemblagePieceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sousSousAssemblagePiece`: Exposes CRUD operations for the **SousSousAssemblagePiece** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SousSousAssemblagePieces
    * const sousSousAssemblagePieces = await prisma.sousSousAssemblagePiece.findMany()
    * ```
    */
  get sousSousAssemblagePiece(): Prisma.SousSousAssemblagePieceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sousAssemblageSousSousAssemblage`: Exposes CRUD operations for the **SousAssemblageSousSousAssemblage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SousAssemblageSousSousAssemblages
    * const sousAssemblageSousSousAssemblages = await prisma.sousAssemblageSousSousAssemblage.findMany()
    * ```
    */
  get sousAssemblageSousSousAssemblage(): Prisma.SousAssemblageSousSousAssemblageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kitPiece`: Exposes CRUD operations for the **KitPiece** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KitPieces
    * const kitPieces = await prisma.kitPiece.findMany()
    * ```
    */
  get kitPiece(): Prisma.KitPieceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockLog`: Exposes CRUD operations for the **StockLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockLogs
    * const stockLogs = await prisma.stockLog.findMany()
    * ```
    */
  get stockLog(): Prisma.StockLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTemplate`: Exposes CRUD operations for the **TaskTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTemplates
    * const taskTemplates = await prisma.taskTemplate.findMany()
    * ```
    */
  get taskTemplate(): Prisma.TaskTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.production`: Exposes CRUD operations for the **Production** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productions
    * const productions = await prisma.production.findMany()
    * ```
    */
  get production(): Prisma.ProductionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionLine`: Exposes CRUD operations for the **ProductionLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionLines
    * const productionLines = await prisma.productionLine.findMany()
    * ```
    */
  get productionLine(): Prisma.ProductionLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionTask`: Exposes CRUD operations for the **ProductionTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionTasks
    * const productionTasks = await prisma.productionTask.findMany()
    * ```
    */
  get productionTask(): Prisma.ProductionTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionTaskLog`: Exposes CRUD operations for the **ProductionTaskLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionTaskLogs
    * const productionTaskLogs = await prisma.productionTaskLog.findMany()
    * ```
    */
  get productionTaskLog(): Prisma.ProductionTaskLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTemplatePiece`: Exposes CRUD operations for the **TaskTemplatePiece** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTemplatePieces
    * const taskTemplatePieces = await prisma.taskTemplatePiece.findMany()
    * ```
    */
  get taskTemplatePiece(): Prisma.TaskTemplatePieceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTemplateSousAssemblage`: Exposes CRUD operations for the **TaskTemplateSousAssemblage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTemplateSousAssemblages
    * const taskTemplateSousAssemblages = await prisma.taskTemplateSousAssemblage.findMany()
    * ```
    */
  get taskTemplateSousAssemblage(): Prisma.TaskTemplateSousAssemblageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTemplateSousSousAssemblage`: Exposes CRUD operations for the **TaskTemplateSousSousAssemblage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTemplateSousSousAssemblages
    * const taskTemplateSousSousAssemblages = await prisma.taskTemplateSousSousAssemblage.findMany()
    * ```
    */
  get taskTemplateSousSousAssemblage(): Prisma.TaskTemplateSousSousAssemblageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTemplateLog`: Exposes CRUD operations for the **TaskTemplateLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTemplateLogs
    * const taskTemplateLogs = await prisma.taskTemplateLog.findMany()
    * ```
    */
  get taskTemplateLog(): Prisma.TaskTemplateLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Borne: 'Borne',
    User: 'User',
    Piece: 'Piece',
    SousAssemblage: 'SousAssemblage',
    SousSousAssemblage: 'SousSousAssemblage',
    Kit: 'Kit',
    SousAssemblagePiece: 'SousAssemblagePiece',
    SousSousAssemblagePiece: 'SousSousAssemblagePiece',
    SousAssemblageSousSousAssemblage: 'SousAssemblageSousSousAssemblage',
    KitPiece: 'KitPiece',
    StockLog: 'StockLog',
    TaskTemplate: 'TaskTemplate',
    Production: 'Production',
    ProductionLine: 'ProductionLine',
    ProductionTask: 'ProductionTask',
    ProductionTaskLog: 'ProductionTaskLog',
    TaskTemplatePiece: 'TaskTemplatePiece',
    TaskTemplateSousAssemblage: 'TaskTemplateSousAssemblage',
    TaskTemplateSousSousAssemblage: 'TaskTemplateSousSousAssemblage',
    TaskTemplateLog: 'TaskTemplateLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "borne" | "user" | "piece" | "sousAssemblage" | "sousSousAssemblage" | "kit" | "sousAssemblagePiece" | "sousSousAssemblagePiece" | "sousAssemblageSousSousAssemblage" | "kitPiece" | "stockLog" | "taskTemplate" | "production" | "productionLine" | "productionTask" | "productionTaskLog" | "taskTemplatePiece" | "taskTemplateSousAssemblage" | "taskTemplateSousSousAssemblage" | "taskTemplateLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Borne: {
        payload: Prisma.$BornePayload<ExtArgs>
        fields: Prisma.BorneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BorneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BorneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>
          }
          findFirst: {
            args: Prisma.BorneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BorneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>
          }
          findMany: {
            args: Prisma.BorneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>[]
          }
          create: {
            args: Prisma.BorneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>
          }
          createMany: {
            args: Prisma.BorneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BorneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>[]
          }
          delete: {
            args: Prisma.BorneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>
          }
          update: {
            args: Prisma.BorneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>
          }
          deleteMany: {
            args: Prisma.BorneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BorneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BorneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>[]
          }
          upsert: {
            args: Prisma.BorneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BornePayload>
          }
          aggregate: {
            args: Prisma.BorneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBorne>
          }
          groupBy: {
            args: Prisma.BorneGroupByArgs<ExtArgs>
            result: $Utils.Optional<BorneGroupByOutputType>[]
          }
          count: {
            args: Prisma.BorneCountArgs<ExtArgs>
            result: $Utils.Optional<BorneCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Piece: {
        payload: Prisma.$PiecePayload<ExtArgs>
        fields: Prisma.PieceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PieceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PieceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>
          }
          findFirst: {
            args: Prisma.PieceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PieceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>
          }
          findMany: {
            args: Prisma.PieceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>[]
          }
          create: {
            args: Prisma.PieceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>
          }
          createMany: {
            args: Prisma.PieceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PieceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>[]
          }
          delete: {
            args: Prisma.PieceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>
          }
          update: {
            args: Prisma.PieceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>
          }
          deleteMany: {
            args: Prisma.PieceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PieceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PieceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>[]
          }
          upsert: {
            args: Prisma.PieceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PiecePayload>
          }
          aggregate: {
            args: Prisma.PieceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePiece>
          }
          groupBy: {
            args: Prisma.PieceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PieceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PieceCountArgs<ExtArgs>
            result: $Utils.Optional<PieceCountAggregateOutputType> | number
          }
        }
      }
      SousAssemblage: {
        payload: Prisma.$SousAssemblagePayload<ExtArgs>
        fields: Prisma.SousAssemblageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SousAssemblageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SousAssemblageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>
          }
          findFirst: {
            args: Prisma.SousAssemblageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SousAssemblageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>
          }
          findMany: {
            args: Prisma.SousAssemblageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>[]
          }
          create: {
            args: Prisma.SousAssemblageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>
          }
          createMany: {
            args: Prisma.SousAssemblageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SousAssemblageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>[]
          }
          delete: {
            args: Prisma.SousAssemblageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>
          }
          update: {
            args: Prisma.SousAssemblageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>
          }
          deleteMany: {
            args: Prisma.SousAssemblageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SousAssemblageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SousAssemblageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>[]
          }
          upsert: {
            args: Prisma.SousAssemblageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePayload>
          }
          aggregate: {
            args: Prisma.SousAssemblageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSousAssemblage>
          }
          groupBy: {
            args: Prisma.SousAssemblageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SousAssemblageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SousAssemblageCountArgs<ExtArgs>
            result: $Utils.Optional<SousAssemblageCountAggregateOutputType> | number
          }
        }
      }
      SousSousAssemblage: {
        payload: Prisma.$SousSousAssemblagePayload<ExtArgs>
        fields: Prisma.SousSousAssemblageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SousSousAssemblageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SousSousAssemblageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>
          }
          findFirst: {
            args: Prisma.SousSousAssemblageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SousSousAssemblageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>
          }
          findMany: {
            args: Prisma.SousSousAssemblageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>[]
          }
          create: {
            args: Prisma.SousSousAssemblageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>
          }
          createMany: {
            args: Prisma.SousSousAssemblageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SousSousAssemblageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>[]
          }
          delete: {
            args: Prisma.SousSousAssemblageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>
          }
          update: {
            args: Prisma.SousSousAssemblageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>
          }
          deleteMany: {
            args: Prisma.SousSousAssemblageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SousSousAssemblageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SousSousAssemblageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>[]
          }
          upsert: {
            args: Prisma.SousSousAssemblageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePayload>
          }
          aggregate: {
            args: Prisma.SousSousAssemblageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSousSousAssemblage>
          }
          groupBy: {
            args: Prisma.SousSousAssemblageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SousSousAssemblageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SousSousAssemblageCountArgs<ExtArgs>
            result: $Utils.Optional<SousSousAssemblageCountAggregateOutputType> | number
          }
        }
      }
      Kit: {
        payload: Prisma.$KitPayload<ExtArgs>
        fields: Prisma.KitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>
          }
          findFirst: {
            args: Prisma.KitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>
          }
          findMany: {
            args: Prisma.KitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>[]
          }
          create: {
            args: Prisma.KitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>
          }
          createMany: {
            args: Prisma.KitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>[]
          }
          delete: {
            args: Prisma.KitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>
          }
          update: {
            args: Prisma.KitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>
          }
          deleteMany: {
            args: Prisma.KitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>[]
          }
          upsert: {
            args: Prisma.KitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPayload>
          }
          aggregate: {
            args: Prisma.KitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKit>
          }
          groupBy: {
            args: Prisma.KitGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitCountArgs<ExtArgs>
            result: $Utils.Optional<KitCountAggregateOutputType> | number
          }
        }
      }
      SousAssemblagePiece: {
        payload: Prisma.$SousAssemblagePiecePayload<ExtArgs>
        fields: Prisma.SousAssemblagePieceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SousAssemblagePieceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SousAssemblagePieceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>
          }
          findFirst: {
            args: Prisma.SousAssemblagePieceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SousAssemblagePieceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>
          }
          findMany: {
            args: Prisma.SousAssemblagePieceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>[]
          }
          create: {
            args: Prisma.SousAssemblagePieceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>
          }
          createMany: {
            args: Prisma.SousAssemblagePieceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SousAssemblagePieceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>[]
          }
          delete: {
            args: Prisma.SousAssemblagePieceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>
          }
          update: {
            args: Prisma.SousAssemblagePieceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>
          }
          deleteMany: {
            args: Prisma.SousAssemblagePieceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SousAssemblagePieceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SousAssemblagePieceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>[]
          }
          upsert: {
            args: Prisma.SousAssemblagePieceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblagePiecePayload>
          }
          aggregate: {
            args: Prisma.SousAssemblagePieceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSousAssemblagePiece>
          }
          groupBy: {
            args: Prisma.SousAssemblagePieceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SousAssemblagePieceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SousAssemblagePieceCountArgs<ExtArgs>
            result: $Utils.Optional<SousAssemblagePieceCountAggregateOutputType> | number
          }
        }
      }
      SousSousAssemblagePiece: {
        payload: Prisma.$SousSousAssemblagePiecePayload<ExtArgs>
        fields: Prisma.SousSousAssemblagePieceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SousSousAssemblagePieceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SousSousAssemblagePieceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>
          }
          findFirst: {
            args: Prisma.SousSousAssemblagePieceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SousSousAssemblagePieceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>
          }
          findMany: {
            args: Prisma.SousSousAssemblagePieceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>[]
          }
          create: {
            args: Prisma.SousSousAssemblagePieceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>
          }
          createMany: {
            args: Prisma.SousSousAssemblagePieceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SousSousAssemblagePieceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>[]
          }
          delete: {
            args: Prisma.SousSousAssemblagePieceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>
          }
          update: {
            args: Prisma.SousSousAssemblagePieceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>
          }
          deleteMany: {
            args: Prisma.SousSousAssemblagePieceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SousSousAssemblagePieceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SousSousAssemblagePieceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>[]
          }
          upsert: {
            args: Prisma.SousSousAssemblagePieceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousSousAssemblagePiecePayload>
          }
          aggregate: {
            args: Prisma.SousSousAssemblagePieceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSousSousAssemblagePiece>
          }
          groupBy: {
            args: Prisma.SousSousAssemblagePieceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SousSousAssemblagePieceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SousSousAssemblagePieceCountArgs<ExtArgs>
            result: $Utils.Optional<SousSousAssemblagePieceCountAggregateOutputType> | number
          }
        }
      }
      SousAssemblageSousSousAssemblage: {
        payload: Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>
        fields: Prisma.SousAssemblageSousSousAssemblageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SousAssemblageSousSousAssemblageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SousAssemblageSousSousAssemblageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>
          }
          findFirst: {
            args: Prisma.SousAssemblageSousSousAssemblageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SousAssemblageSousSousAssemblageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>
          }
          findMany: {
            args: Prisma.SousAssemblageSousSousAssemblageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>[]
          }
          create: {
            args: Prisma.SousAssemblageSousSousAssemblageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>
          }
          createMany: {
            args: Prisma.SousAssemblageSousSousAssemblageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SousAssemblageSousSousAssemblageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>[]
          }
          delete: {
            args: Prisma.SousAssemblageSousSousAssemblageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>
          }
          update: {
            args: Prisma.SousAssemblageSousSousAssemblageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>
          }
          deleteMany: {
            args: Prisma.SousAssemblageSousSousAssemblageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SousAssemblageSousSousAssemblageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SousAssemblageSousSousAssemblageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>[]
          }
          upsert: {
            args: Prisma.SousAssemblageSousSousAssemblageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SousAssemblageSousSousAssemblagePayload>
          }
          aggregate: {
            args: Prisma.SousAssemblageSousSousAssemblageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSousAssemblageSousSousAssemblage>
          }
          groupBy: {
            args: Prisma.SousAssemblageSousSousAssemblageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SousAssemblageSousSousAssemblageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SousAssemblageSousSousAssemblageCountArgs<ExtArgs>
            result: $Utils.Optional<SousAssemblageSousSousAssemblageCountAggregateOutputType> | number
          }
        }
      }
      KitPiece: {
        payload: Prisma.$KitPiecePayload<ExtArgs>
        fields: Prisma.KitPieceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitPieceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitPieceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>
          }
          findFirst: {
            args: Prisma.KitPieceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitPieceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>
          }
          findMany: {
            args: Prisma.KitPieceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>[]
          }
          create: {
            args: Prisma.KitPieceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>
          }
          createMany: {
            args: Prisma.KitPieceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitPieceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>[]
          }
          delete: {
            args: Prisma.KitPieceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>
          }
          update: {
            args: Prisma.KitPieceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>
          }
          deleteMany: {
            args: Prisma.KitPieceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitPieceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KitPieceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>[]
          }
          upsert: {
            args: Prisma.KitPieceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitPiecePayload>
          }
          aggregate: {
            args: Prisma.KitPieceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKitPiece>
          }
          groupBy: {
            args: Prisma.KitPieceGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitPieceGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitPieceCountArgs<ExtArgs>
            result: $Utils.Optional<KitPieceCountAggregateOutputType> | number
          }
        }
      }
      StockLog: {
        payload: Prisma.$StockLogPayload<ExtArgs>
        fields: Prisma.StockLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          findFirst: {
            args: Prisma.StockLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          findMany: {
            args: Prisma.StockLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>[]
          }
          create: {
            args: Prisma.StockLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          createMany: {
            args: Prisma.StockLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>[]
          }
          delete: {
            args: Prisma.StockLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          update: {
            args: Prisma.StockLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          deleteMany: {
            args: Prisma.StockLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>[]
          }
          upsert: {
            args: Prisma.StockLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLogPayload>
          }
          aggregate: {
            args: Prisma.StockLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockLog>
          }
          groupBy: {
            args: Prisma.StockLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockLogCountArgs<ExtArgs>
            result: $Utils.Optional<StockLogCountAggregateOutputType> | number
          }
        }
      }
      TaskTemplate: {
        payload: Prisma.$TaskTemplatePayload<ExtArgs>
        fields: Prisma.TaskTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>
          }
          findFirst: {
            args: Prisma.TaskTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>
          }
          findMany: {
            args: Prisma.TaskTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>[]
          }
          create: {
            args: Prisma.TaskTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>
          }
          createMany: {
            args: Prisma.TaskTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>[]
          }
          delete: {
            args: Prisma.TaskTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>
          }
          update: {
            args: Prisma.TaskTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>
          }
          deleteMany: {
            args: Prisma.TaskTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>[]
          }
          upsert: {
            args: Prisma.TaskTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePayload>
          }
          aggregate: {
            args: Prisma.TaskTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTemplate>
          }
          groupBy: {
            args: Prisma.TaskTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateCountAggregateOutputType> | number
          }
        }
      }
      Production: {
        payload: Prisma.$ProductionPayload<ExtArgs>
        fields: Prisma.ProductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          findFirst: {
            args: Prisma.ProductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          findMany: {
            args: Prisma.ProductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>[]
          }
          create: {
            args: Prisma.ProductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          createMany: {
            args: Prisma.ProductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>[]
          }
          delete: {
            args: Prisma.ProductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          update: {
            args: Prisma.ProductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          deleteMany: {
            args: Prisma.ProductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>[]
          }
          upsert: {
            args: Prisma.ProductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          aggregate: {
            args: Prisma.ProductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduction>
          }
          groupBy: {
            args: Prisma.ProductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionCountAggregateOutputType> | number
          }
        }
      }
      ProductionLine: {
        payload: Prisma.$ProductionLinePayload<ExtArgs>
        fields: Prisma.ProductionLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>
          }
          findFirst: {
            args: Prisma.ProductionLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>
          }
          findMany: {
            args: Prisma.ProductionLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>[]
          }
          create: {
            args: Prisma.ProductionLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>
          }
          createMany: {
            args: Prisma.ProductionLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>[]
          }
          delete: {
            args: Prisma.ProductionLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>
          }
          update: {
            args: Prisma.ProductionLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>
          }
          deleteMany: {
            args: Prisma.ProductionLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>[]
          }
          upsert: {
            args: Prisma.ProductionLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionLinePayload>
          }
          aggregate: {
            args: Prisma.ProductionLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionLine>
          }
          groupBy: {
            args: Prisma.ProductionLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionLineCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionLineCountAggregateOutputType> | number
          }
        }
      }
      ProductionTask: {
        payload: Prisma.$ProductionTaskPayload<ExtArgs>
        fields: Prisma.ProductionTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          findFirst: {
            args: Prisma.ProductionTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          findMany: {
            args: Prisma.ProductionTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>[]
          }
          create: {
            args: Prisma.ProductionTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          createMany: {
            args: Prisma.ProductionTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>[]
          }
          delete: {
            args: Prisma.ProductionTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          update: {
            args: Prisma.ProductionTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          deleteMany: {
            args: Prisma.ProductionTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>[]
          }
          upsert: {
            args: Prisma.ProductionTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          aggregate: {
            args: Prisma.ProductionTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionTask>
          }
          groupBy: {
            args: Prisma.ProductionTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionTaskCountAggregateOutputType> | number
          }
        }
      }
      ProductionTaskLog: {
        payload: Prisma.$ProductionTaskLogPayload<ExtArgs>
        fields: Prisma.ProductionTaskLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionTaskLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionTaskLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>
          }
          findFirst: {
            args: Prisma.ProductionTaskLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionTaskLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>
          }
          findMany: {
            args: Prisma.ProductionTaskLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>[]
          }
          create: {
            args: Prisma.ProductionTaskLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>
          }
          createMany: {
            args: Prisma.ProductionTaskLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionTaskLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>[]
          }
          delete: {
            args: Prisma.ProductionTaskLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>
          }
          update: {
            args: Prisma.ProductionTaskLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>
          }
          deleteMany: {
            args: Prisma.ProductionTaskLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionTaskLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionTaskLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>[]
          }
          upsert: {
            args: Prisma.ProductionTaskLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskLogPayload>
          }
          aggregate: {
            args: Prisma.ProductionTaskLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionTaskLog>
          }
          groupBy: {
            args: Prisma.ProductionTaskLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionTaskLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionTaskLogCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionTaskLogCountAggregateOutputType> | number
          }
        }
      }
      TaskTemplatePiece: {
        payload: Prisma.$TaskTemplatePiecePayload<ExtArgs>
        fields: Prisma.TaskTemplatePieceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTemplatePieceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTemplatePieceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>
          }
          findFirst: {
            args: Prisma.TaskTemplatePieceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTemplatePieceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>
          }
          findMany: {
            args: Prisma.TaskTemplatePieceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>[]
          }
          create: {
            args: Prisma.TaskTemplatePieceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>
          }
          createMany: {
            args: Prisma.TaskTemplatePieceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTemplatePieceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>[]
          }
          delete: {
            args: Prisma.TaskTemplatePieceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>
          }
          update: {
            args: Prisma.TaskTemplatePieceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>
          }
          deleteMany: {
            args: Prisma.TaskTemplatePieceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTemplatePieceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTemplatePieceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>[]
          }
          upsert: {
            args: Prisma.TaskTemplatePieceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplatePiecePayload>
          }
          aggregate: {
            args: Prisma.TaskTemplatePieceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTemplatePiece>
          }
          groupBy: {
            args: Prisma.TaskTemplatePieceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplatePieceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTemplatePieceCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplatePieceCountAggregateOutputType> | number
          }
        }
      }
      TaskTemplateSousAssemblage: {
        payload: Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>
        fields: Prisma.TaskTemplateSousAssemblageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTemplateSousAssemblageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTemplateSousAssemblageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>
          }
          findFirst: {
            args: Prisma.TaskTemplateSousAssemblageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTemplateSousAssemblageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>
          }
          findMany: {
            args: Prisma.TaskTemplateSousAssemblageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>[]
          }
          create: {
            args: Prisma.TaskTemplateSousAssemblageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>
          }
          createMany: {
            args: Prisma.TaskTemplateSousAssemblageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTemplateSousAssemblageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>[]
          }
          delete: {
            args: Prisma.TaskTemplateSousAssemblageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>
          }
          update: {
            args: Prisma.TaskTemplateSousAssemblageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>
          }
          deleteMany: {
            args: Prisma.TaskTemplateSousAssemblageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTemplateSousAssemblageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTemplateSousAssemblageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>[]
          }
          upsert: {
            args: Prisma.TaskTemplateSousAssemblageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousAssemblagePayload>
          }
          aggregate: {
            args: Prisma.TaskTemplateSousAssemblageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTemplateSousAssemblage>
          }
          groupBy: {
            args: Prisma.TaskTemplateSousAssemblageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateSousAssemblageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTemplateSousAssemblageCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateSousAssemblageCountAggregateOutputType> | number
          }
        }
      }
      TaskTemplateSousSousAssemblage: {
        payload: Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>
        fields: Prisma.TaskTemplateSousSousAssemblageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTemplateSousSousAssemblageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTemplateSousSousAssemblageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>
          }
          findFirst: {
            args: Prisma.TaskTemplateSousSousAssemblageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTemplateSousSousAssemblageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>
          }
          findMany: {
            args: Prisma.TaskTemplateSousSousAssemblageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>[]
          }
          create: {
            args: Prisma.TaskTemplateSousSousAssemblageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>
          }
          createMany: {
            args: Prisma.TaskTemplateSousSousAssemblageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTemplateSousSousAssemblageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>[]
          }
          delete: {
            args: Prisma.TaskTemplateSousSousAssemblageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>
          }
          update: {
            args: Prisma.TaskTemplateSousSousAssemblageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>
          }
          deleteMany: {
            args: Prisma.TaskTemplateSousSousAssemblageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTemplateSousSousAssemblageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTemplateSousSousAssemblageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>[]
          }
          upsert: {
            args: Prisma.TaskTemplateSousSousAssemblageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateSousSousAssemblagePayload>
          }
          aggregate: {
            args: Prisma.TaskTemplateSousSousAssemblageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTemplateSousSousAssemblage>
          }
          groupBy: {
            args: Prisma.TaskTemplateSousSousAssemblageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateSousSousAssemblageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTemplateSousSousAssemblageCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateSousSousAssemblageCountAggregateOutputType> | number
          }
        }
      }
      TaskTemplateLog: {
        payload: Prisma.$TaskTemplateLogPayload<ExtArgs>
        fields: Prisma.TaskTemplateLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTemplateLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTemplateLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>
          }
          findFirst: {
            args: Prisma.TaskTemplateLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTemplateLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>
          }
          findMany: {
            args: Prisma.TaskTemplateLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>[]
          }
          create: {
            args: Prisma.TaskTemplateLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>
          }
          createMany: {
            args: Prisma.TaskTemplateLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTemplateLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>[]
          }
          delete: {
            args: Prisma.TaskTemplateLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>
          }
          update: {
            args: Prisma.TaskTemplateLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>
          }
          deleteMany: {
            args: Prisma.TaskTemplateLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTemplateLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTemplateLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>[]
          }
          upsert: {
            args: Prisma.TaskTemplateLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTemplateLogPayload>
          }
          aggregate: {
            args: Prisma.TaskTemplateLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTemplateLog>
          }
          groupBy: {
            args: Prisma.TaskTemplateLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTemplateLogCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTemplateLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    borne?: BorneOmit
    user?: UserOmit
    piece?: PieceOmit
    sousAssemblage?: SousAssemblageOmit
    sousSousAssemblage?: SousSousAssemblageOmit
    kit?: KitOmit
    sousAssemblagePiece?: SousAssemblagePieceOmit
    sousSousAssemblagePiece?: SousSousAssemblagePieceOmit
    sousAssemblageSousSousAssemblage?: SousAssemblageSousSousAssemblageOmit
    kitPiece?: KitPieceOmit
    stockLog?: StockLogOmit
    taskTemplate?: TaskTemplateOmit
    production?: ProductionOmit
    productionLine?: ProductionLineOmit
    productionTask?: ProductionTaskOmit
    productionTaskLog?: ProductionTaskLogOmit
    taskTemplatePiece?: TaskTemplatePieceOmit
    taskTemplateSousAssemblage?: TaskTemplateSousAssemblageOmit
    taskTemplateSousSousAssemblage?: TaskTemplateSousSousAssemblageOmit
    taskTemplateLog?: TaskTemplateLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BorneCountOutputType
   */

  export type BorneCountOutputType = {
    productionLines: number
    taskTemplates: number
    kits: number
    pieces: number
    sousAssemblages: number
    sousSousAssemblages: number
  }

  export type BorneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionLines?: boolean | BorneCountOutputTypeCountProductionLinesArgs
    taskTemplates?: boolean | BorneCountOutputTypeCountTaskTemplatesArgs
    kits?: boolean | BorneCountOutputTypeCountKitsArgs
    pieces?: boolean | BorneCountOutputTypeCountPiecesArgs
    sousAssemblages?: boolean | BorneCountOutputTypeCountSousAssemblagesArgs
    sousSousAssemblages?: boolean | BorneCountOutputTypeCountSousSousAssemblagesArgs
  }

  // Custom InputTypes
  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorneCountOutputType
     */
    select?: BorneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeCountProductionLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionLineWhereInput
  }

  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeCountTaskTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateWhereInput
  }

  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeCountKitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitWhereInput
  }

  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeCountPiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PieceWhereInput
  }

  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeCountSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblageWhereInput
  }

  /**
   * BorneCountOutputType without action
   */
  export type BorneCountOutputTypeCountSousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousSousAssemblageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedTasks: number
    taskLogs: number
    stockLogs: number
    templateLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    taskLogs?: boolean | UserCountOutputTypeCountTaskLogsArgs
    stockLogs?: boolean | UserCountOutputTypeCountStockLogsArgs
    templateLogs?: boolean | UserCountOutputTypeCountTemplateLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemplateLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateLogWhereInput
  }


  /**
   * Count Type PieceCountOutputType
   */

  export type PieceCountOutputType = {
    kits: number
    sousAssemblages: number
    sousSousAssemblages: number
    taskTemplatePieces: number
    bornes: number
  }

  export type PieceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kits?: boolean | PieceCountOutputTypeCountKitsArgs
    sousAssemblages?: boolean | PieceCountOutputTypeCountSousAssemblagesArgs
    sousSousAssemblages?: boolean | PieceCountOutputTypeCountSousSousAssemblagesArgs
    taskTemplatePieces?: boolean | PieceCountOutputTypeCountTaskTemplatePiecesArgs
    bornes?: boolean | PieceCountOutputTypeCountBornesArgs
  }

  // Custom InputTypes
  /**
   * PieceCountOutputType without action
   */
  export type PieceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceCountOutputType
     */
    select?: PieceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PieceCountOutputType without action
   */
  export type PieceCountOutputTypeCountKitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitPieceWhereInput
  }

  /**
   * PieceCountOutputType without action
   */
  export type PieceCountOutputTypeCountSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblagePieceWhereInput
  }

  /**
   * PieceCountOutputType without action
   */
  export type PieceCountOutputTypeCountSousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousSousAssemblagePieceWhereInput
  }

  /**
   * PieceCountOutputType without action
   */
  export type PieceCountOutputTypeCountTaskTemplatePiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplatePieceWhereInput
  }

  /**
   * PieceCountOutputType without action
   */
  export type PieceCountOutputTypeCountBornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorneWhereInput
  }


  /**
   * Count Type SousAssemblageCountOutputType
   */

  export type SousAssemblageCountOutputType = {
    pieces: number
    sousSousAssemblages: number
    taskTemplateSousAssemblages: number
    bornes: number
  }

  export type SousAssemblageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pieces?: boolean | SousAssemblageCountOutputTypeCountPiecesArgs
    sousSousAssemblages?: boolean | SousAssemblageCountOutputTypeCountSousSousAssemblagesArgs
    taskTemplateSousAssemblages?: boolean | SousAssemblageCountOutputTypeCountTaskTemplateSousAssemblagesArgs
    bornes?: boolean | SousAssemblageCountOutputTypeCountBornesArgs
  }

  // Custom InputTypes
  /**
   * SousAssemblageCountOutputType without action
   */
  export type SousAssemblageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageCountOutputType
     */
    select?: SousAssemblageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SousAssemblageCountOutputType without action
   */
  export type SousAssemblageCountOutputTypeCountPiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblagePieceWhereInput
  }

  /**
   * SousAssemblageCountOutputType without action
   */
  export type SousAssemblageCountOutputTypeCountSousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblageSousSousAssemblageWhereInput
  }

  /**
   * SousAssemblageCountOutputType without action
   */
  export type SousAssemblageCountOutputTypeCountTaskTemplateSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateSousAssemblageWhereInput
  }

  /**
   * SousAssemblageCountOutputType without action
   */
  export type SousAssemblageCountOutputTypeCountBornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorneWhereInput
  }


  /**
   * Count Type SousSousAssemblageCountOutputType
   */

  export type SousSousAssemblageCountOutputType = {
    sousAssemblages: number
    pieces: number
    taskTemplateSousSousAssemblages: number
    bornes: number
  }

  export type SousSousAssemblageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblages?: boolean | SousSousAssemblageCountOutputTypeCountSousAssemblagesArgs
    pieces?: boolean | SousSousAssemblageCountOutputTypeCountPiecesArgs
    taskTemplateSousSousAssemblages?: boolean | SousSousAssemblageCountOutputTypeCountTaskTemplateSousSousAssemblagesArgs
    bornes?: boolean | SousSousAssemblageCountOutputTypeCountBornesArgs
  }

  // Custom InputTypes
  /**
   * SousSousAssemblageCountOutputType without action
   */
  export type SousSousAssemblageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblageCountOutputType
     */
    select?: SousSousAssemblageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SousSousAssemblageCountOutputType without action
   */
  export type SousSousAssemblageCountOutputTypeCountSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblageSousSousAssemblageWhereInput
  }

  /**
   * SousSousAssemblageCountOutputType without action
   */
  export type SousSousAssemblageCountOutputTypeCountPiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousSousAssemblagePieceWhereInput
  }

  /**
   * SousSousAssemblageCountOutputType without action
   */
  export type SousSousAssemblageCountOutputTypeCountTaskTemplateSousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateSousSousAssemblageWhereInput
  }

  /**
   * SousSousAssemblageCountOutputType without action
   */
  export type SousSousAssemblageCountOutputTypeCountBornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorneWhereInput
  }


  /**
   * Count Type KitCountOutputType
   */

  export type KitCountOutputType = {
    pieces: number
    bornes: number
  }

  export type KitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pieces?: boolean | KitCountOutputTypeCountPiecesArgs
    bornes?: boolean | KitCountOutputTypeCountBornesArgs
  }

  // Custom InputTypes
  /**
   * KitCountOutputType without action
   */
  export type KitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitCountOutputType
     */
    select?: KitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KitCountOutputType without action
   */
  export type KitCountOutputTypeCountPiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitPieceWhereInput
  }

  /**
   * KitCountOutputType without action
   */
  export type KitCountOutputTypeCountBornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorneWhereInput
  }


  /**
   * Count Type TaskTemplateCountOutputType
   */

  export type TaskTemplateCountOutputType = {
    productionTasks: number
    logs: number
    pieces: number
    sousAssemblages: number
    sousSousAssemblages: number
  }

  export type TaskTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTasks?: boolean | TaskTemplateCountOutputTypeCountProductionTasksArgs
    logs?: boolean | TaskTemplateCountOutputTypeCountLogsArgs
    pieces?: boolean | TaskTemplateCountOutputTypeCountPiecesArgs
    sousAssemblages?: boolean | TaskTemplateCountOutputTypeCountSousAssemblagesArgs
    sousSousAssemblages?: boolean | TaskTemplateCountOutputTypeCountSousSousAssemblagesArgs
  }

  // Custom InputTypes
  /**
   * TaskTemplateCountOutputType without action
   */
  export type TaskTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateCountOutputType
     */
    select?: TaskTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskTemplateCountOutputType without action
   */
  export type TaskTemplateCountOutputTypeCountProductionTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskWhereInput
  }

  /**
   * TaskTemplateCountOutputType without action
   */
  export type TaskTemplateCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateLogWhereInput
  }

  /**
   * TaskTemplateCountOutputType without action
   */
  export type TaskTemplateCountOutputTypeCountPiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplatePieceWhereInput
  }

  /**
   * TaskTemplateCountOutputType without action
   */
  export type TaskTemplateCountOutputTypeCountSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateSousAssemblageWhereInput
  }

  /**
   * TaskTemplateCountOutputType without action
   */
  export type TaskTemplateCountOutputTypeCountSousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateSousSousAssemblageWhereInput
  }


  /**
   * Count Type ProductionCountOutputType
   */

  export type ProductionCountOutputType = {
    lines: number
    tasks: number
  }

  export type ProductionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | ProductionCountOutputTypeCountLinesArgs
    tasks?: boolean | ProductionCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProductionCountOutputType without action
   */
  export type ProductionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCountOutputType
     */
    select?: ProductionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionCountOutputType without action
   */
  export type ProductionCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionLineWhereInput
  }

  /**
   * ProductionCountOutputType without action
   */
  export type ProductionCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskWhereInput
  }


  /**
   * Count Type ProductionTaskCountOutputType
   */

  export type ProductionTaskCountOutputType = {
    logs: number
  }

  export type ProductionTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | ProductionTaskCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ProductionTaskCountOutputType without action
   */
  export type ProductionTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskCountOutputType
     */
    select?: ProductionTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionTaskCountOutputType without action
   */
  export type ProductionTaskCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Borne
   */

  export type AggregateBorne = {
    _count: BorneCountAggregateOutputType | null
    _avg: BorneAvgAggregateOutputType | null
    _sum: BorneSumAggregateOutputType | null
    _min: BorneMinAggregateOutputType | null
    _max: BorneMaxAggregateOutputType | null
  }

  export type BorneAvgAggregateOutputType = {
    id: number | null
  }

  export type BorneSumAggregateOutputType = {
    id: number | null
  }

  export type BorneMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type BorneMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type BorneCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type BorneAvgAggregateInputType = {
    id?: true
  }

  export type BorneSumAggregateInputType = {
    id?: true
  }

  export type BorneMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type BorneMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type BorneCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type BorneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Borne to aggregate.
     */
    where?: BorneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bornes to fetch.
     */
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BorneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bornes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bornes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bornes
    **/
    _count?: true | BorneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BorneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BorneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorneMaxAggregateInputType
  }

  export type GetBorneAggregateType<T extends BorneAggregateArgs> = {
        [P in keyof T & keyof AggregateBorne]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorne[P]>
      : GetScalarType<T[P], AggregateBorne[P]>
  }




  export type BorneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorneWhereInput
    orderBy?: BorneOrderByWithAggregationInput | BorneOrderByWithAggregationInput[]
    by: BorneScalarFieldEnum[] | BorneScalarFieldEnum
    having?: BorneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorneCountAggregateInputType | true
    _avg?: BorneAvgAggregateInputType
    _sum?: BorneSumAggregateInputType
    _min?: BorneMinAggregateInputType
    _max?: BorneMaxAggregateInputType
  }

  export type BorneGroupByOutputType = {
    id: number
    nom: string
    _count: BorneCountAggregateOutputType | null
    _avg: BorneAvgAggregateOutputType | null
    _sum: BorneSumAggregateOutputType | null
    _min: BorneMinAggregateOutputType | null
    _max: BorneMaxAggregateOutputType | null
  }

  type GetBorneGroupByPayload<T extends BorneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BorneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorneGroupByOutputType[P]>
            : GetScalarType<T[P], BorneGroupByOutputType[P]>
        }
      >
    >


  export type BorneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    productionLines?: boolean | Borne$productionLinesArgs<ExtArgs>
    taskTemplates?: boolean | Borne$taskTemplatesArgs<ExtArgs>
    kits?: boolean | Borne$kitsArgs<ExtArgs>
    pieces?: boolean | Borne$piecesArgs<ExtArgs>
    sousAssemblages?: boolean | Borne$sousAssemblagesArgs<ExtArgs>
    sousSousAssemblages?: boolean | Borne$sousSousAssemblagesArgs<ExtArgs>
    _count?: boolean | BorneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["borne"]>

  export type BorneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
  }, ExtArgs["result"]["borne"]>

  export type BorneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
  }, ExtArgs["result"]["borne"]>

  export type BorneSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type BorneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom", ExtArgs["result"]["borne"]>
  export type BorneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionLines?: boolean | Borne$productionLinesArgs<ExtArgs>
    taskTemplates?: boolean | Borne$taskTemplatesArgs<ExtArgs>
    kits?: boolean | Borne$kitsArgs<ExtArgs>
    pieces?: boolean | Borne$piecesArgs<ExtArgs>
    sousAssemblages?: boolean | Borne$sousAssemblagesArgs<ExtArgs>
    sousSousAssemblages?: boolean | Borne$sousSousAssemblagesArgs<ExtArgs>
    _count?: boolean | BorneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BorneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BorneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BornePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Borne"
    objects: {
      productionLines: Prisma.$ProductionLinePayload<ExtArgs>[]
      taskTemplates: Prisma.$TaskTemplatePayload<ExtArgs>[]
      kits: Prisma.$KitPayload<ExtArgs>[]
      pieces: Prisma.$PiecePayload<ExtArgs>[]
      sousAssemblages: Prisma.$SousAssemblagePayload<ExtArgs>[]
      sousSousAssemblages: Prisma.$SousSousAssemblagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["borne"]>
    composites: {}
  }

  type BorneGetPayload<S extends boolean | null | undefined | BorneDefaultArgs> = $Result.GetResult<Prisma.$BornePayload, S>

  type BorneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BorneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BorneCountAggregateInputType | true
    }

  export interface BorneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Borne'], meta: { name: 'Borne' } }
    /**
     * Find zero or one Borne that matches the filter.
     * @param {BorneFindUniqueArgs} args - Arguments to find a Borne
     * @example
     * // Get one Borne
     * const borne = await prisma.borne.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BorneFindUniqueArgs>(args: SelectSubset<T, BorneFindUniqueArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Borne that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BorneFindUniqueOrThrowArgs} args - Arguments to find a Borne
     * @example
     * // Get one Borne
     * const borne = await prisma.borne.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BorneFindUniqueOrThrowArgs>(args: SelectSubset<T, BorneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borne that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneFindFirstArgs} args - Arguments to find a Borne
     * @example
     * // Get one Borne
     * const borne = await prisma.borne.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BorneFindFirstArgs>(args?: SelectSubset<T, BorneFindFirstArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borne that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneFindFirstOrThrowArgs} args - Arguments to find a Borne
     * @example
     * // Get one Borne
     * const borne = await prisma.borne.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BorneFindFirstOrThrowArgs>(args?: SelectSubset<T, BorneFindFirstOrThrowArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bornes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bornes
     * const bornes = await prisma.borne.findMany()
     * 
     * // Get first 10 Bornes
     * const bornes = await prisma.borne.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borneWithIdOnly = await prisma.borne.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BorneFindManyArgs>(args?: SelectSubset<T, BorneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Borne.
     * @param {BorneCreateArgs} args - Arguments to create a Borne.
     * @example
     * // Create one Borne
     * const Borne = await prisma.borne.create({
     *   data: {
     *     // ... data to create a Borne
     *   }
     * })
     * 
     */
    create<T extends BorneCreateArgs>(args: SelectSubset<T, BorneCreateArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bornes.
     * @param {BorneCreateManyArgs} args - Arguments to create many Bornes.
     * @example
     * // Create many Bornes
     * const borne = await prisma.borne.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BorneCreateManyArgs>(args?: SelectSubset<T, BorneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bornes and returns the data saved in the database.
     * @param {BorneCreateManyAndReturnArgs} args - Arguments to create many Bornes.
     * @example
     * // Create many Bornes
     * const borne = await prisma.borne.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bornes and only return the `id`
     * const borneWithIdOnly = await prisma.borne.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BorneCreateManyAndReturnArgs>(args?: SelectSubset<T, BorneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Borne.
     * @param {BorneDeleteArgs} args - Arguments to delete one Borne.
     * @example
     * // Delete one Borne
     * const Borne = await prisma.borne.delete({
     *   where: {
     *     // ... filter to delete one Borne
     *   }
     * })
     * 
     */
    delete<T extends BorneDeleteArgs>(args: SelectSubset<T, BorneDeleteArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Borne.
     * @param {BorneUpdateArgs} args - Arguments to update one Borne.
     * @example
     * // Update one Borne
     * const borne = await prisma.borne.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BorneUpdateArgs>(args: SelectSubset<T, BorneUpdateArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bornes.
     * @param {BorneDeleteManyArgs} args - Arguments to filter Bornes to delete.
     * @example
     * // Delete a few Bornes
     * const { count } = await prisma.borne.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BorneDeleteManyArgs>(args?: SelectSubset<T, BorneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bornes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bornes
     * const borne = await prisma.borne.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BorneUpdateManyArgs>(args: SelectSubset<T, BorneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bornes and returns the data updated in the database.
     * @param {BorneUpdateManyAndReturnArgs} args - Arguments to update many Bornes.
     * @example
     * // Update many Bornes
     * const borne = await prisma.borne.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bornes and only return the `id`
     * const borneWithIdOnly = await prisma.borne.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BorneUpdateManyAndReturnArgs>(args: SelectSubset<T, BorneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Borne.
     * @param {BorneUpsertArgs} args - Arguments to update or create a Borne.
     * @example
     * // Update or create a Borne
     * const borne = await prisma.borne.upsert({
     *   create: {
     *     // ... data to create a Borne
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Borne we want to update
     *   }
     * })
     */
    upsert<T extends BorneUpsertArgs>(args: SelectSubset<T, BorneUpsertArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bornes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneCountArgs} args - Arguments to filter Bornes to count.
     * @example
     * // Count the number of Bornes
     * const count = await prisma.borne.count({
     *   where: {
     *     // ... the filter for the Bornes we want to count
     *   }
     * })
    **/
    count<T extends BorneCountArgs>(
      args?: Subset<T, BorneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Borne.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorneAggregateArgs>(args: Subset<T, BorneAggregateArgs>): Prisma.PrismaPromise<GetBorneAggregateType<T>>

    /**
     * Group by Borne.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorneGroupByArgs['orderBy'] }
        : { orderBy?: BorneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Borne model
   */
  readonly fields: BorneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Borne.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BorneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionLines<T extends Borne$productionLinesArgs<ExtArgs> = {}>(args?: Subset<T, Borne$productionLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskTemplates<T extends Borne$taskTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Borne$taskTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kits<T extends Borne$kitsArgs<ExtArgs> = {}>(args?: Subset<T, Borne$kitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pieces<T extends Borne$piecesArgs<ExtArgs> = {}>(args?: Subset<T, Borne$piecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousAssemblages<T extends Borne$sousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, Borne$sousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousSousAssemblages<T extends Borne$sousSousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, Borne$sousSousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Borne model
   */
  interface BorneFieldRefs {
    readonly id: FieldRef<"Borne", 'Int'>
    readonly nom: FieldRef<"Borne", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Borne findUnique
   */
  export type BorneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * Filter, which Borne to fetch.
     */
    where: BorneWhereUniqueInput
  }

  /**
   * Borne findUniqueOrThrow
   */
  export type BorneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * Filter, which Borne to fetch.
     */
    where: BorneWhereUniqueInput
  }

  /**
   * Borne findFirst
   */
  export type BorneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * Filter, which Borne to fetch.
     */
    where?: BorneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bornes to fetch.
     */
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bornes.
     */
    cursor?: BorneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bornes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bornes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bornes.
     */
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * Borne findFirstOrThrow
   */
  export type BorneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * Filter, which Borne to fetch.
     */
    where?: BorneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bornes to fetch.
     */
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bornes.
     */
    cursor?: BorneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bornes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bornes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bornes.
     */
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * Borne findMany
   */
  export type BorneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * Filter, which Bornes to fetch.
     */
    where?: BorneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bornes to fetch.
     */
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bornes.
     */
    cursor?: BorneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bornes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bornes.
     */
    skip?: number
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * Borne create
   */
  export type BorneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * The data needed to create a Borne.
     */
    data: XOR<BorneCreateInput, BorneUncheckedCreateInput>
  }

  /**
   * Borne createMany
   */
  export type BorneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bornes.
     */
    data: BorneCreateManyInput | BorneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Borne createManyAndReturn
   */
  export type BorneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * The data used to create many Bornes.
     */
    data: BorneCreateManyInput | BorneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Borne update
   */
  export type BorneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * The data needed to update a Borne.
     */
    data: XOR<BorneUpdateInput, BorneUncheckedUpdateInput>
    /**
     * Choose, which Borne to update.
     */
    where: BorneWhereUniqueInput
  }

  /**
   * Borne updateMany
   */
  export type BorneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bornes.
     */
    data: XOR<BorneUpdateManyMutationInput, BorneUncheckedUpdateManyInput>
    /**
     * Filter which Bornes to update
     */
    where?: BorneWhereInput
    /**
     * Limit how many Bornes to update.
     */
    limit?: number
  }

  /**
   * Borne updateManyAndReturn
   */
  export type BorneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * The data used to update Bornes.
     */
    data: XOR<BorneUpdateManyMutationInput, BorneUncheckedUpdateManyInput>
    /**
     * Filter which Bornes to update
     */
    where?: BorneWhereInput
    /**
     * Limit how many Bornes to update.
     */
    limit?: number
  }

  /**
   * Borne upsert
   */
  export type BorneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * The filter to search for the Borne to update in case it exists.
     */
    where: BorneWhereUniqueInput
    /**
     * In case the Borne found by the `where` argument doesn't exist, create a new Borne with this data.
     */
    create: XOR<BorneCreateInput, BorneUncheckedCreateInput>
    /**
     * In case the Borne was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BorneUpdateInput, BorneUncheckedUpdateInput>
  }

  /**
   * Borne delete
   */
  export type BorneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    /**
     * Filter which Borne to delete.
     */
    where: BorneWhereUniqueInput
  }

  /**
   * Borne deleteMany
   */
  export type BorneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bornes to delete
     */
    where?: BorneWhereInput
    /**
     * Limit how many Bornes to delete.
     */
    limit?: number
  }

  /**
   * Borne.productionLines
   */
  export type Borne$productionLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    where?: ProductionLineWhereInput
    orderBy?: ProductionLineOrderByWithRelationInput | ProductionLineOrderByWithRelationInput[]
    cursor?: ProductionLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionLineScalarFieldEnum | ProductionLineScalarFieldEnum[]
  }

  /**
   * Borne.taskTemplates
   */
  export type Borne$taskTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    where?: TaskTemplateWhereInput
    orderBy?: TaskTemplateOrderByWithRelationInput | TaskTemplateOrderByWithRelationInput[]
    cursor?: TaskTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateScalarFieldEnum | TaskTemplateScalarFieldEnum[]
  }

  /**
   * Borne.kits
   */
  export type Borne$kitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    where?: KitWhereInput
    orderBy?: KitOrderByWithRelationInput | KitOrderByWithRelationInput[]
    cursor?: KitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitScalarFieldEnum | KitScalarFieldEnum[]
  }

  /**
   * Borne.pieces
   */
  export type Borne$piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    where?: PieceWhereInput
    orderBy?: PieceOrderByWithRelationInput | PieceOrderByWithRelationInput[]
    cursor?: PieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PieceScalarFieldEnum | PieceScalarFieldEnum[]
  }

  /**
   * Borne.sousAssemblages
   */
  export type Borne$sousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    where?: SousAssemblageWhereInput
    orderBy?: SousAssemblageOrderByWithRelationInput | SousAssemblageOrderByWithRelationInput[]
    cursor?: SousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousAssemblageScalarFieldEnum | SousAssemblageScalarFieldEnum[]
  }

  /**
   * Borne.sousSousAssemblages
   */
  export type Borne$sousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    where?: SousSousAssemblageWhereInput
    orderBy?: SousSousAssemblageOrderByWithRelationInput | SousSousAssemblageOrderByWithRelationInput[]
    cursor?: SousSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousSousAssemblageScalarFieldEnum | SousSousAssemblageScalarFieldEnum[]
  }

  /**
   * Borne without action
   */
  export type BorneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    nom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    nom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    nom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    nom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    nom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    nom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: $Enums.Role
    nom: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    taskLogs?: boolean | User$taskLogsArgs<ExtArgs>
    stockLogs?: boolean | User$stockLogsArgs<ExtArgs>
    templateLogs?: boolean | User$templateLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "nom" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    taskLogs?: boolean | User$taskLogsArgs<ExtArgs>
    stockLogs?: boolean | User$stockLogsArgs<ExtArgs>
    templateLogs?: boolean | User$templateLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      assignedTasks: Prisma.$ProductionTaskPayload<ExtArgs>[]
      taskLogs: Prisma.$ProductionTaskLogPayload<ExtArgs>[]
      stockLogs: Prisma.$StockLogPayload<ExtArgs>[]
      templateLogs: Prisma.$TaskTemplateLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: $Enums.Role
      nom: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskLogs<T extends User$taskLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockLogs<T extends User$stockLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$stockLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templateLogs<T extends User$templateLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$templateLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly nom: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    where?: ProductionTaskWhereInput
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    cursor?: ProductionTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * User.taskLogs
   */
  export type User$taskLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    where?: ProductionTaskLogWhereInput
    orderBy?: ProductionTaskLogOrderByWithRelationInput | ProductionTaskLogOrderByWithRelationInput[]
    cursor?: ProductionTaskLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionTaskLogScalarFieldEnum | ProductionTaskLogScalarFieldEnum[]
  }

  /**
   * User.stockLogs
   */
  export type User$stockLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    where?: StockLogWhereInput
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    cursor?: StockLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * User.templateLogs
   */
  export type User$templateLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    where?: TaskTemplateLogWhereInput
    orderBy?: TaskTemplateLogOrderByWithRelationInput | TaskTemplateLogOrderByWithRelationInput[]
    cursor?: TaskTemplateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateLogScalarFieldEnum | TaskTemplateLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Piece
   */

  export type AggregatePiece = {
    _count: PieceCountAggregateOutputType | null
    _avg: PieceAvgAggregateOutputType | null
    _sum: PieceSumAggregateOutputType | null
    _min: PieceMinAggregateOutputType | null
    _max: PieceMaxAggregateOutputType | null
  }

  export type PieceAvgAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type PieceSumAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type PieceMinAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    nombre: number | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type PieceMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    nombre: number | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type PieceCountAggregateOutputType = {
    id: number
    nom: number
    reference: number
    nombre: number
    photo: number
    emplacement: number
    createdAt: number
    updatedAt: number
    archived: number
    seuilAlerte: number
    etat: number
    numero: number
    type: number
    version: number
    _all: number
  }


  export type PieceAvgAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type PieceSumAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type PieceMinAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    nombre?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type PieceMaxAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    nombre?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type PieceCountAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    nombre?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
    _all?: true
  }

  export type PieceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Piece to aggregate.
     */
    where?: PieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pieces to fetch.
     */
    orderBy?: PieceOrderByWithRelationInput | PieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pieces
    **/
    _count?: true | PieceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PieceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PieceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PieceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PieceMaxAggregateInputType
  }

  export type GetPieceAggregateType<T extends PieceAggregateArgs> = {
        [P in keyof T & keyof AggregatePiece]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePiece[P]>
      : GetScalarType<T[P], AggregatePiece[P]>
  }




  export type PieceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PieceWhereInput
    orderBy?: PieceOrderByWithAggregationInput | PieceOrderByWithAggregationInput[]
    by: PieceScalarFieldEnum[] | PieceScalarFieldEnum
    having?: PieceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PieceCountAggregateInputType | true
    _avg?: PieceAvgAggregateInputType
    _sum?: PieceSumAggregateInputType
    _min?: PieceMinAggregateInputType
    _max?: PieceMaxAggregateInputType
  }

  export type PieceGroupByOutputType = {
    id: number
    nom: string
    reference: string
    nombre: number
    photo: string | null
    emplacement: string
    createdAt: Date
    updatedAt: Date
    archived: boolean
    seuilAlerte: number
    etat: $Enums.PieceEtat
    numero: string | null
    type: $Enums.PieceType
    version: string
    _count: PieceCountAggregateOutputType | null
    _avg: PieceAvgAggregateOutputType | null
    _sum: PieceSumAggregateOutputType | null
    _min: PieceMinAggregateOutputType | null
    _max: PieceMaxAggregateOutputType | null
  }

  type GetPieceGroupByPayload<T extends PieceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PieceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PieceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PieceGroupByOutputType[P]>
            : GetScalarType<T[P], PieceGroupByOutputType[P]>
        }
      >
    >


  export type PieceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    nombre?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
    kits?: boolean | Piece$kitsArgs<ExtArgs>
    sousAssemblages?: boolean | Piece$sousAssemblagesArgs<ExtArgs>
    sousSousAssemblages?: boolean | Piece$sousSousAssemblagesArgs<ExtArgs>
    taskTemplatePieces?: boolean | Piece$taskTemplatePiecesArgs<ExtArgs>
    bornes?: boolean | Piece$bornesArgs<ExtArgs>
    _count?: boolean | PieceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["piece"]>

  export type PieceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    nombre?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["piece"]>

  export type PieceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    nombre?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["piece"]>

  export type PieceSelectScalar = {
    id?: boolean
    nom?: boolean
    reference?: boolean
    nombre?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }

  export type PieceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "reference" | "nombre" | "photo" | "emplacement" | "createdAt" | "updatedAt" | "archived" | "seuilAlerte" | "etat" | "numero" | "type" | "version", ExtArgs["result"]["piece"]>
  export type PieceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kits?: boolean | Piece$kitsArgs<ExtArgs>
    sousAssemblages?: boolean | Piece$sousAssemblagesArgs<ExtArgs>
    sousSousAssemblages?: boolean | Piece$sousSousAssemblagesArgs<ExtArgs>
    taskTemplatePieces?: boolean | Piece$taskTemplatePiecesArgs<ExtArgs>
    bornes?: boolean | Piece$bornesArgs<ExtArgs>
    _count?: boolean | PieceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PieceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PieceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PiecePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Piece"
    objects: {
      kits: Prisma.$KitPiecePayload<ExtArgs>[]
      sousAssemblages: Prisma.$SousAssemblagePiecePayload<ExtArgs>[]
      sousSousAssemblages: Prisma.$SousSousAssemblagePiecePayload<ExtArgs>[]
      taskTemplatePieces: Prisma.$TaskTemplatePiecePayload<ExtArgs>[]
      bornes: Prisma.$BornePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      reference: string
      nombre: number
      photo: string | null
      emplacement: string
      createdAt: Date
      updatedAt: Date
      archived: boolean
      seuilAlerte: number
      etat: $Enums.PieceEtat
      numero: string | null
      type: $Enums.PieceType
      version: string
    }, ExtArgs["result"]["piece"]>
    composites: {}
  }

  type PieceGetPayload<S extends boolean | null | undefined | PieceDefaultArgs> = $Result.GetResult<Prisma.$PiecePayload, S>

  type PieceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PieceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PieceCountAggregateInputType | true
    }

  export interface PieceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Piece'], meta: { name: 'Piece' } }
    /**
     * Find zero or one Piece that matches the filter.
     * @param {PieceFindUniqueArgs} args - Arguments to find a Piece
     * @example
     * // Get one Piece
     * const piece = await prisma.piece.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PieceFindUniqueArgs>(args: SelectSubset<T, PieceFindUniqueArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Piece that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PieceFindUniqueOrThrowArgs} args - Arguments to find a Piece
     * @example
     * // Get one Piece
     * const piece = await prisma.piece.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PieceFindUniqueOrThrowArgs>(args: SelectSubset<T, PieceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Piece that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceFindFirstArgs} args - Arguments to find a Piece
     * @example
     * // Get one Piece
     * const piece = await prisma.piece.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PieceFindFirstArgs>(args?: SelectSubset<T, PieceFindFirstArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Piece that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceFindFirstOrThrowArgs} args - Arguments to find a Piece
     * @example
     * // Get one Piece
     * const piece = await prisma.piece.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PieceFindFirstOrThrowArgs>(args?: SelectSubset<T, PieceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pieces
     * const pieces = await prisma.piece.findMany()
     * 
     * // Get first 10 Pieces
     * const pieces = await prisma.piece.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pieceWithIdOnly = await prisma.piece.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PieceFindManyArgs>(args?: SelectSubset<T, PieceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Piece.
     * @param {PieceCreateArgs} args - Arguments to create a Piece.
     * @example
     * // Create one Piece
     * const Piece = await prisma.piece.create({
     *   data: {
     *     // ... data to create a Piece
     *   }
     * })
     * 
     */
    create<T extends PieceCreateArgs>(args: SelectSubset<T, PieceCreateArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pieces.
     * @param {PieceCreateManyArgs} args - Arguments to create many Pieces.
     * @example
     * // Create many Pieces
     * const piece = await prisma.piece.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PieceCreateManyArgs>(args?: SelectSubset<T, PieceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pieces and returns the data saved in the database.
     * @param {PieceCreateManyAndReturnArgs} args - Arguments to create many Pieces.
     * @example
     * // Create many Pieces
     * const piece = await prisma.piece.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pieces and only return the `id`
     * const pieceWithIdOnly = await prisma.piece.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PieceCreateManyAndReturnArgs>(args?: SelectSubset<T, PieceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Piece.
     * @param {PieceDeleteArgs} args - Arguments to delete one Piece.
     * @example
     * // Delete one Piece
     * const Piece = await prisma.piece.delete({
     *   where: {
     *     // ... filter to delete one Piece
     *   }
     * })
     * 
     */
    delete<T extends PieceDeleteArgs>(args: SelectSubset<T, PieceDeleteArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Piece.
     * @param {PieceUpdateArgs} args - Arguments to update one Piece.
     * @example
     * // Update one Piece
     * const piece = await prisma.piece.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PieceUpdateArgs>(args: SelectSubset<T, PieceUpdateArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pieces.
     * @param {PieceDeleteManyArgs} args - Arguments to filter Pieces to delete.
     * @example
     * // Delete a few Pieces
     * const { count } = await prisma.piece.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PieceDeleteManyArgs>(args?: SelectSubset<T, PieceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pieces
     * const piece = await prisma.piece.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PieceUpdateManyArgs>(args: SelectSubset<T, PieceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pieces and returns the data updated in the database.
     * @param {PieceUpdateManyAndReturnArgs} args - Arguments to update many Pieces.
     * @example
     * // Update many Pieces
     * const piece = await prisma.piece.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pieces and only return the `id`
     * const pieceWithIdOnly = await prisma.piece.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PieceUpdateManyAndReturnArgs>(args: SelectSubset<T, PieceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Piece.
     * @param {PieceUpsertArgs} args - Arguments to update or create a Piece.
     * @example
     * // Update or create a Piece
     * const piece = await prisma.piece.upsert({
     *   create: {
     *     // ... data to create a Piece
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Piece we want to update
     *   }
     * })
     */
    upsert<T extends PieceUpsertArgs>(args: SelectSubset<T, PieceUpsertArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceCountArgs} args - Arguments to filter Pieces to count.
     * @example
     * // Count the number of Pieces
     * const count = await prisma.piece.count({
     *   where: {
     *     // ... the filter for the Pieces we want to count
     *   }
     * })
    **/
    count<T extends PieceCountArgs>(
      args?: Subset<T, PieceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PieceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Piece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PieceAggregateArgs>(args: Subset<T, PieceAggregateArgs>): Prisma.PrismaPromise<GetPieceAggregateType<T>>

    /**
     * Group by Piece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PieceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PieceGroupByArgs['orderBy'] }
        : { orderBy?: PieceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PieceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPieceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Piece model
   */
  readonly fields: PieceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Piece.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PieceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kits<T extends Piece$kitsArgs<ExtArgs> = {}>(args?: Subset<T, Piece$kitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousAssemblages<T extends Piece$sousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, Piece$sousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousSousAssemblages<T extends Piece$sousSousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, Piece$sousSousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskTemplatePieces<T extends Piece$taskTemplatePiecesArgs<ExtArgs> = {}>(args?: Subset<T, Piece$taskTemplatePiecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bornes<T extends Piece$bornesArgs<ExtArgs> = {}>(args?: Subset<T, Piece$bornesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Piece model
   */
  interface PieceFieldRefs {
    readonly id: FieldRef<"Piece", 'Int'>
    readonly nom: FieldRef<"Piece", 'String'>
    readonly reference: FieldRef<"Piece", 'String'>
    readonly nombre: FieldRef<"Piece", 'Int'>
    readonly photo: FieldRef<"Piece", 'String'>
    readonly emplacement: FieldRef<"Piece", 'String'>
    readonly createdAt: FieldRef<"Piece", 'DateTime'>
    readonly updatedAt: FieldRef<"Piece", 'DateTime'>
    readonly archived: FieldRef<"Piece", 'Boolean'>
    readonly seuilAlerte: FieldRef<"Piece", 'Int'>
    readonly etat: FieldRef<"Piece", 'PieceEtat'>
    readonly numero: FieldRef<"Piece", 'String'>
    readonly type: FieldRef<"Piece", 'PieceType'>
    readonly version: FieldRef<"Piece", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Piece findUnique
   */
  export type PieceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * Filter, which Piece to fetch.
     */
    where: PieceWhereUniqueInput
  }

  /**
   * Piece findUniqueOrThrow
   */
  export type PieceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * Filter, which Piece to fetch.
     */
    where: PieceWhereUniqueInput
  }

  /**
   * Piece findFirst
   */
  export type PieceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * Filter, which Piece to fetch.
     */
    where?: PieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pieces to fetch.
     */
    orderBy?: PieceOrderByWithRelationInput | PieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pieces.
     */
    cursor?: PieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pieces.
     */
    distinct?: PieceScalarFieldEnum | PieceScalarFieldEnum[]
  }

  /**
   * Piece findFirstOrThrow
   */
  export type PieceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * Filter, which Piece to fetch.
     */
    where?: PieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pieces to fetch.
     */
    orderBy?: PieceOrderByWithRelationInput | PieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pieces.
     */
    cursor?: PieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pieces.
     */
    distinct?: PieceScalarFieldEnum | PieceScalarFieldEnum[]
  }

  /**
   * Piece findMany
   */
  export type PieceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * Filter, which Pieces to fetch.
     */
    where?: PieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pieces to fetch.
     */
    orderBy?: PieceOrderByWithRelationInput | PieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pieces.
     */
    cursor?: PieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pieces.
     */
    skip?: number
    distinct?: PieceScalarFieldEnum | PieceScalarFieldEnum[]
  }

  /**
   * Piece create
   */
  export type PieceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * The data needed to create a Piece.
     */
    data: XOR<PieceCreateInput, PieceUncheckedCreateInput>
  }

  /**
   * Piece createMany
   */
  export type PieceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pieces.
     */
    data: PieceCreateManyInput | PieceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Piece createManyAndReturn
   */
  export type PieceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * The data used to create many Pieces.
     */
    data: PieceCreateManyInput | PieceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Piece update
   */
  export type PieceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * The data needed to update a Piece.
     */
    data: XOR<PieceUpdateInput, PieceUncheckedUpdateInput>
    /**
     * Choose, which Piece to update.
     */
    where: PieceWhereUniqueInput
  }

  /**
   * Piece updateMany
   */
  export type PieceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pieces.
     */
    data: XOR<PieceUpdateManyMutationInput, PieceUncheckedUpdateManyInput>
    /**
     * Filter which Pieces to update
     */
    where?: PieceWhereInput
    /**
     * Limit how many Pieces to update.
     */
    limit?: number
  }

  /**
   * Piece updateManyAndReturn
   */
  export type PieceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * The data used to update Pieces.
     */
    data: XOR<PieceUpdateManyMutationInput, PieceUncheckedUpdateManyInput>
    /**
     * Filter which Pieces to update
     */
    where?: PieceWhereInput
    /**
     * Limit how many Pieces to update.
     */
    limit?: number
  }

  /**
   * Piece upsert
   */
  export type PieceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * The filter to search for the Piece to update in case it exists.
     */
    where: PieceWhereUniqueInput
    /**
     * In case the Piece found by the `where` argument doesn't exist, create a new Piece with this data.
     */
    create: XOR<PieceCreateInput, PieceUncheckedCreateInput>
    /**
     * In case the Piece was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PieceUpdateInput, PieceUncheckedUpdateInput>
  }

  /**
   * Piece delete
   */
  export type PieceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
    /**
     * Filter which Piece to delete.
     */
    where: PieceWhereUniqueInput
  }

  /**
   * Piece deleteMany
   */
  export type PieceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pieces to delete
     */
    where?: PieceWhereInput
    /**
     * Limit how many Pieces to delete.
     */
    limit?: number
  }

  /**
   * Piece.kits
   */
  export type Piece$kitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    where?: KitPieceWhereInput
    orderBy?: KitPieceOrderByWithRelationInput | KitPieceOrderByWithRelationInput[]
    cursor?: KitPieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitPieceScalarFieldEnum | KitPieceScalarFieldEnum[]
  }

  /**
   * Piece.sousAssemblages
   */
  export type Piece$sousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    where?: SousAssemblagePieceWhereInput
    orderBy?: SousAssemblagePieceOrderByWithRelationInput | SousAssemblagePieceOrderByWithRelationInput[]
    cursor?: SousAssemblagePieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousAssemblagePieceScalarFieldEnum | SousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * Piece.sousSousAssemblages
   */
  export type Piece$sousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    where?: SousSousAssemblagePieceWhereInput
    orderBy?: SousSousAssemblagePieceOrderByWithRelationInput | SousSousAssemblagePieceOrderByWithRelationInput[]
    cursor?: SousSousAssemblagePieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousSousAssemblagePieceScalarFieldEnum | SousSousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * Piece.taskTemplatePieces
   */
  export type Piece$taskTemplatePiecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    where?: TaskTemplatePieceWhereInput
    orderBy?: TaskTemplatePieceOrderByWithRelationInput | TaskTemplatePieceOrderByWithRelationInput[]
    cursor?: TaskTemplatePieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplatePieceScalarFieldEnum | TaskTemplatePieceScalarFieldEnum[]
  }

  /**
   * Piece.bornes
   */
  export type Piece$bornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    where?: BorneWhereInput
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    cursor?: BorneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * Piece without action
   */
  export type PieceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piece
     */
    select?: PieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Piece
     */
    omit?: PieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceInclude<ExtArgs> | null
  }


  /**
   * Model SousAssemblage
   */

  export type AggregateSousAssemblage = {
    _count: SousAssemblageCountAggregateOutputType | null
    _avg: SousAssemblageAvgAggregateOutputType | null
    _sum: SousAssemblageSumAggregateOutputType | null
    _min: SousAssemblageMinAggregateOutputType | null
    _max: SousAssemblageMaxAggregateOutputType | null
  }

  export type SousAssemblageAvgAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type SousAssemblageSumAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type SousAssemblageMinAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    nombre: number | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type SousAssemblageMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    nombre: number | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type SousAssemblageCountAggregateOutputType = {
    id: number
    nom: number
    reference: number
    photo: number
    emplacement: number
    createdAt: number
    updatedAt: number
    archived: number
    nombre: number
    seuilAlerte: number
    etat: number
    numero: number
    type: number
    version: number
    _all: number
  }


  export type SousAssemblageAvgAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type SousAssemblageSumAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type SousAssemblageMinAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type SousAssemblageMaxAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type SousAssemblageCountAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
    _all?: true
  }

  export type SousAssemblageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousAssemblage to aggregate.
     */
    where?: SousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblages to fetch.
     */
    orderBy?: SousAssemblageOrderByWithRelationInput | SousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SousAssemblages
    **/
    _count?: true | SousAssemblageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SousAssemblageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SousAssemblageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SousAssemblageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SousAssemblageMaxAggregateInputType
  }

  export type GetSousAssemblageAggregateType<T extends SousAssemblageAggregateArgs> = {
        [P in keyof T & keyof AggregateSousAssemblage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSousAssemblage[P]>
      : GetScalarType<T[P], AggregateSousAssemblage[P]>
  }




  export type SousAssemblageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblageWhereInput
    orderBy?: SousAssemblageOrderByWithAggregationInput | SousAssemblageOrderByWithAggregationInput[]
    by: SousAssemblageScalarFieldEnum[] | SousAssemblageScalarFieldEnum
    having?: SousAssemblageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SousAssemblageCountAggregateInputType | true
    _avg?: SousAssemblageAvgAggregateInputType
    _sum?: SousAssemblageSumAggregateInputType
    _min?: SousAssemblageMinAggregateInputType
    _max?: SousAssemblageMaxAggregateInputType
  }

  export type SousAssemblageGroupByOutputType = {
    id: number
    nom: string
    reference: string
    photo: string | null
    emplacement: string
    createdAt: Date
    updatedAt: Date
    archived: boolean
    nombre: number
    seuilAlerte: number
    etat: $Enums.PieceEtat
    numero: string | null
    type: $Enums.PieceType
    version: string
    _count: SousAssemblageCountAggregateOutputType | null
    _avg: SousAssemblageAvgAggregateOutputType | null
    _sum: SousAssemblageSumAggregateOutputType | null
    _min: SousAssemblageMinAggregateOutputType | null
    _max: SousAssemblageMaxAggregateOutputType | null
  }

  type GetSousAssemblageGroupByPayload<T extends SousAssemblageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SousAssemblageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SousAssemblageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SousAssemblageGroupByOutputType[P]>
            : GetScalarType<T[P], SousAssemblageGroupByOutputType[P]>
        }
      >
    >


  export type SousAssemblageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
    pieces?: boolean | SousAssemblage$piecesArgs<ExtArgs>
    sousSousAssemblages?: boolean | SousAssemblage$sousSousAssemblagesArgs<ExtArgs>
    taskTemplateSousAssemblages?: boolean | SousAssemblage$taskTemplateSousAssemblagesArgs<ExtArgs>
    bornes?: boolean | SousAssemblage$bornesArgs<ExtArgs>
    _count?: boolean | SousAssemblageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblage"]>

  export type SousAssemblageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["sousAssemblage"]>

  export type SousAssemblageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["sousAssemblage"]>

  export type SousAssemblageSelectScalar = {
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }

  export type SousAssemblageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "reference" | "photo" | "emplacement" | "createdAt" | "updatedAt" | "archived" | "nombre" | "seuilAlerte" | "etat" | "numero" | "type" | "version", ExtArgs["result"]["sousAssemblage"]>
  export type SousAssemblageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pieces?: boolean | SousAssemblage$piecesArgs<ExtArgs>
    sousSousAssemblages?: boolean | SousAssemblage$sousSousAssemblagesArgs<ExtArgs>
    taskTemplateSousAssemblages?: boolean | SousAssemblage$taskTemplateSousAssemblagesArgs<ExtArgs>
    bornes?: boolean | SousAssemblage$bornesArgs<ExtArgs>
    _count?: boolean | SousAssemblageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SousAssemblageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SousAssemblageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SousAssemblagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SousAssemblage"
    objects: {
      pieces: Prisma.$SousAssemblagePiecePayload<ExtArgs>[]
      sousSousAssemblages: Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>[]
      taskTemplateSousAssemblages: Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>[]
      bornes: Prisma.$BornePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      reference: string
      photo: string | null
      emplacement: string
      createdAt: Date
      updatedAt: Date
      archived: boolean
      nombre: number
      seuilAlerte: number
      etat: $Enums.PieceEtat
      numero: string | null
      type: $Enums.PieceType
      version: string
    }, ExtArgs["result"]["sousAssemblage"]>
    composites: {}
  }

  type SousAssemblageGetPayload<S extends boolean | null | undefined | SousAssemblageDefaultArgs> = $Result.GetResult<Prisma.$SousAssemblagePayload, S>

  type SousAssemblageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SousAssemblageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SousAssemblageCountAggregateInputType | true
    }

  export interface SousAssemblageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SousAssemblage'], meta: { name: 'SousAssemblage' } }
    /**
     * Find zero or one SousAssemblage that matches the filter.
     * @param {SousAssemblageFindUniqueArgs} args - Arguments to find a SousAssemblage
     * @example
     * // Get one SousAssemblage
     * const sousAssemblage = await prisma.sousAssemblage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SousAssemblageFindUniqueArgs>(args: SelectSubset<T, SousAssemblageFindUniqueArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SousAssemblage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SousAssemblageFindUniqueOrThrowArgs} args - Arguments to find a SousAssemblage
     * @example
     * // Get one SousAssemblage
     * const sousAssemblage = await prisma.sousAssemblage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SousAssemblageFindUniqueOrThrowArgs>(args: SelectSubset<T, SousAssemblageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousAssemblage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageFindFirstArgs} args - Arguments to find a SousAssemblage
     * @example
     * // Get one SousAssemblage
     * const sousAssemblage = await prisma.sousAssemblage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SousAssemblageFindFirstArgs>(args?: SelectSubset<T, SousAssemblageFindFirstArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousAssemblage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageFindFirstOrThrowArgs} args - Arguments to find a SousAssemblage
     * @example
     * // Get one SousAssemblage
     * const sousAssemblage = await prisma.sousAssemblage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SousAssemblageFindFirstOrThrowArgs>(args?: SelectSubset<T, SousAssemblageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SousAssemblages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SousAssemblages
     * const sousAssemblages = await prisma.sousAssemblage.findMany()
     * 
     * // Get first 10 SousAssemblages
     * const sousAssemblages = await prisma.sousAssemblage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sousAssemblageWithIdOnly = await prisma.sousAssemblage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SousAssemblageFindManyArgs>(args?: SelectSubset<T, SousAssemblageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SousAssemblage.
     * @param {SousAssemblageCreateArgs} args - Arguments to create a SousAssemblage.
     * @example
     * // Create one SousAssemblage
     * const SousAssemblage = await prisma.sousAssemblage.create({
     *   data: {
     *     // ... data to create a SousAssemblage
     *   }
     * })
     * 
     */
    create<T extends SousAssemblageCreateArgs>(args: SelectSubset<T, SousAssemblageCreateArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SousAssemblages.
     * @param {SousAssemblageCreateManyArgs} args - Arguments to create many SousAssemblages.
     * @example
     * // Create many SousAssemblages
     * const sousAssemblage = await prisma.sousAssemblage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SousAssemblageCreateManyArgs>(args?: SelectSubset<T, SousAssemblageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SousAssemblages and returns the data saved in the database.
     * @param {SousAssemblageCreateManyAndReturnArgs} args - Arguments to create many SousAssemblages.
     * @example
     * // Create many SousAssemblages
     * const sousAssemblage = await prisma.sousAssemblage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SousAssemblages and only return the `id`
     * const sousAssemblageWithIdOnly = await prisma.sousAssemblage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SousAssemblageCreateManyAndReturnArgs>(args?: SelectSubset<T, SousAssemblageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SousAssemblage.
     * @param {SousAssemblageDeleteArgs} args - Arguments to delete one SousAssemblage.
     * @example
     * // Delete one SousAssemblage
     * const SousAssemblage = await prisma.sousAssemblage.delete({
     *   where: {
     *     // ... filter to delete one SousAssemblage
     *   }
     * })
     * 
     */
    delete<T extends SousAssemblageDeleteArgs>(args: SelectSubset<T, SousAssemblageDeleteArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SousAssemblage.
     * @param {SousAssemblageUpdateArgs} args - Arguments to update one SousAssemblage.
     * @example
     * // Update one SousAssemblage
     * const sousAssemblage = await prisma.sousAssemblage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SousAssemblageUpdateArgs>(args: SelectSubset<T, SousAssemblageUpdateArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SousAssemblages.
     * @param {SousAssemblageDeleteManyArgs} args - Arguments to filter SousAssemblages to delete.
     * @example
     * // Delete a few SousAssemblages
     * const { count } = await prisma.sousAssemblage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SousAssemblageDeleteManyArgs>(args?: SelectSubset<T, SousAssemblageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SousAssemblages
     * const sousAssemblage = await prisma.sousAssemblage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SousAssemblageUpdateManyArgs>(args: SelectSubset<T, SousAssemblageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousAssemblages and returns the data updated in the database.
     * @param {SousAssemblageUpdateManyAndReturnArgs} args - Arguments to update many SousAssemblages.
     * @example
     * // Update many SousAssemblages
     * const sousAssemblage = await prisma.sousAssemblage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SousAssemblages and only return the `id`
     * const sousAssemblageWithIdOnly = await prisma.sousAssemblage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SousAssemblageUpdateManyAndReturnArgs>(args: SelectSubset<T, SousAssemblageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SousAssemblage.
     * @param {SousAssemblageUpsertArgs} args - Arguments to update or create a SousAssemblage.
     * @example
     * // Update or create a SousAssemblage
     * const sousAssemblage = await prisma.sousAssemblage.upsert({
     *   create: {
     *     // ... data to create a SousAssemblage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SousAssemblage we want to update
     *   }
     * })
     */
    upsert<T extends SousAssemblageUpsertArgs>(args: SelectSubset<T, SousAssemblageUpsertArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageCountArgs} args - Arguments to filter SousAssemblages to count.
     * @example
     * // Count the number of SousAssemblages
     * const count = await prisma.sousAssemblage.count({
     *   where: {
     *     // ... the filter for the SousAssemblages we want to count
     *   }
     * })
    **/
    count<T extends SousAssemblageCountArgs>(
      args?: Subset<T, SousAssemblageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SousAssemblageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SousAssemblageAggregateArgs>(args: Subset<T, SousAssemblageAggregateArgs>): Prisma.PrismaPromise<GetSousAssemblageAggregateType<T>>

    /**
     * Group by SousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SousAssemblageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SousAssemblageGroupByArgs['orderBy'] }
        : { orderBy?: SousAssemblageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SousAssemblageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSousAssemblageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SousAssemblage model
   */
  readonly fields: SousAssemblageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SousAssemblage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SousAssemblageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pieces<T extends SousAssemblage$piecesArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblage$piecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousSousAssemblages<T extends SousAssemblage$sousSousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblage$sousSousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskTemplateSousAssemblages<T extends SousAssemblage$taskTemplateSousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblage$taskTemplateSousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bornes<T extends SousAssemblage$bornesArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblage$bornesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SousAssemblage model
   */
  interface SousAssemblageFieldRefs {
    readonly id: FieldRef<"SousAssemblage", 'Int'>
    readonly nom: FieldRef<"SousAssemblage", 'String'>
    readonly reference: FieldRef<"SousAssemblage", 'String'>
    readonly photo: FieldRef<"SousAssemblage", 'String'>
    readonly emplacement: FieldRef<"SousAssemblage", 'String'>
    readonly createdAt: FieldRef<"SousAssemblage", 'DateTime'>
    readonly updatedAt: FieldRef<"SousAssemblage", 'DateTime'>
    readonly archived: FieldRef<"SousAssemblage", 'Boolean'>
    readonly nombre: FieldRef<"SousAssemblage", 'Int'>
    readonly seuilAlerte: FieldRef<"SousAssemblage", 'Int'>
    readonly etat: FieldRef<"SousAssemblage", 'PieceEtat'>
    readonly numero: FieldRef<"SousAssemblage", 'String'>
    readonly type: FieldRef<"SousAssemblage", 'PieceType'>
    readonly version: FieldRef<"SousAssemblage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SousAssemblage findUnique
   */
  export type SousAssemblageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblage to fetch.
     */
    where: SousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblage findUniqueOrThrow
   */
  export type SousAssemblageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblage to fetch.
     */
    where: SousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblage findFirst
   */
  export type SousAssemblageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblage to fetch.
     */
    where?: SousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblages to fetch.
     */
    orderBy?: SousAssemblageOrderByWithRelationInput | SousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousAssemblages.
     */
    cursor?: SousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousAssemblages.
     */
    distinct?: SousAssemblageScalarFieldEnum | SousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblage findFirstOrThrow
   */
  export type SousAssemblageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblage to fetch.
     */
    where?: SousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblages to fetch.
     */
    orderBy?: SousAssemblageOrderByWithRelationInput | SousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousAssemblages.
     */
    cursor?: SousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousAssemblages.
     */
    distinct?: SousAssemblageScalarFieldEnum | SousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblage findMany
   */
  export type SousAssemblageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblages to fetch.
     */
    where?: SousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblages to fetch.
     */
    orderBy?: SousAssemblageOrderByWithRelationInput | SousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SousAssemblages.
     */
    cursor?: SousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblages.
     */
    skip?: number
    distinct?: SousAssemblageScalarFieldEnum | SousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblage create
   */
  export type SousAssemblageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to create a SousAssemblage.
     */
    data: XOR<SousAssemblageCreateInput, SousAssemblageUncheckedCreateInput>
  }

  /**
   * SousAssemblage createMany
   */
  export type SousAssemblageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SousAssemblages.
     */
    data: SousAssemblageCreateManyInput | SousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousAssemblage createManyAndReturn
   */
  export type SousAssemblageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to create many SousAssemblages.
     */
    data: SousAssemblageCreateManyInput | SousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousAssemblage update
   */
  export type SousAssemblageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to update a SousAssemblage.
     */
    data: XOR<SousAssemblageUpdateInput, SousAssemblageUncheckedUpdateInput>
    /**
     * Choose, which SousAssemblage to update.
     */
    where: SousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblage updateMany
   */
  export type SousAssemblageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SousAssemblages.
     */
    data: XOR<SousAssemblageUpdateManyMutationInput, SousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which SousAssemblages to update
     */
    where?: SousAssemblageWhereInput
    /**
     * Limit how many SousAssemblages to update.
     */
    limit?: number
  }

  /**
   * SousAssemblage updateManyAndReturn
   */
  export type SousAssemblageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to update SousAssemblages.
     */
    data: XOR<SousAssemblageUpdateManyMutationInput, SousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which SousAssemblages to update
     */
    where?: SousAssemblageWhereInput
    /**
     * Limit how many SousAssemblages to update.
     */
    limit?: number
  }

  /**
   * SousAssemblage upsert
   */
  export type SousAssemblageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * The filter to search for the SousAssemblage to update in case it exists.
     */
    where: SousAssemblageWhereUniqueInput
    /**
     * In case the SousAssemblage found by the `where` argument doesn't exist, create a new SousAssemblage with this data.
     */
    create: XOR<SousAssemblageCreateInput, SousAssemblageUncheckedCreateInput>
    /**
     * In case the SousAssemblage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SousAssemblageUpdateInput, SousAssemblageUncheckedUpdateInput>
  }

  /**
   * SousAssemblage delete
   */
  export type SousAssemblageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
    /**
     * Filter which SousAssemblage to delete.
     */
    where: SousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblage deleteMany
   */
  export type SousAssemblageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousAssemblages to delete
     */
    where?: SousAssemblageWhereInput
    /**
     * Limit how many SousAssemblages to delete.
     */
    limit?: number
  }

  /**
   * SousAssemblage.pieces
   */
  export type SousAssemblage$piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    where?: SousAssemblagePieceWhereInput
    orderBy?: SousAssemblagePieceOrderByWithRelationInput | SousAssemblagePieceOrderByWithRelationInput[]
    cursor?: SousAssemblagePieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousAssemblagePieceScalarFieldEnum | SousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousAssemblage.sousSousAssemblages
   */
  export type SousAssemblage$sousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    where?: SousAssemblageSousSousAssemblageWhereInput
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithRelationInput | SousAssemblageSousSousAssemblageOrderByWithRelationInput[]
    cursor?: SousAssemblageSousSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousAssemblageSousSousAssemblageScalarFieldEnum | SousAssemblageSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblage.taskTemplateSousAssemblages
   */
  export type SousAssemblage$taskTemplateSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    where?: TaskTemplateSousAssemblageWhereInput
    orderBy?: TaskTemplateSousAssemblageOrderByWithRelationInput | TaskTemplateSousAssemblageOrderByWithRelationInput[]
    cursor?: TaskTemplateSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateSousAssemblageScalarFieldEnum | TaskTemplateSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblage.bornes
   */
  export type SousAssemblage$bornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    where?: BorneWhereInput
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    cursor?: BorneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * SousAssemblage without action
   */
  export type SousAssemblageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblage
     */
    select?: SousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblage
     */
    omit?: SousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageInclude<ExtArgs> | null
  }


  /**
   * Model SousSousAssemblage
   */

  export type AggregateSousSousAssemblage = {
    _count: SousSousAssemblageCountAggregateOutputType | null
    _avg: SousSousAssemblageAvgAggregateOutputType | null
    _sum: SousSousAssemblageSumAggregateOutputType | null
    _min: SousSousAssemblageMinAggregateOutputType | null
    _max: SousSousAssemblageMaxAggregateOutputType | null
  }

  export type SousSousAssemblageAvgAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type SousSousAssemblageSumAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type SousSousAssemblageMinAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    nombre: number | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type SousSousAssemblageMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    nombre: number | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type SousSousAssemblageCountAggregateOutputType = {
    id: number
    nom: number
    reference: number
    photo: number
    emplacement: number
    createdAt: number
    updatedAt: number
    archived: number
    nombre: number
    seuilAlerte: number
    etat: number
    numero: number
    type: number
    version: number
    _all: number
  }


  export type SousSousAssemblageAvgAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type SousSousAssemblageSumAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type SousSousAssemblageMinAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type SousSousAssemblageMaxAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type SousSousAssemblageCountAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
    _all?: true
  }

  export type SousSousAssemblageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousSousAssemblage to aggregate.
     */
    where?: SousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblages to fetch.
     */
    orderBy?: SousSousAssemblageOrderByWithRelationInput | SousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SousSousAssemblages
    **/
    _count?: true | SousSousAssemblageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SousSousAssemblageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SousSousAssemblageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SousSousAssemblageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SousSousAssemblageMaxAggregateInputType
  }

  export type GetSousSousAssemblageAggregateType<T extends SousSousAssemblageAggregateArgs> = {
        [P in keyof T & keyof AggregateSousSousAssemblage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSousSousAssemblage[P]>
      : GetScalarType<T[P], AggregateSousSousAssemblage[P]>
  }




  export type SousSousAssemblageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousSousAssemblageWhereInput
    orderBy?: SousSousAssemblageOrderByWithAggregationInput | SousSousAssemblageOrderByWithAggregationInput[]
    by: SousSousAssemblageScalarFieldEnum[] | SousSousAssemblageScalarFieldEnum
    having?: SousSousAssemblageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SousSousAssemblageCountAggregateInputType | true
    _avg?: SousSousAssemblageAvgAggregateInputType
    _sum?: SousSousAssemblageSumAggregateInputType
    _min?: SousSousAssemblageMinAggregateInputType
    _max?: SousSousAssemblageMaxAggregateInputType
  }

  export type SousSousAssemblageGroupByOutputType = {
    id: number
    nom: string
    reference: string
    photo: string | null
    emplacement: string
    createdAt: Date
    updatedAt: Date
    archived: boolean
    nombre: number
    seuilAlerte: number
    etat: $Enums.PieceEtat
    numero: string | null
    type: $Enums.PieceType
    version: string
    _count: SousSousAssemblageCountAggregateOutputType | null
    _avg: SousSousAssemblageAvgAggregateOutputType | null
    _sum: SousSousAssemblageSumAggregateOutputType | null
    _min: SousSousAssemblageMinAggregateOutputType | null
    _max: SousSousAssemblageMaxAggregateOutputType | null
  }

  type GetSousSousAssemblageGroupByPayload<T extends SousSousAssemblageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SousSousAssemblageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SousSousAssemblageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SousSousAssemblageGroupByOutputType[P]>
            : GetScalarType<T[P], SousSousAssemblageGroupByOutputType[P]>
        }
      >
    >


  export type SousSousAssemblageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
    sousAssemblages?: boolean | SousSousAssemblage$sousAssemblagesArgs<ExtArgs>
    pieces?: boolean | SousSousAssemblage$piecesArgs<ExtArgs>
    taskTemplateSousSousAssemblages?: boolean | SousSousAssemblage$taskTemplateSousSousAssemblagesArgs<ExtArgs>
    bornes?: boolean | SousSousAssemblage$bornesArgs<ExtArgs>
    _count?: boolean | SousSousAssemblageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousSousAssemblage"]>

  export type SousSousAssemblageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["sousSousAssemblage"]>

  export type SousSousAssemblageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["sousSousAssemblage"]>

  export type SousSousAssemblageSelectScalar = {
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }

  export type SousSousAssemblageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "reference" | "photo" | "emplacement" | "createdAt" | "updatedAt" | "archived" | "nombre" | "seuilAlerte" | "etat" | "numero" | "type" | "version", ExtArgs["result"]["sousSousAssemblage"]>
  export type SousSousAssemblageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblages?: boolean | SousSousAssemblage$sousAssemblagesArgs<ExtArgs>
    pieces?: boolean | SousSousAssemblage$piecesArgs<ExtArgs>
    taskTemplateSousSousAssemblages?: boolean | SousSousAssemblage$taskTemplateSousSousAssemblagesArgs<ExtArgs>
    bornes?: boolean | SousSousAssemblage$bornesArgs<ExtArgs>
    _count?: boolean | SousSousAssemblageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SousSousAssemblageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SousSousAssemblageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SousSousAssemblagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SousSousAssemblage"
    objects: {
      sousAssemblages: Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>[]
      pieces: Prisma.$SousSousAssemblagePiecePayload<ExtArgs>[]
      taskTemplateSousSousAssemblages: Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>[]
      bornes: Prisma.$BornePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      reference: string
      photo: string | null
      emplacement: string
      createdAt: Date
      updatedAt: Date
      archived: boolean
      nombre: number
      seuilAlerte: number
      etat: $Enums.PieceEtat
      numero: string | null
      type: $Enums.PieceType
      version: string
    }, ExtArgs["result"]["sousSousAssemblage"]>
    composites: {}
  }

  type SousSousAssemblageGetPayload<S extends boolean | null | undefined | SousSousAssemblageDefaultArgs> = $Result.GetResult<Prisma.$SousSousAssemblagePayload, S>

  type SousSousAssemblageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SousSousAssemblageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SousSousAssemblageCountAggregateInputType | true
    }

  export interface SousSousAssemblageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SousSousAssemblage'], meta: { name: 'SousSousAssemblage' } }
    /**
     * Find zero or one SousSousAssemblage that matches the filter.
     * @param {SousSousAssemblageFindUniqueArgs} args - Arguments to find a SousSousAssemblage
     * @example
     * // Get one SousSousAssemblage
     * const sousSousAssemblage = await prisma.sousSousAssemblage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SousSousAssemblageFindUniqueArgs>(args: SelectSubset<T, SousSousAssemblageFindUniqueArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SousSousAssemblage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SousSousAssemblageFindUniqueOrThrowArgs} args - Arguments to find a SousSousAssemblage
     * @example
     * // Get one SousSousAssemblage
     * const sousSousAssemblage = await prisma.sousSousAssemblage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SousSousAssemblageFindUniqueOrThrowArgs>(args: SelectSubset<T, SousSousAssemblageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousSousAssemblage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageFindFirstArgs} args - Arguments to find a SousSousAssemblage
     * @example
     * // Get one SousSousAssemblage
     * const sousSousAssemblage = await prisma.sousSousAssemblage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SousSousAssemblageFindFirstArgs>(args?: SelectSubset<T, SousSousAssemblageFindFirstArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousSousAssemblage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageFindFirstOrThrowArgs} args - Arguments to find a SousSousAssemblage
     * @example
     * // Get one SousSousAssemblage
     * const sousSousAssemblage = await prisma.sousSousAssemblage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SousSousAssemblageFindFirstOrThrowArgs>(args?: SelectSubset<T, SousSousAssemblageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SousSousAssemblages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SousSousAssemblages
     * const sousSousAssemblages = await prisma.sousSousAssemblage.findMany()
     * 
     * // Get first 10 SousSousAssemblages
     * const sousSousAssemblages = await prisma.sousSousAssemblage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sousSousAssemblageWithIdOnly = await prisma.sousSousAssemblage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SousSousAssemblageFindManyArgs>(args?: SelectSubset<T, SousSousAssemblageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SousSousAssemblage.
     * @param {SousSousAssemblageCreateArgs} args - Arguments to create a SousSousAssemblage.
     * @example
     * // Create one SousSousAssemblage
     * const SousSousAssemblage = await prisma.sousSousAssemblage.create({
     *   data: {
     *     // ... data to create a SousSousAssemblage
     *   }
     * })
     * 
     */
    create<T extends SousSousAssemblageCreateArgs>(args: SelectSubset<T, SousSousAssemblageCreateArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SousSousAssemblages.
     * @param {SousSousAssemblageCreateManyArgs} args - Arguments to create many SousSousAssemblages.
     * @example
     * // Create many SousSousAssemblages
     * const sousSousAssemblage = await prisma.sousSousAssemblage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SousSousAssemblageCreateManyArgs>(args?: SelectSubset<T, SousSousAssemblageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SousSousAssemblages and returns the data saved in the database.
     * @param {SousSousAssemblageCreateManyAndReturnArgs} args - Arguments to create many SousSousAssemblages.
     * @example
     * // Create many SousSousAssemblages
     * const sousSousAssemblage = await prisma.sousSousAssemblage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SousSousAssemblages and only return the `id`
     * const sousSousAssemblageWithIdOnly = await prisma.sousSousAssemblage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SousSousAssemblageCreateManyAndReturnArgs>(args?: SelectSubset<T, SousSousAssemblageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SousSousAssemblage.
     * @param {SousSousAssemblageDeleteArgs} args - Arguments to delete one SousSousAssemblage.
     * @example
     * // Delete one SousSousAssemblage
     * const SousSousAssemblage = await prisma.sousSousAssemblage.delete({
     *   where: {
     *     // ... filter to delete one SousSousAssemblage
     *   }
     * })
     * 
     */
    delete<T extends SousSousAssemblageDeleteArgs>(args: SelectSubset<T, SousSousAssemblageDeleteArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SousSousAssemblage.
     * @param {SousSousAssemblageUpdateArgs} args - Arguments to update one SousSousAssemblage.
     * @example
     * // Update one SousSousAssemblage
     * const sousSousAssemblage = await prisma.sousSousAssemblage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SousSousAssemblageUpdateArgs>(args: SelectSubset<T, SousSousAssemblageUpdateArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SousSousAssemblages.
     * @param {SousSousAssemblageDeleteManyArgs} args - Arguments to filter SousSousAssemblages to delete.
     * @example
     * // Delete a few SousSousAssemblages
     * const { count } = await prisma.sousSousAssemblage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SousSousAssemblageDeleteManyArgs>(args?: SelectSubset<T, SousSousAssemblageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SousSousAssemblages
     * const sousSousAssemblage = await prisma.sousSousAssemblage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SousSousAssemblageUpdateManyArgs>(args: SelectSubset<T, SousSousAssemblageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousSousAssemblages and returns the data updated in the database.
     * @param {SousSousAssemblageUpdateManyAndReturnArgs} args - Arguments to update many SousSousAssemblages.
     * @example
     * // Update many SousSousAssemblages
     * const sousSousAssemblage = await prisma.sousSousAssemblage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SousSousAssemblages and only return the `id`
     * const sousSousAssemblageWithIdOnly = await prisma.sousSousAssemblage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SousSousAssemblageUpdateManyAndReturnArgs>(args: SelectSubset<T, SousSousAssemblageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SousSousAssemblage.
     * @param {SousSousAssemblageUpsertArgs} args - Arguments to update or create a SousSousAssemblage.
     * @example
     * // Update or create a SousSousAssemblage
     * const sousSousAssemblage = await prisma.sousSousAssemblage.upsert({
     *   create: {
     *     // ... data to create a SousSousAssemblage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SousSousAssemblage we want to update
     *   }
     * })
     */
    upsert<T extends SousSousAssemblageUpsertArgs>(args: SelectSubset<T, SousSousAssemblageUpsertArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SousSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageCountArgs} args - Arguments to filter SousSousAssemblages to count.
     * @example
     * // Count the number of SousSousAssemblages
     * const count = await prisma.sousSousAssemblage.count({
     *   where: {
     *     // ... the filter for the SousSousAssemblages we want to count
     *   }
     * })
    **/
    count<T extends SousSousAssemblageCountArgs>(
      args?: Subset<T, SousSousAssemblageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SousSousAssemblageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SousSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SousSousAssemblageAggregateArgs>(args: Subset<T, SousSousAssemblageAggregateArgs>): Prisma.PrismaPromise<GetSousSousAssemblageAggregateType<T>>

    /**
     * Group by SousSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SousSousAssemblageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SousSousAssemblageGroupByArgs['orderBy'] }
        : { orderBy?: SousSousAssemblageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SousSousAssemblageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSousSousAssemblageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SousSousAssemblage model
   */
  readonly fields: SousSousAssemblageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SousSousAssemblage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SousSousAssemblageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sousAssemblages<T extends SousSousAssemblage$sousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblage$sousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pieces<T extends SousSousAssemblage$piecesArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblage$piecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskTemplateSousSousAssemblages<T extends SousSousAssemblage$taskTemplateSousSousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblage$taskTemplateSousSousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bornes<T extends SousSousAssemblage$bornesArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblage$bornesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SousSousAssemblage model
   */
  interface SousSousAssemblageFieldRefs {
    readonly id: FieldRef<"SousSousAssemblage", 'Int'>
    readonly nom: FieldRef<"SousSousAssemblage", 'String'>
    readonly reference: FieldRef<"SousSousAssemblage", 'String'>
    readonly photo: FieldRef<"SousSousAssemblage", 'String'>
    readonly emplacement: FieldRef<"SousSousAssemblage", 'String'>
    readonly createdAt: FieldRef<"SousSousAssemblage", 'DateTime'>
    readonly updatedAt: FieldRef<"SousSousAssemblage", 'DateTime'>
    readonly archived: FieldRef<"SousSousAssemblage", 'Boolean'>
    readonly nombre: FieldRef<"SousSousAssemblage", 'Int'>
    readonly seuilAlerte: FieldRef<"SousSousAssemblage", 'Int'>
    readonly etat: FieldRef<"SousSousAssemblage", 'PieceEtat'>
    readonly numero: FieldRef<"SousSousAssemblage", 'String'>
    readonly type: FieldRef<"SousSousAssemblage", 'PieceType'>
    readonly version: FieldRef<"SousSousAssemblage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SousSousAssemblage findUnique
   */
  export type SousSousAssemblageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblage to fetch.
     */
    where: SousSousAssemblageWhereUniqueInput
  }

  /**
   * SousSousAssemblage findUniqueOrThrow
   */
  export type SousSousAssemblageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblage to fetch.
     */
    where: SousSousAssemblageWhereUniqueInput
  }

  /**
   * SousSousAssemblage findFirst
   */
  export type SousSousAssemblageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblage to fetch.
     */
    where?: SousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblages to fetch.
     */
    orderBy?: SousSousAssemblageOrderByWithRelationInput | SousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousSousAssemblages.
     */
    cursor?: SousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousSousAssemblages.
     */
    distinct?: SousSousAssemblageScalarFieldEnum | SousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage findFirstOrThrow
   */
  export type SousSousAssemblageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblage to fetch.
     */
    where?: SousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblages to fetch.
     */
    orderBy?: SousSousAssemblageOrderByWithRelationInput | SousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousSousAssemblages.
     */
    cursor?: SousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousSousAssemblages.
     */
    distinct?: SousSousAssemblageScalarFieldEnum | SousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage findMany
   */
  export type SousSousAssemblageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblages to fetch.
     */
    where?: SousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblages to fetch.
     */
    orderBy?: SousSousAssemblageOrderByWithRelationInput | SousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SousSousAssemblages.
     */
    cursor?: SousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblages.
     */
    skip?: number
    distinct?: SousSousAssemblageScalarFieldEnum | SousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage create
   */
  export type SousSousAssemblageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to create a SousSousAssemblage.
     */
    data: XOR<SousSousAssemblageCreateInput, SousSousAssemblageUncheckedCreateInput>
  }

  /**
   * SousSousAssemblage createMany
   */
  export type SousSousAssemblageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SousSousAssemblages.
     */
    data: SousSousAssemblageCreateManyInput | SousSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousSousAssemblage createManyAndReturn
   */
  export type SousSousAssemblageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to create many SousSousAssemblages.
     */
    data: SousSousAssemblageCreateManyInput | SousSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousSousAssemblage update
   */
  export type SousSousAssemblageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to update a SousSousAssemblage.
     */
    data: XOR<SousSousAssemblageUpdateInput, SousSousAssemblageUncheckedUpdateInput>
    /**
     * Choose, which SousSousAssemblage to update.
     */
    where: SousSousAssemblageWhereUniqueInput
  }

  /**
   * SousSousAssemblage updateMany
   */
  export type SousSousAssemblageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SousSousAssemblages.
     */
    data: XOR<SousSousAssemblageUpdateManyMutationInput, SousSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which SousSousAssemblages to update
     */
    where?: SousSousAssemblageWhereInput
    /**
     * Limit how many SousSousAssemblages to update.
     */
    limit?: number
  }

  /**
   * SousSousAssemblage updateManyAndReturn
   */
  export type SousSousAssemblageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to update SousSousAssemblages.
     */
    data: XOR<SousSousAssemblageUpdateManyMutationInput, SousSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which SousSousAssemblages to update
     */
    where?: SousSousAssemblageWhereInput
    /**
     * Limit how many SousSousAssemblages to update.
     */
    limit?: number
  }

  /**
   * SousSousAssemblage upsert
   */
  export type SousSousAssemblageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * The filter to search for the SousSousAssemblage to update in case it exists.
     */
    where: SousSousAssemblageWhereUniqueInput
    /**
     * In case the SousSousAssemblage found by the `where` argument doesn't exist, create a new SousSousAssemblage with this data.
     */
    create: XOR<SousSousAssemblageCreateInput, SousSousAssemblageUncheckedCreateInput>
    /**
     * In case the SousSousAssemblage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SousSousAssemblageUpdateInput, SousSousAssemblageUncheckedUpdateInput>
  }

  /**
   * SousSousAssemblage delete
   */
  export type SousSousAssemblageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter which SousSousAssemblage to delete.
     */
    where: SousSousAssemblageWhereUniqueInput
  }

  /**
   * SousSousAssemblage deleteMany
   */
  export type SousSousAssemblageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousSousAssemblages to delete
     */
    where?: SousSousAssemblageWhereInput
    /**
     * Limit how many SousSousAssemblages to delete.
     */
    limit?: number
  }

  /**
   * SousSousAssemblage.sousAssemblages
   */
  export type SousSousAssemblage$sousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    where?: SousAssemblageSousSousAssemblageWhereInput
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithRelationInput | SousAssemblageSousSousAssemblageOrderByWithRelationInput[]
    cursor?: SousAssemblageSousSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousAssemblageSousSousAssemblageScalarFieldEnum | SousAssemblageSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage.pieces
   */
  export type SousSousAssemblage$piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    where?: SousSousAssemblagePieceWhereInput
    orderBy?: SousSousAssemblagePieceOrderByWithRelationInput | SousSousAssemblagePieceOrderByWithRelationInput[]
    cursor?: SousSousAssemblagePieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SousSousAssemblagePieceScalarFieldEnum | SousSousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage.taskTemplateSousSousAssemblages
   */
  export type SousSousAssemblage$taskTemplateSousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    where?: TaskTemplateSousSousAssemblageWhereInput
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithRelationInput | TaskTemplateSousSousAssemblageOrderByWithRelationInput[]
    cursor?: TaskTemplateSousSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateSousSousAssemblageScalarFieldEnum | TaskTemplateSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage.bornes
   */
  export type SousSousAssemblage$bornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    where?: BorneWhereInput
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    cursor?: BorneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * SousSousAssemblage without action
   */
  export type SousSousAssemblageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblage
     */
    select?: SousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblage
     */
    omit?: SousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblageInclude<ExtArgs> | null
  }


  /**
   * Model Kit
   */

  export type AggregateKit = {
    _count: KitCountAggregateOutputType | null
    _avg: KitAvgAggregateOutputType | null
    _sum: KitSumAggregateOutputType | null
    _min: KitMinAggregateOutputType | null
    _max: KitMaxAggregateOutputType | null
  }

  export type KitAvgAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type KitSumAggregateOutputType = {
    id: number | null
    nombre: number | null
    seuilAlerte: number | null
  }

  export type KitMinAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    nombre: number | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type KitMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    photo: string | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    nombre: number | null
    seuilAlerte: number | null
    etat: $Enums.PieceEtat | null
    numero: string | null
    type: $Enums.PieceType | null
    version: string | null
  }

  export type KitCountAggregateOutputType = {
    id: number
    nom: number
    reference: number
    photo: number
    emplacement: number
    createdAt: number
    updatedAt: number
    archived: number
    nombre: number
    seuilAlerte: number
    etat: number
    numero: number
    type: number
    version: number
    _all: number
  }


  export type KitAvgAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type KitSumAggregateInputType = {
    id?: true
    nombre?: true
    seuilAlerte?: true
  }

  export type KitMinAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type KitMaxAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
  }

  export type KitCountAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    photo?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    nombre?: true
    seuilAlerte?: true
    etat?: true
    numero?: true
    type?: true
    version?: true
    _all?: true
  }

  export type KitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kit to aggregate.
     */
    where?: KitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kits to fetch.
     */
    orderBy?: KitOrderByWithRelationInput | KitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kits
    **/
    _count?: true | KitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitMaxAggregateInputType
  }

  export type GetKitAggregateType<T extends KitAggregateArgs> = {
        [P in keyof T & keyof AggregateKit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKit[P]>
      : GetScalarType<T[P], AggregateKit[P]>
  }




  export type KitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitWhereInput
    orderBy?: KitOrderByWithAggregationInput | KitOrderByWithAggregationInput[]
    by: KitScalarFieldEnum[] | KitScalarFieldEnum
    having?: KitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitCountAggregateInputType | true
    _avg?: KitAvgAggregateInputType
    _sum?: KitSumAggregateInputType
    _min?: KitMinAggregateInputType
    _max?: KitMaxAggregateInputType
  }

  export type KitGroupByOutputType = {
    id: number
    nom: string
    reference: string
    photo: string | null
    emplacement: string
    createdAt: Date
    updatedAt: Date
    archived: boolean
    nombre: number
    seuilAlerte: number
    etat: $Enums.PieceEtat
    numero: string | null
    type: $Enums.PieceType
    version: string
    _count: KitCountAggregateOutputType | null
    _avg: KitAvgAggregateOutputType | null
    _sum: KitSumAggregateOutputType | null
    _min: KitMinAggregateOutputType | null
    _max: KitMaxAggregateOutputType | null
  }

  type GetKitGroupByPayload<T extends KitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitGroupByOutputType[P]>
            : GetScalarType<T[P], KitGroupByOutputType[P]>
        }
      >
    >


  export type KitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
    pieces?: boolean | Kit$piecesArgs<ExtArgs>
    bornes?: boolean | Kit$bornesArgs<ExtArgs>
    _count?: boolean | KitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kit"]>

  export type KitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["kit"]>

  export type KitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["kit"]>

  export type KitSelectScalar = {
    id?: boolean
    nom?: boolean
    reference?: boolean
    photo?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    nombre?: boolean
    seuilAlerte?: boolean
    etat?: boolean
    numero?: boolean
    type?: boolean
    version?: boolean
  }

  export type KitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "reference" | "photo" | "emplacement" | "createdAt" | "updatedAt" | "archived" | "nombre" | "seuilAlerte" | "etat" | "numero" | "type" | "version", ExtArgs["result"]["kit"]>
  export type KitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pieces?: boolean | Kit$piecesArgs<ExtArgs>
    bornes?: boolean | Kit$bornesArgs<ExtArgs>
    _count?: boolean | KitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kit"
    objects: {
      pieces: Prisma.$KitPiecePayload<ExtArgs>[]
      bornes: Prisma.$BornePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      reference: string
      photo: string | null
      emplacement: string
      createdAt: Date
      updatedAt: Date
      archived: boolean
      nombre: number
      seuilAlerte: number
      etat: $Enums.PieceEtat
      numero: string | null
      type: $Enums.PieceType
      version: string
    }, ExtArgs["result"]["kit"]>
    composites: {}
  }

  type KitGetPayload<S extends boolean | null | undefined | KitDefaultArgs> = $Result.GetResult<Prisma.$KitPayload, S>

  type KitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KitCountAggregateInputType | true
    }

  export interface KitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kit'], meta: { name: 'Kit' } }
    /**
     * Find zero or one Kit that matches the filter.
     * @param {KitFindUniqueArgs} args - Arguments to find a Kit
     * @example
     * // Get one Kit
     * const kit = await prisma.kit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitFindUniqueArgs>(args: SelectSubset<T, KitFindUniqueArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KitFindUniqueOrThrowArgs} args - Arguments to find a Kit
     * @example
     * // Get one Kit
     * const kit = await prisma.kit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitFindUniqueOrThrowArgs>(args: SelectSubset<T, KitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitFindFirstArgs} args - Arguments to find a Kit
     * @example
     * // Get one Kit
     * const kit = await prisma.kit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitFindFirstArgs>(args?: SelectSubset<T, KitFindFirstArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitFindFirstOrThrowArgs} args - Arguments to find a Kit
     * @example
     * // Get one Kit
     * const kit = await prisma.kit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitFindFirstOrThrowArgs>(args?: SelectSubset<T, KitFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kits
     * const kits = await prisma.kit.findMany()
     * 
     * // Get first 10 Kits
     * const kits = await prisma.kit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitWithIdOnly = await prisma.kit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KitFindManyArgs>(args?: SelectSubset<T, KitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kit.
     * @param {KitCreateArgs} args - Arguments to create a Kit.
     * @example
     * // Create one Kit
     * const Kit = await prisma.kit.create({
     *   data: {
     *     // ... data to create a Kit
     *   }
     * })
     * 
     */
    create<T extends KitCreateArgs>(args: SelectSubset<T, KitCreateArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kits.
     * @param {KitCreateManyArgs} args - Arguments to create many Kits.
     * @example
     * // Create many Kits
     * const kit = await prisma.kit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitCreateManyArgs>(args?: SelectSubset<T, KitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kits and returns the data saved in the database.
     * @param {KitCreateManyAndReturnArgs} args - Arguments to create many Kits.
     * @example
     * // Create many Kits
     * const kit = await prisma.kit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kits and only return the `id`
     * const kitWithIdOnly = await prisma.kit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitCreateManyAndReturnArgs>(args?: SelectSubset<T, KitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kit.
     * @param {KitDeleteArgs} args - Arguments to delete one Kit.
     * @example
     * // Delete one Kit
     * const Kit = await prisma.kit.delete({
     *   where: {
     *     // ... filter to delete one Kit
     *   }
     * })
     * 
     */
    delete<T extends KitDeleteArgs>(args: SelectSubset<T, KitDeleteArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kit.
     * @param {KitUpdateArgs} args - Arguments to update one Kit.
     * @example
     * // Update one Kit
     * const kit = await prisma.kit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitUpdateArgs>(args: SelectSubset<T, KitUpdateArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kits.
     * @param {KitDeleteManyArgs} args - Arguments to filter Kits to delete.
     * @example
     * // Delete a few Kits
     * const { count } = await prisma.kit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitDeleteManyArgs>(args?: SelectSubset<T, KitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kits
     * const kit = await prisma.kit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitUpdateManyArgs>(args: SelectSubset<T, KitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kits and returns the data updated in the database.
     * @param {KitUpdateManyAndReturnArgs} args - Arguments to update many Kits.
     * @example
     * // Update many Kits
     * const kit = await prisma.kit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kits and only return the `id`
     * const kitWithIdOnly = await prisma.kit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KitUpdateManyAndReturnArgs>(args: SelectSubset<T, KitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kit.
     * @param {KitUpsertArgs} args - Arguments to update or create a Kit.
     * @example
     * // Update or create a Kit
     * const kit = await prisma.kit.upsert({
     *   create: {
     *     // ... data to create a Kit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kit we want to update
     *   }
     * })
     */
    upsert<T extends KitUpsertArgs>(args: SelectSubset<T, KitUpsertArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitCountArgs} args - Arguments to filter Kits to count.
     * @example
     * // Count the number of Kits
     * const count = await prisma.kit.count({
     *   where: {
     *     // ... the filter for the Kits we want to count
     *   }
     * })
    **/
    count<T extends KitCountArgs>(
      args?: Subset<T, KitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitAggregateArgs>(args: Subset<T, KitAggregateArgs>): Prisma.PrismaPromise<GetKitAggregateType<T>>

    /**
     * Group by Kit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitGroupByArgs['orderBy'] }
        : { orderBy?: KitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kit model
   */
  readonly fields: KitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pieces<T extends Kit$piecesArgs<ExtArgs> = {}>(args?: Subset<T, Kit$piecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bornes<T extends Kit$bornesArgs<ExtArgs> = {}>(args?: Subset<T, Kit$bornesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kit model
   */
  interface KitFieldRefs {
    readonly id: FieldRef<"Kit", 'Int'>
    readonly nom: FieldRef<"Kit", 'String'>
    readonly reference: FieldRef<"Kit", 'String'>
    readonly photo: FieldRef<"Kit", 'String'>
    readonly emplacement: FieldRef<"Kit", 'String'>
    readonly createdAt: FieldRef<"Kit", 'DateTime'>
    readonly updatedAt: FieldRef<"Kit", 'DateTime'>
    readonly archived: FieldRef<"Kit", 'Boolean'>
    readonly nombre: FieldRef<"Kit", 'Int'>
    readonly seuilAlerte: FieldRef<"Kit", 'Int'>
    readonly etat: FieldRef<"Kit", 'PieceEtat'>
    readonly numero: FieldRef<"Kit", 'String'>
    readonly type: FieldRef<"Kit", 'PieceType'>
    readonly version: FieldRef<"Kit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Kit findUnique
   */
  export type KitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * Filter, which Kit to fetch.
     */
    where: KitWhereUniqueInput
  }

  /**
   * Kit findUniqueOrThrow
   */
  export type KitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * Filter, which Kit to fetch.
     */
    where: KitWhereUniqueInput
  }

  /**
   * Kit findFirst
   */
  export type KitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * Filter, which Kit to fetch.
     */
    where?: KitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kits to fetch.
     */
    orderBy?: KitOrderByWithRelationInput | KitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kits.
     */
    cursor?: KitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kits.
     */
    distinct?: KitScalarFieldEnum | KitScalarFieldEnum[]
  }

  /**
   * Kit findFirstOrThrow
   */
  export type KitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * Filter, which Kit to fetch.
     */
    where?: KitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kits to fetch.
     */
    orderBy?: KitOrderByWithRelationInput | KitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kits.
     */
    cursor?: KitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kits.
     */
    distinct?: KitScalarFieldEnum | KitScalarFieldEnum[]
  }

  /**
   * Kit findMany
   */
  export type KitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * Filter, which Kits to fetch.
     */
    where?: KitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kits to fetch.
     */
    orderBy?: KitOrderByWithRelationInput | KitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kits.
     */
    cursor?: KitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kits.
     */
    skip?: number
    distinct?: KitScalarFieldEnum | KitScalarFieldEnum[]
  }

  /**
   * Kit create
   */
  export type KitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * The data needed to create a Kit.
     */
    data: XOR<KitCreateInput, KitUncheckedCreateInput>
  }

  /**
   * Kit createMany
   */
  export type KitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kits.
     */
    data: KitCreateManyInput | KitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kit createManyAndReturn
   */
  export type KitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * The data used to create many Kits.
     */
    data: KitCreateManyInput | KitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kit update
   */
  export type KitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * The data needed to update a Kit.
     */
    data: XOR<KitUpdateInput, KitUncheckedUpdateInput>
    /**
     * Choose, which Kit to update.
     */
    where: KitWhereUniqueInput
  }

  /**
   * Kit updateMany
   */
  export type KitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kits.
     */
    data: XOR<KitUpdateManyMutationInput, KitUncheckedUpdateManyInput>
    /**
     * Filter which Kits to update
     */
    where?: KitWhereInput
    /**
     * Limit how many Kits to update.
     */
    limit?: number
  }

  /**
   * Kit updateManyAndReturn
   */
  export type KitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * The data used to update Kits.
     */
    data: XOR<KitUpdateManyMutationInput, KitUncheckedUpdateManyInput>
    /**
     * Filter which Kits to update
     */
    where?: KitWhereInput
    /**
     * Limit how many Kits to update.
     */
    limit?: number
  }

  /**
   * Kit upsert
   */
  export type KitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * The filter to search for the Kit to update in case it exists.
     */
    where: KitWhereUniqueInput
    /**
     * In case the Kit found by the `where` argument doesn't exist, create a new Kit with this data.
     */
    create: XOR<KitCreateInput, KitUncheckedCreateInput>
    /**
     * In case the Kit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitUpdateInput, KitUncheckedUpdateInput>
  }

  /**
   * Kit delete
   */
  export type KitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
    /**
     * Filter which Kit to delete.
     */
    where: KitWhereUniqueInput
  }

  /**
   * Kit deleteMany
   */
  export type KitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kits to delete
     */
    where?: KitWhereInput
    /**
     * Limit how many Kits to delete.
     */
    limit?: number
  }

  /**
   * Kit.pieces
   */
  export type Kit$piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    where?: KitPieceWhereInput
    orderBy?: KitPieceOrderByWithRelationInput | KitPieceOrderByWithRelationInput[]
    cursor?: KitPieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitPieceScalarFieldEnum | KitPieceScalarFieldEnum[]
  }

  /**
   * Kit.bornes
   */
  export type Kit$bornesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    where?: BorneWhereInput
    orderBy?: BorneOrderByWithRelationInput | BorneOrderByWithRelationInput[]
    cursor?: BorneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorneScalarFieldEnum | BorneScalarFieldEnum[]
  }

  /**
   * Kit without action
   */
  export type KitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kit
     */
    select?: KitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kit
     */
    omit?: KitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitInclude<ExtArgs> | null
  }


  /**
   * Model SousAssemblagePiece
   */

  export type AggregateSousAssemblagePiece = {
    _count: SousAssemblagePieceCountAggregateOutputType | null
    _avg: SousAssemblagePieceAvgAggregateOutputType | null
    _sum: SousAssemblagePieceSumAggregateOutputType | null
    _min: SousAssemblagePieceMinAggregateOutputType | null
    _max: SousAssemblagePieceMaxAggregateOutputType | null
  }

  export type SousAssemblagePieceAvgAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousAssemblagePieceSumAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousAssemblagePieceMinAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousAssemblagePieceMaxAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousAssemblagePieceCountAggregateOutputType = {
    id: number
    sousAssemblageId: number
    pieceId: number
    nombre: number
    _all: number
  }


  export type SousAssemblagePieceAvgAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousAssemblagePieceSumAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousAssemblagePieceMinAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousAssemblagePieceMaxAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousAssemblagePieceCountAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    pieceId?: true
    nombre?: true
    _all?: true
  }

  export type SousAssemblagePieceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousAssemblagePiece to aggregate.
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblagePieces to fetch.
     */
    orderBy?: SousAssemblagePieceOrderByWithRelationInput | SousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblagePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SousAssemblagePieces
    **/
    _count?: true | SousAssemblagePieceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SousAssemblagePieceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SousAssemblagePieceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SousAssemblagePieceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SousAssemblagePieceMaxAggregateInputType
  }

  export type GetSousAssemblagePieceAggregateType<T extends SousAssemblagePieceAggregateArgs> = {
        [P in keyof T & keyof AggregateSousAssemblagePiece]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSousAssemblagePiece[P]>
      : GetScalarType<T[P], AggregateSousAssemblagePiece[P]>
  }




  export type SousAssemblagePieceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblagePieceWhereInput
    orderBy?: SousAssemblagePieceOrderByWithAggregationInput | SousAssemblagePieceOrderByWithAggregationInput[]
    by: SousAssemblagePieceScalarFieldEnum[] | SousAssemblagePieceScalarFieldEnum
    having?: SousAssemblagePieceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SousAssemblagePieceCountAggregateInputType | true
    _avg?: SousAssemblagePieceAvgAggregateInputType
    _sum?: SousAssemblagePieceSumAggregateInputType
    _min?: SousAssemblagePieceMinAggregateInputType
    _max?: SousAssemblagePieceMaxAggregateInputType
  }

  export type SousAssemblagePieceGroupByOutputType = {
    id: number
    sousAssemblageId: number
    pieceId: number
    nombre: number
    _count: SousAssemblagePieceCountAggregateOutputType | null
    _avg: SousAssemblagePieceAvgAggregateOutputType | null
    _sum: SousAssemblagePieceSumAggregateOutputType | null
    _min: SousAssemblagePieceMinAggregateOutputType | null
    _max: SousAssemblagePieceMaxAggregateOutputType | null
  }

  type GetSousAssemblagePieceGroupByPayload<T extends SousAssemblagePieceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SousAssemblagePieceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SousAssemblagePieceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SousAssemblagePieceGroupByOutputType[P]>
            : GetScalarType<T[P], SousAssemblagePieceGroupByOutputType[P]>
        }
      >
    >


  export type SousAssemblagePieceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblagePiece"]>

  export type SousAssemblagePieceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblagePiece"]>

  export type SousAssemblagePieceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblagePiece"]>

  export type SousAssemblagePieceSelectScalar = {
    id?: boolean
    sousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
  }

  export type SousAssemblagePieceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sousAssemblageId" | "pieceId" | "nombre", ExtArgs["result"]["sousAssemblagePiece"]>
  export type SousAssemblagePieceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
  }
  export type SousAssemblagePieceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
  }
  export type SousAssemblagePieceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
  }

  export type $SousAssemblagePiecePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SousAssemblagePiece"
    objects: {
      piece: Prisma.$PiecePayload<ExtArgs>
      sousAssemblage: Prisma.$SousAssemblagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sousAssemblageId: number
      pieceId: number
      nombre: number
    }, ExtArgs["result"]["sousAssemblagePiece"]>
    composites: {}
  }

  type SousAssemblagePieceGetPayload<S extends boolean | null | undefined | SousAssemblagePieceDefaultArgs> = $Result.GetResult<Prisma.$SousAssemblagePiecePayload, S>

  type SousAssemblagePieceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SousAssemblagePieceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SousAssemblagePieceCountAggregateInputType | true
    }

  export interface SousAssemblagePieceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SousAssemblagePiece'], meta: { name: 'SousAssemblagePiece' } }
    /**
     * Find zero or one SousAssemblagePiece that matches the filter.
     * @param {SousAssemblagePieceFindUniqueArgs} args - Arguments to find a SousAssemblagePiece
     * @example
     * // Get one SousAssemblagePiece
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SousAssemblagePieceFindUniqueArgs>(args: SelectSubset<T, SousAssemblagePieceFindUniqueArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SousAssemblagePiece that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SousAssemblagePieceFindUniqueOrThrowArgs} args - Arguments to find a SousAssemblagePiece
     * @example
     * // Get one SousAssemblagePiece
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SousAssemblagePieceFindUniqueOrThrowArgs>(args: SelectSubset<T, SousAssemblagePieceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousAssemblagePiece that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceFindFirstArgs} args - Arguments to find a SousAssemblagePiece
     * @example
     * // Get one SousAssemblagePiece
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SousAssemblagePieceFindFirstArgs>(args?: SelectSubset<T, SousAssemblagePieceFindFirstArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousAssemblagePiece that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceFindFirstOrThrowArgs} args - Arguments to find a SousAssemblagePiece
     * @example
     * // Get one SousAssemblagePiece
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SousAssemblagePieceFindFirstOrThrowArgs>(args?: SelectSubset<T, SousAssemblagePieceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SousAssemblagePieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SousAssemblagePieces
     * const sousAssemblagePieces = await prisma.sousAssemblagePiece.findMany()
     * 
     * // Get first 10 SousAssemblagePieces
     * const sousAssemblagePieces = await prisma.sousAssemblagePiece.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sousAssemblagePieceWithIdOnly = await prisma.sousAssemblagePiece.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SousAssemblagePieceFindManyArgs>(args?: SelectSubset<T, SousAssemblagePieceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SousAssemblagePiece.
     * @param {SousAssemblagePieceCreateArgs} args - Arguments to create a SousAssemblagePiece.
     * @example
     * // Create one SousAssemblagePiece
     * const SousAssemblagePiece = await prisma.sousAssemblagePiece.create({
     *   data: {
     *     // ... data to create a SousAssemblagePiece
     *   }
     * })
     * 
     */
    create<T extends SousAssemblagePieceCreateArgs>(args: SelectSubset<T, SousAssemblagePieceCreateArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SousAssemblagePieces.
     * @param {SousAssemblagePieceCreateManyArgs} args - Arguments to create many SousAssemblagePieces.
     * @example
     * // Create many SousAssemblagePieces
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SousAssemblagePieceCreateManyArgs>(args?: SelectSubset<T, SousAssemblagePieceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SousAssemblagePieces and returns the data saved in the database.
     * @param {SousAssemblagePieceCreateManyAndReturnArgs} args - Arguments to create many SousAssemblagePieces.
     * @example
     * // Create many SousAssemblagePieces
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SousAssemblagePieces and only return the `id`
     * const sousAssemblagePieceWithIdOnly = await prisma.sousAssemblagePiece.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SousAssemblagePieceCreateManyAndReturnArgs>(args?: SelectSubset<T, SousAssemblagePieceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SousAssemblagePiece.
     * @param {SousAssemblagePieceDeleteArgs} args - Arguments to delete one SousAssemblagePiece.
     * @example
     * // Delete one SousAssemblagePiece
     * const SousAssemblagePiece = await prisma.sousAssemblagePiece.delete({
     *   where: {
     *     // ... filter to delete one SousAssemblagePiece
     *   }
     * })
     * 
     */
    delete<T extends SousAssemblagePieceDeleteArgs>(args: SelectSubset<T, SousAssemblagePieceDeleteArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SousAssemblagePiece.
     * @param {SousAssemblagePieceUpdateArgs} args - Arguments to update one SousAssemblagePiece.
     * @example
     * // Update one SousAssemblagePiece
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SousAssemblagePieceUpdateArgs>(args: SelectSubset<T, SousAssemblagePieceUpdateArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SousAssemblagePieces.
     * @param {SousAssemblagePieceDeleteManyArgs} args - Arguments to filter SousAssemblagePieces to delete.
     * @example
     * // Delete a few SousAssemblagePieces
     * const { count } = await prisma.sousAssemblagePiece.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SousAssemblagePieceDeleteManyArgs>(args?: SelectSubset<T, SousAssemblagePieceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousAssemblagePieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SousAssemblagePieces
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SousAssemblagePieceUpdateManyArgs>(args: SelectSubset<T, SousAssemblagePieceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousAssemblagePieces and returns the data updated in the database.
     * @param {SousAssemblagePieceUpdateManyAndReturnArgs} args - Arguments to update many SousAssemblagePieces.
     * @example
     * // Update many SousAssemblagePieces
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SousAssemblagePieces and only return the `id`
     * const sousAssemblagePieceWithIdOnly = await prisma.sousAssemblagePiece.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SousAssemblagePieceUpdateManyAndReturnArgs>(args: SelectSubset<T, SousAssemblagePieceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SousAssemblagePiece.
     * @param {SousAssemblagePieceUpsertArgs} args - Arguments to update or create a SousAssemblagePiece.
     * @example
     * // Update or create a SousAssemblagePiece
     * const sousAssemblagePiece = await prisma.sousAssemblagePiece.upsert({
     *   create: {
     *     // ... data to create a SousAssemblagePiece
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SousAssemblagePiece we want to update
     *   }
     * })
     */
    upsert<T extends SousAssemblagePieceUpsertArgs>(args: SelectSubset<T, SousAssemblagePieceUpsertArgs<ExtArgs>>): Prisma__SousAssemblagePieceClient<$Result.GetResult<Prisma.$SousAssemblagePiecePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SousAssemblagePieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceCountArgs} args - Arguments to filter SousAssemblagePieces to count.
     * @example
     * // Count the number of SousAssemblagePieces
     * const count = await prisma.sousAssemblagePiece.count({
     *   where: {
     *     // ... the filter for the SousAssemblagePieces we want to count
     *   }
     * })
    **/
    count<T extends SousAssemblagePieceCountArgs>(
      args?: Subset<T, SousAssemblagePieceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SousAssemblagePieceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SousAssemblagePiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SousAssemblagePieceAggregateArgs>(args: Subset<T, SousAssemblagePieceAggregateArgs>): Prisma.PrismaPromise<GetSousAssemblagePieceAggregateType<T>>

    /**
     * Group by SousAssemblagePiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblagePieceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SousAssemblagePieceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SousAssemblagePieceGroupByArgs['orderBy'] }
        : { orderBy?: SousAssemblagePieceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SousAssemblagePieceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSousAssemblagePieceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SousAssemblagePiece model
   */
  readonly fields: SousAssemblagePieceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SousAssemblagePiece.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SousAssemblagePieceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    piece<T extends PieceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PieceDefaultArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sousAssemblage<T extends SousAssemblageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblageDefaultArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SousAssemblagePiece model
   */
  interface SousAssemblagePieceFieldRefs {
    readonly id: FieldRef<"SousAssemblagePiece", 'Int'>
    readonly sousAssemblageId: FieldRef<"SousAssemblagePiece", 'Int'>
    readonly pieceId: FieldRef<"SousAssemblagePiece", 'Int'>
    readonly nombre: FieldRef<"SousAssemblagePiece", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SousAssemblagePiece findUnique
   */
  export type SousAssemblagePieceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblagePiece to fetch.
     */
    where: SousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousAssemblagePiece findUniqueOrThrow
   */
  export type SousAssemblagePieceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblagePiece to fetch.
     */
    where: SousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousAssemblagePiece findFirst
   */
  export type SousAssemblagePieceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblagePiece to fetch.
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblagePieces to fetch.
     */
    orderBy?: SousAssemblagePieceOrderByWithRelationInput | SousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousAssemblagePieces.
     */
    cursor?: SousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblagePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousAssemblagePieces.
     */
    distinct?: SousAssemblagePieceScalarFieldEnum | SousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousAssemblagePiece findFirstOrThrow
   */
  export type SousAssemblagePieceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblagePiece to fetch.
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblagePieces to fetch.
     */
    orderBy?: SousAssemblagePieceOrderByWithRelationInput | SousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousAssemblagePieces.
     */
    cursor?: SousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblagePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousAssemblagePieces.
     */
    distinct?: SousAssemblagePieceScalarFieldEnum | SousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousAssemblagePiece findMany
   */
  export type SousAssemblagePieceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblagePieces to fetch.
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblagePieces to fetch.
     */
    orderBy?: SousAssemblagePieceOrderByWithRelationInput | SousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SousAssemblagePieces.
     */
    cursor?: SousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblagePieces.
     */
    skip?: number
    distinct?: SousAssemblagePieceScalarFieldEnum | SousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousAssemblagePiece create
   */
  export type SousAssemblagePieceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * The data needed to create a SousAssemblagePiece.
     */
    data: XOR<SousAssemblagePieceCreateInput, SousAssemblagePieceUncheckedCreateInput>
  }

  /**
   * SousAssemblagePiece createMany
   */
  export type SousAssemblagePieceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SousAssemblagePieces.
     */
    data: SousAssemblagePieceCreateManyInput | SousAssemblagePieceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousAssemblagePiece createManyAndReturn
   */
  export type SousAssemblagePieceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * The data used to create many SousAssemblagePieces.
     */
    data: SousAssemblagePieceCreateManyInput | SousAssemblagePieceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SousAssemblagePiece update
   */
  export type SousAssemblagePieceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * The data needed to update a SousAssemblagePiece.
     */
    data: XOR<SousAssemblagePieceUpdateInput, SousAssemblagePieceUncheckedUpdateInput>
    /**
     * Choose, which SousAssemblagePiece to update.
     */
    where: SousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousAssemblagePiece updateMany
   */
  export type SousAssemblagePieceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SousAssemblagePieces.
     */
    data: XOR<SousAssemblagePieceUpdateManyMutationInput, SousAssemblagePieceUncheckedUpdateManyInput>
    /**
     * Filter which SousAssemblagePieces to update
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * Limit how many SousAssemblagePieces to update.
     */
    limit?: number
  }

  /**
   * SousAssemblagePiece updateManyAndReturn
   */
  export type SousAssemblagePieceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * The data used to update SousAssemblagePieces.
     */
    data: XOR<SousAssemblagePieceUpdateManyMutationInput, SousAssemblagePieceUncheckedUpdateManyInput>
    /**
     * Filter which SousAssemblagePieces to update
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * Limit how many SousAssemblagePieces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SousAssemblagePiece upsert
   */
  export type SousAssemblagePieceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * The filter to search for the SousAssemblagePiece to update in case it exists.
     */
    where: SousAssemblagePieceWhereUniqueInput
    /**
     * In case the SousAssemblagePiece found by the `where` argument doesn't exist, create a new SousAssemblagePiece with this data.
     */
    create: XOR<SousAssemblagePieceCreateInput, SousAssemblagePieceUncheckedCreateInput>
    /**
     * In case the SousAssemblagePiece was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SousAssemblagePieceUpdateInput, SousAssemblagePieceUncheckedUpdateInput>
  }

  /**
   * SousAssemblagePiece delete
   */
  export type SousAssemblagePieceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter which SousAssemblagePiece to delete.
     */
    where: SousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousAssemblagePiece deleteMany
   */
  export type SousAssemblagePieceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousAssemblagePieces to delete
     */
    where?: SousAssemblagePieceWhereInput
    /**
     * Limit how many SousAssemblagePieces to delete.
     */
    limit?: number
  }

  /**
   * SousAssemblagePiece without action
   */
  export type SousAssemblagePieceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblagePiece
     */
    select?: SousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblagePiece
     */
    omit?: SousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblagePieceInclude<ExtArgs> | null
  }


  /**
   * Model SousSousAssemblagePiece
   */

  export type AggregateSousSousAssemblagePiece = {
    _count: SousSousAssemblagePieceCountAggregateOutputType | null
    _avg: SousSousAssemblagePieceAvgAggregateOutputType | null
    _sum: SousSousAssemblagePieceSumAggregateOutputType | null
    _min: SousSousAssemblagePieceMinAggregateOutputType | null
    _max: SousSousAssemblagePieceMaxAggregateOutputType | null
  }

  export type SousSousAssemblagePieceAvgAggregateOutputType = {
    id: number | null
    sousSousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousSousAssemblagePieceSumAggregateOutputType = {
    id: number | null
    sousSousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousSousAssemblagePieceMinAggregateOutputType = {
    id: number | null
    sousSousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousSousAssemblagePieceMaxAggregateOutputType = {
    id: number | null
    sousSousAssemblageId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type SousSousAssemblagePieceCountAggregateOutputType = {
    id: number
    sousSousAssemblageId: number
    pieceId: number
    nombre: number
    _all: number
  }


  export type SousSousAssemblagePieceAvgAggregateInputType = {
    id?: true
    sousSousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousSousAssemblagePieceSumAggregateInputType = {
    id?: true
    sousSousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousSousAssemblagePieceMinAggregateInputType = {
    id?: true
    sousSousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousSousAssemblagePieceMaxAggregateInputType = {
    id?: true
    sousSousAssemblageId?: true
    pieceId?: true
    nombre?: true
  }

  export type SousSousAssemblagePieceCountAggregateInputType = {
    id?: true
    sousSousAssemblageId?: true
    pieceId?: true
    nombre?: true
    _all?: true
  }

  export type SousSousAssemblagePieceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousSousAssemblagePiece to aggregate.
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblagePieces to fetch.
     */
    orderBy?: SousSousAssemblagePieceOrderByWithRelationInput | SousSousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SousSousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblagePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SousSousAssemblagePieces
    **/
    _count?: true | SousSousAssemblagePieceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SousSousAssemblagePieceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SousSousAssemblagePieceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SousSousAssemblagePieceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SousSousAssemblagePieceMaxAggregateInputType
  }

  export type GetSousSousAssemblagePieceAggregateType<T extends SousSousAssemblagePieceAggregateArgs> = {
        [P in keyof T & keyof AggregateSousSousAssemblagePiece]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSousSousAssemblagePiece[P]>
      : GetScalarType<T[P], AggregateSousSousAssemblagePiece[P]>
  }




  export type SousSousAssemblagePieceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousSousAssemblagePieceWhereInput
    orderBy?: SousSousAssemblagePieceOrderByWithAggregationInput | SousSousAssemblagePieceOrderByWithAggregationInput[]
    by: SousSousAssemblagePieceScalarFieldEnum[] | SousSousAssemblagePieceScalarFieldEnum
    having?: SousSousAssemblagePieceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SousSousAssemblagePieceCountAggregateInputType | true
    _avg?: SousSousAssemblagePieceAvgAggregateInputType
    _sum?: SousSousAssemblagePieceSumAggregateInputType
    _min?: SousSousAssemblagePieceMinAggregateInputType
    _max?: SousSousAssemblagePieceMaxAggregateInputType
  }

  export type SousSousAssemblagePieceGroupByOutputType = {
    id: number
    sousSousAssemblageId: number
    pieceId: number
    nombre: number
    _count: SousSousAssemblagePieceCountAggregateOutputType | null
    _avg: SousSousAssemblagePieceAvgAggregateOutputType | null
    _sum: SousSousAssemblagePieceSumAggregateOutputType | null
    _min: SousSousAssemblagePieceMinAggregateOutputType | null
    _max: SousSousAssemblagePieceMaxAggregateOutputType | null
  }

  type GetSousSousAssemblagePieceGroupByPayload<T extends SousSousAssemblagePieceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SousSousAssemblagePieceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SousSousAssemblagePieceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SousSousAssemblagePieceGroupByOutputType[P]>
            : GetScalarType<T[P], SousSousAssemblagePieceGroupByOutputType[P]>
        }
      >
    >


  export type SousSousAssemblagePieceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousSousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousSousAssemblagePiece"]>

  export type SousSousAssemblagePieceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousSousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousSousAssemblagePiece"]>

  export type SousSousAssemblagePieceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousSousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousSousAssemblagePiece"]>

  export type SousSousAssemblagePieceSelectScalar = {
    id?: boolean
    sousSousAssemblageId?: boolean
    pieceId?: boolean
    nombre?: boolean
  }

  export type SousSousAssemblagePieceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sousSousAssemblageId" | "pieceId" | "nombre", ExtArgs["result"]["sousSousAssemblagePiece"]>
  export type SousSousAssemblagePieceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }
  export type SousSousAssemblagePieceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }
  export type SousSousAssemblagePieceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }

  export type $SousSousAssemblagePiecePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SousSousAssemblagePiece"
    objects: {
      piece: Prisma.$PiecePayload<ExtArgs>
      sousSousAssemblage: Prisma.$SousSousAssemblagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sousSousAssemblageId: number
      pieceId: number
      nombre: number
    }, ExtArgs["result"]["sousSousAssemblagePiece"]>
    composites: {}
  }

  type SousSousAssemblagePieceGetPayload<S extends boolean | null | undefined | SousSousAssemblagePieceDefaultArgs> = $Result.GetResult<Prisma.$SousSousAssemblagePiecePayload, S>

  type SousSousAssemblagePieceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SousSousAssemblagePieceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SousSousAssemblagePieceCountAggregateInputType | true
    }

  export interface SousSousAssemblagePieceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SousSousAssemblagePiece'], meta: { name: 'SousSousAssemblagePiece' } }
    /**
     * Find zero or one SousSousAssemblagePiece that matches the filter.
     * @param {SousSousAssemblagePieceFindUniqueArgs} args - Arguments to find a SousSousAssemblagePiece
     * @example
     * // Get one SousSousAssemblagePiece
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SousSousAssemblagePieceFindUniqueArgs>(args: SelectSubset<T, SousSousAssemblagePieceFindUniqueArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SousSousAssemblagePiece that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SousSousAssemblagePieceFindUniqueOrThrowArgs} args - Arguments to find a SousSousAssemblagePiece
     * @example
     * // Get one SousSousAssemblagePiece
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SousSousAssemblagePieceFindUniqueOrThrowArgs>(args: SelectSubset<T, SousSousAssemblagePieceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousSousAssemblagePiece that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceFindFirstArgs} args - Arguments to find a SousSousAssemblagePiece
     * @example
     * // Get one SousSousAssemblagePiece
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SousSousAssemblagePieceFindFirstArgs>(args?: SelectSubset<T, SousSousAssemblagePieceFindFirstArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousSousAssemblagePiece that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceFindFirstOrThrowArgs} args - Arguments to find a SousSousAssemblagePiece
     * @example
     * // Get one SousSousAssemblagePiece
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SousSousAssemblagePieceFindFirstOrThrowArgs>(args?: SelectSubset<T, SousSousAssemblagePieceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SousSousAssemblagePieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SousSousAssemblagePieces
     * const sousSousAssemblagePieces = await prisma.sousSousAssemblagePiece.findMany()
     * 
     * // Get first 10 SousSousAssemblagePieces
     * const sousSousAssemblagePieces = await prisma.sousSousAssemblagePiece.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sousSousAssemblagePieceWithIdOnly = await prisma.sousSousAssemblagePiece.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SousSousAssemblagePieceFindManyArgs>(args?: SelectSubset<T, SousSousAssemblagePieceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SousSousAssemblagePiece.
     * @param {SousSousAssemblagePieceCreateArgs} args - Arguments to create a SousSousAssemblagePiece.
     * @example
     * // Create one SousSousAssemblagePiece
     * const SousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.create({
     *   data: {
     *     // ... data to create a SousSousAssemblagePiece
     *   }
     * })
     * 
     */
    create<T extends SousSousAssemblagePieceCreateArgs>(args: SelectSubset<T, SousSousAssemblagePieceCreateArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SousSousAssemblagePieces.
     * @param {SousSousAssemblagePieceCreateManyArgs} args - Arguments to create many SousSousAssemblagePieces.
     * @example
     * // Create many SousSousAssemblagePieces
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SousSousAssemblagePieceCreateManyArgs>(args?: SelectSubset<T, SousSousAssemblagePieceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SousSousAssemblagePieces and returns the data saved in the database.
     * @param {SousSousAssemblagePieceCreateManyAndReturnArgs} args - Arguments to create many SousSousAssemblagePieces.
     * @example
     * // Create many SousSousAssemblagePieces
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SousSousAssemblagePieces and only return the `id`
     * const sousSousAssemblagePieceWithIdOnly = await prisma.sousSousAssemblagePiece.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SousSousAssemblagePieceCreateManyAndReturnArgs>(args?: SelectSubset<T, SousSousAssemblagePieceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SousSousAssemblagePiece.
     * @param {SousSousAssemblagePieceDeleteArgs} args - Arguments to delete one SousSousAssemblagePiece.
     * @example
     * // Delete one SousSousAssemblagePiece
     * const SousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.delete({
     *   where: {
     *     // ... filter to delete one SousSousAssemblagePiece
     *   }
     * })
     * 
     */
    delete<T extends SousSousAssemblagePieceDeleteArgs>(args: SelectSubset<T, SousSousAssemblagePieceDeleteArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SousSousAssemblagePiece.
     * @param {SousSousAssemblagePieceUpdateArgs} args - Arguments to update one SousSousAssemblagePiece.
     * @example
     * // Update one SousSousAssemblagePiece
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SousSousAssemblagePieceUpdateArgs>(args: SelectSubset<T, SousSousAssemblagePieceUpdateArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SousSousAssemblagePieces.
     * @param {SousSousAssemblagePieceDeleteManyArgs} args - Arguments to filter SousSousAssemblagePieces to delete.
     * @example
     * // Delete a few SousSousAssemblagePieces
     * const { count } = await prisma.sousSousAssemblagePiece.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SousSousAssemblagePieceDeleteManyArgs>(args?: SelectSubset<T, SousSousAssemblagePieceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousSousAssemblagePieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SousSousAssemblagePieces
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SousSousAssemblagePieceUpdateManyArgs>(args: SelectSubset<T, SousSousAssemblagePieceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousSousAssemblagePieces and returns the data updated in the database.
     * @param {SousSousAssemblagePieceUpdateManyAndReturnArgs} args - Arguments to update many SousSousAssemblagePieces.
     * @example
     * // Update many SousSousAssemblagePieces
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SousSousAssemblagePieces and only return the `id`
     * const sousSousAssemblagePieceWithIdOnly = await prisma.sousSousAssemblagePiece.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SousSousAssemblagePieceUpdateManyAndReturnArgs>(args: SelectSubset<T, SousSousAssemblagePieceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SousSousAssemblagePiece.
     * @param {SousSousAssemblagePieceUpsertArgs} args - Arguments to update or create a SousSousAssemblagePiece.
     * @example
     * // Update or create a SousSousAssemblagePiece
     * const sousSousAssemblagePiece = await prisma.sousSousAssemblagePiece.upsert({
     *   create: {
     *     // ... data to create a SousSousAssemblagePiece
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SousSousAssemblagePiece we want to update
     *   }
     * })
     */
    upsert<T extends SousSousAssemblagePieceUpsertArgs>(args: SelectSubset<T, SousSousAssemblagePieceUpsertArgs<ExtArgs>>): Prisma__SousSousAssemblagePieceClient<$Result.GetResult<Prisma.$SousSousAssemblagePiecePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SousSousAssemblagePieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceCountArgs} args - Arguments to filter SousSousAssemblagePieces to count.
     * @example
     * // Count the number of SousSousAssemblagePieces
     * const count = await prisma.sousSousAssemblagePiece.count({
     *   where: {
     *     // ... the filter for the SousSousAssemblagePieces we want to count
     *   }
     * })
    **/
    count<T extends SousSousAssemblagePieceCountArgs>(
      args?: Subset<T, SousSousAssemblagePieceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SousSousAssemblagePieceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SousSousAssemblagePiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SousSousAssemblagePieceAggregateArgs>(args: Subset<T, SousSousAssemblagePieceAggregateArgs>): Prisma.PrismaPromise<GetSousSousAssemblagePieceAggregateType<T>>

    /**
     * Group by SousSousAssemblagePiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousSousAssemblagePieceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SousSousAssemblagePieceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SousSousAssemblagePieceGroupByArgs['orderBy'] }
        : { orderBy?: SousSousAssemblagePieceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SousSousAssemblagePieceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSousSousAssemblagePieceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SousSousAssemblagePiece model
   */
  readonly fields: SousSousAssemblagePieceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SousSousAssemblagePiece.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SousSousAssemblagePieceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    piece<T extends PieceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PieceDefaultArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sousSousAssemblage<T extends SousSousAssemblageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblageDefaultArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SousSousAssemblagePiece model
   */
  interface SousSousAssemblagePieceFieldRefs {
    readonly id: FieldRef<"SousSousAssemblagePiece", 'Int'>
    readonly sousSousAssemblageId: FieldRef<"SousSousAssemblagePiece", 'Int'>
    readonly pieceId: FieldRef<"SousSousAssemblagePiece", 'Int'>
    readonly nombre: FieldRef<"SousSousAssemblagePiece", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SousSousAssemblagePiece findUnique
   */
  export type SousSousAssemblagePieceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblagePiece to fetch.
     */
    where: SousSousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousSousAssemblagePiece findUniqueOrThrow
   */
  export type SousSousAssemblagePieceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblagePiece to fetch.
     */
    where: SousSousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousSousAssemblagePiece findFirst
   */
  export type SousSousAssemblagePieceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblagePiece to fetch.
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblagePieces to fetch.
     */
    orderBy?: SousSousAssemblagePieceOrderByWithRelationInput | SousSousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousSousAssemblagePieces.
     */
    cursor?: SousSousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblagePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousSousAssemblagePieces.
     */
    distinct?: SousSousAssemblagePieceScalarFieldEnum | SousSousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousSousAssemblagePiece findFirstOrThrow
   */
  export type SousSousAssemblagePieceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblagePiece to fetch.
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblagePieces to fetch.
     */
    orderBy?: SousSousAssemblagePieceOrderByWithRelationInput | SousSousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousSousAssemblagePieces.
     */
    cursor?: SousSousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblagePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousSousAssemblagePieces.
     */
    distinct?: SousSousAssemblagePieceScalarFieldEnum | SousSousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousSousAssemblagePiece findMany
   */
  export type SousSousAssemblagePieceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter, which SousSousAssemblagePieces to fetch.
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousSousAssemblagePieces to fetch.
     */
    orderBy?: SousSousAssemblagePieceOrderByWithRelationInput | SousSousAssemblagePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SousSousAssemblagePieces.
     */
    cursor?: SousSousAssemblagePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousSousAssemblagePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousSousAssemblagePieces.
     */
    skip?: number
    distinct?: SousSousAssemblagePieceScalarFieldEnum | SousSousAssemblagePieceScalarFieldEnum[]
  }

  /**
   * SousSousAssemblagePiece create
   */
  export type SousSousAssemblagePieceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * The data needed to create a SousSousAssemblagePiece.
     */
    data: XOR<SousSousAssemblagePieceCreateInput, SousSousAssemblagePieceUncheckedCreateInput>
  }

  /**
   * SousSousAssemblagePiece createMany
   */
  export type SousSousAssemblagePieceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SousSousAssemblagePieces.
     */
    data: SousSousAssemblagePieceCreateManyInput | SousSousAssemblagePieceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousSousAssemblagePiece createManyAndReturn
   */
  export type SousSousAssemblagePieceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * The data used to create many SousSousAssemblagePieces.
     */
    data: SousSousAssemblagePieceCreateManyInput | SousSousAssemblagePieceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SousSousAssemblagePiece update
   */
  export type SousSousAssemblagePieceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * The data needed to update a SousSousAssemblagePiece.
     */
    data: XOR<SousSousAssemblagePieceUpdateInput, SousSousAssemblagePieceUncheckedUpdateInput>
    /**
     * Choose, which SousSousAssemblagePiece to update.
     */
    where: SousSousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousSousAssemblagePiece updateMany
   */
  export type SousSousAssemblagePieceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SousSousAssemblagePieces.
     */
    data: XOR<SousSousAssemblagePieceUpdateManyMutationInput, SousSousAssemblagePieceUncheckedUpdateManyInput>
    /**
     * Filter which SousSousAssemblagePieces to update
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * Limit how many SousSousAssemblagePieces to update.
     */
    limit?: number
  }

  /**
   * SousSousAssemblagePiece updateManyAndReturn
   */
  export type SousSousAssemblagePieceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * The data used to update SousSousAssemblagePieces.
     */
    data: XOR<SousSousAssemblagePieceUpdateManyMutationInput, SousSousAssemblagePieceUncheckedUpdateManyInput>
    /**
     * Filter which SousSousAssemblagePieces to update
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * Limit how many SousSousAssemblagePieces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SousSousAssemblagePiece upsert
   */
  export type SousSousAssemblagePieceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * The filter to search for the SousSousAssemblagePiece to update in case it exists.
     */
    where: SousSousAssemblagePieceWhereUniqueInput
    /**
     * In case the SousSousAssemblagePiece found by the `where` argument doesn't exist, create a new SousSousAssemblagePiece with this data.
     */
    create: XOR<SousSousAssemblagePieceCreateInput, SousSousAssemblagePieceUncheckedCreateInput>
    /**
     * In case the SousSousAssemblagePiece was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SousSousAssemblagePieceUpdateInput, SousSousAssemblagePieceUncheckedUpdateInput>
  }

  /**
   * SousSousAssemblagePiece delete
   */
  export type SousSousAssemblagePieceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
    /**
     * Filter which SousSousAssemblagePiece to delete.
     */
    where: SousSousAssemblagePieceWhereUniqueInput
  }

  /**
   * SousSousAssemblagePiece deleteMany
   */
  export type SousSousAssemblagePieceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousSousAssemblagePieces to delete
     */
    where?: SousSousAssemblagePieceWhereInput
    /**
     * Limit how many SousSousAssemblagePieces to delete.
     */
    limit?: number
  }

  /**
   * SousSousAssemblagePiece without action
   */
  export type SousSousAssemblagePieceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousSousAssemblagePiece
     */
    select?: SousSousAssemblagePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousSousAssemblagePiece
     */
    omit?: SousSousAssemblagePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousSousAssemblagePieceInclude<ExtArgs> | null
  }


  /**
   * Model SousAssemblageSousSousAssemblage
   */

  export type AggregateSousAssemblageSousSousAssemblage = {
    _count: SousAssemblageSousSousAssemblageCountAggregateOutputType | null
    _avg: SousAssemblageSousSousAssemblageAvgAggregateOutputType | null
    _sum: SousAssemblageSousSousAssemblageSumAggregateOutputType | null
    _min: SousAssemblageSousSousAssemblageMinAggregateOutputType | null
    _max: SousAssemblageSousSousAssemblageMaxAggregateOutputType | null
  }

  export type SousAssemblageSousSousAssemblageAvgAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    sousSousAssemblageId: number | null
    nombre: number | null
  }

  export type SousAssemblageSousSousAssemblageSumAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    sousSousAssemblageId: number | null
    nombre: number | null
  }

  export type SousAssemblageSousSousAssemblageMinAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    sousSousAssemblageId: number | null
    nombre: number | null
  }

  export type SousAssemblageSousSousAssemblageMaxAggregateOutputType = {
    id: number | null
    sousAssemblageId: number | null
    sousSousAssemblageId: number | null
    nombre: number | null
  }

  export type SousAssemblageSousSousAssemblageCountAggregateOutputType = {
    id: number
    sousAssemblageId: number
    sousSousAssemblageId: number
    nombre: number
    _all: number
  }


  export type SousAssemblageSousSousAssemblageAvgAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    sousSousAssemblageId?: true
    nombre?: true
  }

  export type SousAssemblageSousSousAssemblageSumAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    sousSousAssemblageId?: true
    nombre?: true
  }

  export type SousAssemblageSousSousAssemblageMinAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    sousSousAssemblageId?: true
    nombre?: true
  }

  export type SousAssemblageSousSousAssemblageMaxAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    sousSousAssemblageId?: true
    nombre?: true
  }

  export type SousAssemblageSousSousAssemblageCountAggregateInputType = {
    id?: true
    sousAssemblageId?: true
    sousSousAssemblageId?: true
    nombre?: true
    _all?: true
  }

  export type SousAssemblageSousSousAssemblageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousAssemblageSousSousAssemblage to aggregate.
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblageSousSousAssemblages to fetch.
     */
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithRelationInput | SousAssemblageSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SousAssemblageSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblageSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblageSousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SousAssemblageSousSousAssemblages
    **/
    _count?: true | SousAssemblageSousSousAssemblageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SousAssemblageSousSousAssemblageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SousAssemblageSousSousAssemblageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SousAssemblageSousSousAssemblageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SousAssemblageSousSousAssemblageMaxAggregateInputType
  }

  export type GetSousAssemblageSousSousAssemblageAggregateType<T extends SousAssemblageSousSousAssemblageAggregateArgs> = {
        [P in keyof T & keyof AggregateSousAssemblageSousSousAssemblage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSousAssemblageSousSousAssemblage[P]>
      : GetScalarType<T[P], AggregateSousAssemblageSousSousAssemblage[P]>
  }




  export type SousAssemblageSousSousAssemblageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SousAssemblageSousSousAssemblageWhereInput
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithAggregationInput | SousAssemblageSousSousAssemblageOrderByWithAggregationInput[]
    by: SousAssemblageSousSousAssemblageScalarFieldEnum[] | SousAssemblageSousSousAssemblageScalarFieldEnum
    having?: SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SousAssemblageSousSousAssemblageCountAggregateInputType | true
    _avg?: SousAssemblageSousSousAssemblageAvgAggregateInputType
    _sum?: SousAssemblageSousSousAssemblageSumAggregateInputType
    _min?: SousAssemblageSousSousAssemblageMinAggregateInputType
    _max?: SousAssemblageSousSousAssemblageMaxAggregateInputType
  }

  export type SousAssemblageSousSousAssemblageGroupByOutputType = {
    id: number
    sousAssemblageId: number
    sousSousAssemblageId: number
    nombre: number
    _count: SousAssemblageSousSousAssemblageCountAggregateOutputType | null
    _avg: SousAssemblageSousSousAssemblageAvgAggregateOutputType | null
    _sum: SousAssemblageSousSousAssemblageSumAggregateOutputType | null
    _min: SousAssemblageSousSousAssemblageMinAggregateOutputType | null
    _max: SousAssemblageSousSousAssemblageMaxAggregateOutputType | null
  }

  type GetSousAssemblageSousSousAssemblageGroupByPayload<T extends SousAssemblageSousSousAssemblageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SousAssemblageSousSousAssemblageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SousAssemblageSousSousAssemblageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SousAssemblageSousSousAssemblageGroupByOutputType[P]>
            : GetScalarType<T[P], SousAssemblageSousSousAssemblageGroupByOutputType[P]>
        }
      >
    >


  export type SousAssemblageSousSousAssemblageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousAssemblageId?: boolean
    sousSousAssemblageId?: boolean
    nombre?: boolean
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblageSousSousAssemblage"]>

  export type SousAssemblageSousSousAssemblageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousAssemblageId?: boolean
    sousSousAssemblageId?: boolean
    nombre?: boolean
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblageSousSousAssemblage"]>

  export type SousAssemblageSousSousAssemblageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sousAssemblageId?: boolean
    sousSousAssemblageId?: boolean
    nombre?: boolean
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sousAssemblageSousSousAssemblage"]>

  export type SousAssemblageSousSousAssemblageSelectScalar = {
    id?: boolean
    sousAssemblageId?: boolean
    sousSousAssemblageId?: boolean
    nombre?: boolean
  }

  export type SousAssemblageSousSousAssemblageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sousAssemblageId" | "sousSousAssemblageId" | "nombre", ExtArgs["result"]["sousAssemblageSousSousAssemblage"]>
  export type SousAssemblageSousSousAssemblageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }
  export type SousAssemblageSousSousAssemblageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }
  export type SousAssemblageSousSousAssemblageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
  }

  export type $SousAssemblageSousSousAssemblagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SousAssemblageSousSousAssemblage"
    objects: {
      sousAssemblage: Prisma.$SousAssemblagePayload<ExtArgs>
      sousSousAssemblage: Prisma.$SousSousAssemblagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sousAssemblageId: number
      sousSousAssemblageId: number
      nombre: number
    }, ExtArgs["result"]["sousAssemblageSousSousAssemblage"]>
    composites: {}
  }

  type SousAssemblageSousSousAssemblageGetPayload<S extends boolean | null | undefined | SousAssemblageSousSousAssemblageDefaultArgs> = $Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload, S>

  type SousAssemblageSousSousAssemblageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SousAssemblageSousSousAssemblageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SousAssemblageSousSousAssemblageCountAggregateInputType | true
    }

  export interface SousAssemblageSousSousAssemblageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SousAssemblageSousSousAssemblage'], meta: { name: 'SousAssemblageSousSousAssemblage' } }
    /**
     * Find zero or one SousAssemblageSousSousAssemblage that matches the filter.
     * @param {SousAssemblageSousSousAssemblageFindUniqueArgs} args - Arguments to find a SousAssemblageSousSousAssemblage
     * @example
     * // Get one SousAssemblageSousSousAssemblage
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SousAssemblageSousSousAssemblageFindUniqueArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageFindUniqueArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SousAssemblageSousSousAssemblage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SousAssemblageSousSousAssemblageFindUniqueOrThrowArgs} args - Arguments to find a SousAssemblageSousSousAssemblage
     * @example
     * // Get one SousAssemblageSousSousAssemblage
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SousAssemblageSousSousAssemblageFindUniqueOrThrowArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousAssemblageSousSousAssemblage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageFindFirstArgs} args - Arguments to find a SousAssemblageSousSousAssemblage
     * @example
     * // Get one SousAssemblageSousSousAssemblage
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SousAssemblageSousSousAssemblageFindFirstArgs>(args?: SelectSubset<T, SousAssemblageSousSousAssemblageFindFirstArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SousAssemblageSousSousAssemblage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageFindFirstOrThrowArgs} args - Arguments to find a SousAssemblageSousSousAssemblage
     * @example
     * // Get one SousAssemblageSousSousAssemblage
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SousAssemblageSousSousAssemblageFindFirstOrThrowArgs>(args?: SelectSubset<T, SousAssemblageSousSousAssemblageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SousAssemblageSousSousAssemblages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SousAssemblageSousSousAssemblages
     * const sousAssemblageSousSousAssemblages = await prisma.sousAssemblageSousSousAssemblage.findMany()
     * 
     * // Get first 10 SousAssemblageSousSousAssemblages
     * const sousAssemblageSousSousAssemblages = await prisma.sousAssemblageSousSousAssemblage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sousAssemblageSousSousAssemblageWithIdOnly = await prisma.sousAssemblageSousSousAssemblage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SousAssemblageSousSousAssemblageFindManyArgs>(args?: SelectSubset<T, SousAssemblageSousSousAssemblageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SousAssemblageSousSousAssemblage.
     * @param {SousAssemblageSousSousAssemblageCreateArgs} args - Arguments to create a SousAssemblageSousSousAssemblage.
     * @example
     * // Create one SousAssemblageSousSousAssemblage
     * const SousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.create({
     *   data: {
     *     // ... data to create a SousAssemblageSousSousAssemblage
     *   }
     * })
     * 
     */
    create<T extends SousAssemblageSousSousAssemblageCreateArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageCreateArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SousAssemblageSousSousAssemblages.
     * @param {SousAssemblageSousSousAssemblageCreateManyArgs} args - Arguments to create many SousAssemblageSousSousAssemblages.
     * @example
     * // Create many SousAssemblageSousSousAssemblages
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SousAssemblageSousSousAssemblageCreateManyArgs>(args?: SelectSubset<T, SousAssemblageSousSousAssemblageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SousAssemblageSousSousAssemblages and returns the data saved in the database.
     * @param {SousAssemblageSousSousAssemblageCreateManyAndReturnArgs} args - Arguments to create many SousAssemblageSousSousAssemblages.
     * @example
     * // Create many SousAssemblageSousSousAssemblages
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SousAssemblageSousSousAssemblages and only return the `id`
     * const sousAssemblageSousSousAssemblageWithIdOnly = await prisma.sousAssemblageSousSousAssemblage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SousAssemblageSousSousAssemblageCreateManyAndReturnArgs>(args?: SelectSubset<T, SousAssemblageSousSousAssemblageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SousAssemblageSousSousAssemblage.
     * @param {SousAssemblageSousSousAssemblageDeleteArgs} args - Arguments to delete one SousAssemblageSousSousAssemblage.
     * @example
     * // Delete one SousAssemblageSousSousAssemblage
     * const SousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.delete({
     *   where: {
     *     // ... filter to delete one SousAssemblageSousSousAssemblage
     *   }
     * })
     * 
     */
    delete<T extends SousAssemblageSousSousAssemblageDeleteArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageDeleteArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SousAssemblageSousSousAssemblage.
     * @param {SousAssemblageSousSousAssemblageUpdateArgs} args - Arguments to update one SousAssemblageSousSousAssemblage.
     * @example
     * // Update one SousAssemblageSousSousAssemblage
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SousAssemblageSousSousAssemblageUpdateArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageUpdateArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SousAssemblageSousSousAssemblages.
     * @param {SousAssemblageSousSousAssemblageDeleteManyArgs} args - Arguments to filter SousAssemblageSousSousAssemblages to delete.
     * @example
     * // Delete a few SousAssemblageSousSousAssemblages
     * const { count } = await prisma.sousAssemblageSousSousAssemblage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SousAssemblageSousSousAssemblageDeleteManyArgs>(args?: SelectSubset<T, SousAssemblageSousSousAssemblageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousAssemblageSousSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SousAssemblageSousSousAssemblages
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SousAssemblageSousSousAssemblageUpdateManyArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SousAssemblageSousSousAssemblages and returns the data updated in the database.
     * @param {SousAssemblageSousSousAssemblageUpdateManyAndReturnArgs} args - Arguments to update many SousAssemblageSousSousAssemblages.
     * @example
     * // Update many SousAssemblageSousSousAssemblages
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SousAssemblageSousSousAssemblages and only return the `id`
     * const sousAssemblageSousSousAssemblageWithIdOnly = await prisma.sousAssemblageSousSousAssemblage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SousAssemblageSousSousAssemblageUpdateManyAndReturnArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SousAssemblageSousSousAssemblage.
     * @param {SousAssemblageSousSousAssemblageUpsertArgs} args - Arguments to update or create a SousAssemblageSousSousAssemblage.
     * @example
     * // Update or create a SousAssemblageSousSousAssemblage
     * const sousAssemblageSousSousAssemblage = await prisma.sousAssemblageSousSousAssemblage.upsert({
     *   create: {
     *     // ... data to create a SousAssemblageSousSousAssemblage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SousAssemblageSousSousAssemblage we want to update
     *   }
     * })
     */
    upsert<T extends SousAssemblageSousSousAssemblageUpsertArgs>(args: SelectSubset<T, SousAssemblageSousSousAssemblageUpsertArgs<ExtArgs>>): Prisma__SousAssemblageSousSousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblageSousSousAssemblagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SousAssemblageSousSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageCountArgs} args - Arguments to filter SousAssemblageSousSousAssemblages to count.
     * @example
     * // Count the number of SousAssemblageSousSousAssemblages
     * const count = await prisma.sousAssemblageSousSousAssemblage.count({
     *   where: {
     *     // ... the filter for the SousAssemblageSousSousAssemblages we want to count
     *   }
     * })
    **/
    count<T extends SousAssemblageSousSousAssemblageCountArgs>(
      args?: Subset<T, SousAssemblageSousSousAssemblageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SousAssemblageSousSousAssemblageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SousAssemblageSousSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SousAssemblageSousSousAssemblageAggregateArgs>(args: Subset<T, SousAssemblageSousSousAssemblageAggregateArgs>): Prisma.PrismaPromise<GetSousAssemblageSousSousAssemblageAggregateType<T>>

    /**
     * Group by SousAssemblageSousSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SousAssemblageSousSousAssemblageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SousAssemblageSousSousAssemblageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SousAssemblageSousSousAssemblageGroupByArgs['orderBy'] }
        : { orderBy?: SousAssemblageSousSousAssemblageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SousAssemblageSousSousAssemblageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSousAssemblageSousSousAssemblageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SousAssemblageSousSousAssemblage model
   */
  readonly fields: SousAssemblageSousSousAssemblageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SousAssemblageSousSousAssemblage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SousAssemblageSousSousAssemblageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sousAssemblage<T extends SousAssemblageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblageDefaultArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sousSousAssemblage<T extends SousSousAssemblageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblageDefaultArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SousAssemblageSousSousAssemblage model
   */
  interface SousAssemblageSousSousAssemblageFieldRefs {
    readonly id: FieldRef<"SousAssemblageSousSousAssemblage", 'Int'>
    readonly sousAssemblageId: FieldRef<"SousAssemblageSousSousAssemblage", 'Int'>
    readonly sousSousAssemblageId: FieldRef<"SousAssemblageSousSousAssemblage", 'Int'>
    readonly nombre: FieldRef<"SousAssemblageSousSousAssemblage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SousAssemblageSousSousAssemblage findUnique
   */
  export type SousAssemblageSousSousAssemblageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblageSousSousAssemblage to fetch.
     */
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblageSousSousAssemblage findUniqueOrThrow
   */
  export type SousAssemblageSousSousAssemblageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblageSousSousAssemblage to fetch.
     */
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblageSousSousAssemblage findFirst
   */
  export type SousAssemblageSousSousAssemblageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblageSousSousAssemblage to fetch.
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblageSousSousAssemblages to fetch.
     */
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithRelationInput | SousAssemblageSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousAssemblageSousSousAssemblages.
     */
    cursor?: SousAssemblageSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblageSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblageSousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousAssemblageSousSousAssemblages.
     */
    distinct?: SousAssemblageSousSousAssemblageScalarFieldEnum | SousAssemblageSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblageSousSousAssemblage findFirstOrThrow
   */
  export type SousAssemblageSousSousAssemblageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblageSousSousAssemblage to fetch.
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblageSousSousAssemblages to fetch.
     */
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithRelationInput | SousAssemblageSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SousAssemblageSousSousAssemblages.
     */
    cursor?: SousAssemblageSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblageSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblageSousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SousAssemblageSousSousAssemblages.
     */
    distinct?: SousAssemblageSousSousAssemblageScalarFieldEnum | SousAssemblageSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblageSousSousAssemblage findMany
   */
  export type SousAssemblageSousSousAssemblageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which SousAssemblageSousSousAssemblages to fetch.
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SousAssemblageSousSousAssemblages to fetch.
     */
    orderBy?: SousAssemblageSousSousAssemblageOrderByWithRelationInput | SousAssemblageSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SousAssemblageSousSousAssemblages.
     */
    cursor?: SousAssemblageSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SousAssemblageSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SousAssemblageSousSousAssemblages.
     */
    skip?: number
    distinct?: SousAssemblageSousSousAssemblageScalarFieldEnum | SousAssemblageSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * SousAssemblageSousSousAssemblage create
   */
  export type SousAssemblageSousSousAssemblageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to create a SousAssemblageSousSousAssemblage.
     */
    data: XOR<SousAssemblageSousSousAssemblageCreateInput, SousAssemblageSousSousAssemblageUncheckedCreateInput>
  }

  /**
   * SousAssemblageSousSousAssemblage createMany
   */
  export type SousAssemblageSousSousAssemblageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SousAssemblageSousSousAssemblages.
     */
    data: SousAssemblageSousSousAssemblageCreateManyInput | SousAssemblageSousSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SousAssemblageSousSousAssemblage createManyAndReturn
   */
  export type SousAssemblageSousSousAssemblageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to create many SousAssemblageSousSousAssemblages.
     */
    data: SousAssemblageSousSousAssemblageCreateManyInput | SousAssemblageSousSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SousAssemblageSousSousAssemblage update
   */
  export type SousAssemblageSousSousAssemblageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to update a SousAssemblageSousSousAssemblage.
     */
    data: XOR<SousAssemblageSousSousAssemblageUpdateInput, SousAssemblageSousSousAssemblageUncheckedUpdateInput>
    /**
     * Choose, which SousAssemblageSousSousAssemblage to update.
     */
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblageSousSousAssemblage updateMany
   */
  export type SousAssemblageSousSousAssemblageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SousAssemblageSousSousAssemblages.
     */
    data: XOR<SousAssemblageSousSousAssemblageUpdateManyMutationInput, SousAssemblageSousSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which SousAssemblageSousSousAssemblages to update
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * Limit how many SousAssemblageSousSousAssemblages to update.
     */
    limit?: number
  }

  /**
   * SousAssemblageSousSousAssemblage updateManyAndReturn
   */
  export type SousAssemblageSousSousAssemblageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to update SousAssemblageSousSousAssemblages.
     */
    data: XOR<SousAssemblageSousSousAssemblageUpdateManyMutationInput, SousAssemblageSousSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which SousAssemblageSousSousAssemblages to update
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * Limit how many SousAssemblageSousSousAssemblages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SousAssemblageSousSousAssemblage upsert
   */
  export type SousAssemblageSousSousAssemblageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * The filter to search for the SousAssemblageSousSousAssemblage to update in case it exists.
     */
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    /**
     * In case the SousAssemblageSousSousAssemblage found by the `where` argument doesn't exist, create a new SousAssemblageSousSousAssemblage with this data.
     */
    create: XOR<SousAssemblageSousSousAssemblageCreateInput, SousAssemblageSousSousAssemblageUncheckedCreateInput>
    /**
     * In case the SousAssemblageSousSousAssemblage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SousAssemblageSousSousAssemblageUpdateInput, SousAssemblageSousSousAssemblageUncheckedUpdateInput>
  }

  /**
   * SousAssemblageSousSousAssemblage delete
   */
  export type SousAssemblageSousSousAssemblageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter which SousAssemblageSousSousAssemblage to delete.
     */
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
  }

  /**
   * SousAssemblageSousSousAssemblage deleteMany
   */
  export type SousAssemblageSousSousAssemblageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SousAssemblageSousSousAssemblages to delete
     */
    where?: SousAssemblageSousSousAssemblageWhereInput
    /**
     * Limit how many SousAssemblageSousSousAssemblages to delete.
     */
    limit?: number
  }

  /**
   * SousAssemblageSousSousAssemblage without action
   */
  export type SousAssemblageSousSousAssemblageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SousAssemblageSousSousAssemblage
     */
    select?: SousAssemblageSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SousAssemblageSousSousAssemblage
     */
    omit?: SousAssemblageSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SousAssemblageSousSousAssemblageInclude<ExtArgs> | null
  }


  /**
   * Model KitPiece
   */

  export type AggregateKitPiece = {
    _count: KitPieceCountAggregateOutputType | null
    _avg: KitPieceAvgAggregateOutputType | null
    _sum: KitPieceSumAggregateOutputType | null
    _min: KitPieceMinAggregateOutputType | null
    _max: KitPieceMaxAggregateOutputType | null
  }

  export type KitPieceAvgAggregateOutputType = {
    id: number | null
    kitId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type KitPieceSumAggregateOutputType = {
    id: number | null
    kitId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type KitPieceMinAggregateOutputType = {
    id: number | null
    kitId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type KitPieceMaxAggregateOutputType = {
    id: number | null
    kitId: number | null
    pieceId: number | null
    nombre: number | null
  }

  export type KitPieceCountAggregateOutputType = {
    id: number
    kitId: number
    pieceId: number
    nombre: number
    _all: number
  }


  export type KitPieceAvgAggregateInputType = {
    id?: true
    kitId?: true
    pieceId?: true
    nombre?: true
  }

  export type KitPieceSumAggregateInputType = {
    id?: true
    kitId?: true
    pieceId?: true
    nombre?: true
  }

  export type KitPieceMinAggregateInputType = {
    id?: true
    kitId?: true
    pieceId?: true
    nombre?: true
  }

  export type KitPieceMaxAggregateInputType = {
    id?: true
    kitId?: true
    pieceId?: true
    nombre?: true
  }

  export type KitPieceCountAggregateInputType = {
    id?: true
    kitId?: true
    pieceId?: true
    nombre?: true
    _all?: true
  }

  export type KitPieceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KitPiece to aggregate.
     */
    where?: KitPieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitPieces to fetch.
     */
    orderBy?: KitPieceOrderByWithRelationInput | KitPieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitPieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitPieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitPieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KitPieces
    **/
    _count?: true | KitPieceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KitPieceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KitPieceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitPieceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitPieceMaxAggregateInputType
  }

  export type GetKitPieceAggregateType<T extends KitPieceAggregateArgs> = {
        [P in keyof T & keyof AggregateKitPiece]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitPiece[P]>
      : GetScalarType<T[P], AggregateKitPiece[P]>
  }




  export type KitPieceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitPieceWhereInput
    orderBy?: KitPieceOrderByWithAggregationInput | KitPieceOrderByWithAggregationInput[]
    by: KitPieceScalarFieldEnum[] | KitPieceScalarFieldEnum
    having?: KitPieceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitPieceCountAggregateInputType | true
    _avg?: KitPieceAvgAggregateInputType
    _sum?: KitPieceSumAggregateInputType
    _min?: KitPieceMinAggregateInputType
    _max?: KitPieceMaxAggregateInputType
  }

  export type KitPieceGroupByOutputType = {
    id: number
    kitId: number
    pieceId: number
    nombre: number
    _count: KitPieceCountAggregateOutputType | null
    _avg: KitPieceAvgAggregateOutputType | null
    _sum: KitPieceSumAggregateOutputType | null
    _min: KitPieceMinAggregateOutputType | null
    _max: KitPieceMaxAggregateOutputType | null
  }

  type GetKitPieceGroupByPayload<T extends KitPieceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitPieceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitPieceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitPieceGroupByOutputType[P]>
            : GetScalarType<T[P], KitPieceGroupByOutputType[P]>
        }
      >
    >


  export type KitPieceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitId?: boolean
    pieceId?: boolean
    nombre?: boolean
    kit?: boolean | KitDefaultArgs<ExtArgs>
    piece?: boolean | PieceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitPiece"]>

  export type KitPieceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitId?: boolean
    pieceId?: boolean
    nombre?: boolean
    kit?: boolean | KitDefaultArgs<ExtArgs>
    piece?: boolean | PieceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitPiece"]>

  export type KitPieceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitId?: boolean
    pieceId?: boolean
    nombre?: boolean
    kit?: boolean | KitDefaultArgs<ExtArgs>
    piece?: boolean | PieceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitPiece"]>

  export type KitPieceSelectScalar = {
    id?: boolean
    kitId?: boolean
    pieceId?: boolean
    nombre?: boolean
  }

  export type KitPieceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kitId" | "pieceId" | "nombre", ExtArgs["result"]["kitPiece"]>
  export type KitPieceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kit?: boolean | KitDefaultArgs<ExtArgs>
    piece?: boolean | PieceDefaultArgs<ExtArgs>
  }
  export type KitPieceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kit?: boolean | KitDefaultArgs<ExtArgs>
    piece?: boolean | PieceDefaultArgs<ExtArgs>
  }
  export type KitPieceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kit?: boolean | KitDefaultArgs<ExtArgs>
    piece?: boolean | PieceDefaultArgs<ExtArgs>
  }

  export type $KitPiecePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KitPiece"
    objects: {
      kit: Prisma.$KitPayload<ExtArgs>
      piece: Prisma.$PiecePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kitId: number
      pieceId: number
      nombre: number
    }, ExtArgs["result"]["kitPiece"]>
    composites: {}
  }

  type KitPieceGetPayload<S extends boolean | null | undefined | KitPieceDefaultArgs> = $Result.GetResult<Prisma.$KitPiecePayload, S>

  type KitPieceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KitPieceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KitPieceCountAggregateInputType | true
    }

  export interface KitPieceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KitPiece'], meta: { name: 'KitPiece' } }
    /**
     * Find zero or one KitPiece that matches the filter.
     * @param {KitPieceFindUniqueArgs} args - Arguments to find a KitPiece
     * @example
     * // Get one KitPiece
     * const kitPiece = await prisma.kitPiece.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitPieceFindUniqueArgs>(args: SelectSubset<T, KitPieceFindUniqueArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KitPiece that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KitPieceFindUniqueOrThrowArgs} args - Arguments to find a KitPiece
     * @example
     * // Get one KitPiece
     * const kitPiece = await prisma.kitPiece.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitPieceFindUniqueOrThrowArgs>(args: SelectSubset<T, KitPieceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KitPiece that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceFindFirstArgs} args - Arguments to find a KitPiece
     * @example
     * // Get one KitPiece
     * const kitPiece = await prisma.kitPiece.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitPieceFindFirstArgs>(args?: SelectSubset<T, KitPieceFindFirstArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KitPiece that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceFindFirstOrThrowArgs} args - Arguments to find a KitPiece
     * @example
     * // Get one KitPiece
     * const kitPiece = await prisma.kitPiece.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitPieceFindFirstOrThrowArgs>(args?: SelectSubset<T, KitPieceFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KitPieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KitPieces
     * const kitPieces = await prisma.kitPiece.findMany()
     * 
     * // Get first 10 KitPieces
     * const kitPieces = await prisma.kitPiece.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitPieceWithIdOnly = await prisma.kitPiece.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KitPieceFindManyArgs>(args?: SelectSubset<T, KitPieceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KitPiece.
     * @param {KitPieceCreateArgs} args - Arguments to create a KitPiece.
     * @example
     * // Create one KitPiece
     * const KitPiece = await prisma.kitPiece.create({
     *   data: {
     *     // ... data to create a KitPiece
     *   }
     * })
     * 
     */
    create<T extends KitPieceCreateArgs>(args: SelectSubset<T, KitPieceCreateArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KitPieces.
     * @param {KitPieceCreateManyArgs} args - Arguments to create many KitPieces.
     * @example
     * // Create many KitPieces
     * const kitPiece = await prisma.kitPiece.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitPieceCreateManyArgs>(args?: SelectSubset<T, KitPieceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KitPieces and returns the data saved in the database.
     * @param {KitPieceCreateManyAndReturnArgs} args - Arguments to create many KitPieces.
     * @example
     * // Create many KitPieces
     * const kitPiece = await prisma.kitPiece.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KitPieces and only return the `id`
     * const kitPieceWithIdOnly = await prisma.kitPiece.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitPieceCreateManyAndReturnArgs>(args?: SelectSubset<T, KitPieceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KitPiece.
     * @param {KitPieceDeleteArgs} args - Arguments to delete one KitPiece.
     * @example
     * // Delete one KitPiece
     * const KitPiece = await prisma.kitPiece.delete({
     *   where: {
     *     // ... filter to delete one KitPiece
     *   }
     * })
     * 
     */
    delete<T extends KitPieceDeleteArgs>(args: SelectSubset<T, KitPieceDeleteArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KitPiece.
     * @param {KitPieceUpdateArgs} args - Arguments to update one KitPiece.
     * @example
     * // Update one KitPiece
     * const kitPiece = await prisma.kitPiece.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitPieceUpdateArgs>(args: SelectSubset<T, KitPieceUpdateArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KitPieces.
     * @param {KitPieceDeleteManyArgs} args - Arguments to filter KitPieces to delete.
     * @example
     * // Delete a few KitPieces
     * const { count } = await prisma.kitPiece.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitPieceDeleteManyArgs>(args?: SelectSubset<T, KitPieceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KitPieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KitPieces
     * const kitPiece = await prisma.kitPiece.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitPieceUpdateManyArgs>(args: SelectSubset<T, KitPieceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KitPieces and returns the data updated in the database.
     * @param {KitPieceUpdateManyAndReturnArgs} args - Arguments to update many KitPieces.
     * @example
     * // Update many KitPieces
     * const kitPiece = await prisma.kitPiece.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KitPieces and only return the `id`
     * const kitPieceWithIdOnly = await prisma.kitPiece.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KitPieceUpdateManyAndReturnArgs>(args: SelectSubset<T, KitPieceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KitPiece.
     * @param {KitPieceUpsertArgs} args - Arguments to update or create a KitPiece.
     * @example
     * // Update or create a KitPiece
     * const kitPiece = await prisma.kitPiece.upsert({
     *   create: {
     *     // ... data to create a KitPiece
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KitPiece we want to update
     *   }
     * })
     */
    upsert<T extends KitPieceUpsertArgs>(args: SelectSubset<T, KitPieceUpsertArgs<ExtArgs>>): Prisma__KitPieceClient<$Result.GetResult<Prisma.$KitPiecePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KitPieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceCountArgs} args - Arguments to filter KitPieces to count.
     * @example
     * // Count the number of KitPieces
     * const count = await prisma.kitPiece.count({
     *   where: {
     *     // ... the filter for the KitPieces we want to count
     *   }
     * })
    **/
    count<T extends KitPieceCountArgs>(
      args?: Subset<T, KitPieceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitPieceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KitPiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitPieceAggregateArgs>(args: Subset<T, KitPieceAggregateArgs>): Prisma.PrismaPromise<GetKitPieceAggregateType<T>>

    /**
     * Group by KitPiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitPieceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitPieceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitPieceGroupByArgs['orderBy'] }
        : { orderBy?: KitPieceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitPieceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitPieceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KitPiece model
   */
  readonly fields: KitPieceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KitPiece.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitPieceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kit<T extends KitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitDefaultArgs<ExtArgs>>): Prisma__KitClient<$Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    piece<T extends PieceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PieceDefaultArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KitPiece model
   */
  interface KitPieceFieldRefs {
    readonly id: FieldRef<"KitPiece", 'Int'>
    readonly kitId: FieldRef<"KitPiece", 'Int'>
    readonly pieceId: FieldRef<"KitPiece", 'Int'>
    readonly nombre: FieldRef<"KitPiece", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KitPiece findUnique
   */
  export type KitPieceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * Filter, which KitPiece to fetch.
     */
    where: KitPieceWhereUniqueInput
  }

  /**
   * KitPiece findUniqueOrThrow
   */
  export type KitPieceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * Filter, which KitPiece to fetch.
     */
    where: KitPieceWhereUniqueInput
  }

  /**
   * KitPiece findFirst
   */
  export type KitPieceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * Filter, which KitPiece to fetch.
     */
    where?: KitPieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitPieces to fetch.
     */
    orderBy?: KitPieceOrderByWithRelationInput | KitPieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KitPieces.
     */
    cursor?: KitPieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitPieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitPieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KitPieces.
     */
    distinct?: KitPieceScalarFieldEnum | KitPieceScalarFieldEnum[]
  }

  /**
   * KitPiece findFirstOrThrow
   */
  export type KitPieceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * Filter, which KitPiece to fetch.
     */
    where?: KitPieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitPieces to fetch.
     */
    orderBy?: KitPieceOrderByWithRelationInput | KitPieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KitPieces.
     */
    cursor?: KitPieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitPieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitPieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KitPieces.
     */
    distinct?: KitPieceScalarFieldEnum | KitPieceScalarFieldEnum[]
  }

  /**
   * KitPiece findMany
   */
  export type KitPieceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * Filter, which KitPieces to fetch.
     */
    where?: KitPieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitPieces to fetch.
     */
    orderBy?: KitPieceOrderByWithRelationInput | KitPieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KitPieces.
     */
    cursor?: KitPieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitPieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitPieces.
     */
    skip?: number
    distinct?: KitPieceScalarFieldEnum | KitPieceScalarFieldEnum[]
  }

  /**
   * KitPiece create
   */
  export type KitPieceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * The data needed to create a KitPiece.
     */
    data: XOR<KitPieceCreateInput, KitPieceUncheckedCreateInput>
  }

  /**
   * KitPiece createMany
   */
  export type KitPieceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KitPieces.
     */
    data: KitPieceCreateManyInput | KitPieceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KitPiece createManyAndReturn
   */
  export type KitPieceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * The data used to create many KitPieces.
     */
    data: KitPieceCreateManyInput | KitPieceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KitPiece update
   */
  export type KitPieceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * The data needed to update a KitPiece.
     */
    data: XOR<KitPieceUpdateInput, KitPieceUncheckedUpdateInput>
    /**
     * Choose, which KitPiece to update.
     */
    where: KitPieceWhereUniqueInput
  }

  /**
   * KitPiece updateMany
   */
  export type KitPieceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KitPieces.
     */
    data: XOR<KitPieceUpdateManyMutationInput, KitPieceUncheckedUpdateManyInput>
    /**
     * Filter which KitPieces to update
     */
    where?: KitPieceWhereInput
    /**
     * Limit how many KitPieces to update.
     */
    limit?: number
  }

  /**
   * KitPiece updateManyAndReturn
   */
  export type KitPieceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * The data used to update KitPieces.
     */
    data: XOR<KitPieceUpdateManyMutationInput, KitPieceUncheckedUpdateManyInput>
    /**
     * Filter which KitPieces to update
     */
    where?: KitPieceWhereInput
    /**
     * Limit how many KitPieces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KitPiece upsert
   */
  export type KitPieceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * The filter to search for the KitPiece to update in case it exists.
     */
    where: KitPieceWhereUniqueInput
    /**
     * In case the KitPiece found by the `where` argument doesn't exist, create a new KitPiece with this data.
     */
    create: XOR<KitPieceCreateInput, KitPieceUncheckedCreateInput>
    /**
     * In case the KitPiece was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitPieceUpdateInput, KitPieceUncheckedUpdateInput>
  }

  /**
   * KitPiece delete
   */
  export type KitPieceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
    /**
     * Filter which KitPiece to delete.
     */
    where: KitPieceWhereUniqueInput
  }

  /**
   * KitPiece deleteMany
   */
  export type KitPieceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KitPieces to delete
     */
    where?: KitPieceWhereInput
    /**
     * Limit how many KitPieces to delete.
     */
    limit?: number
  }

  /**
   * KitPiece without action
   */
  export type KitPieceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitPiece
     */
    select?: KitPieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitPiece
     */
    omit?: KitPieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitPieceInclude<ExtArgs> | null
  }


  /**
   * Model StockLog
   */

  export type AggregateStockLog = {
    _count: StockLogCountAggregateOutputType | null
    _avg: StockLogAvgAggregateOutputType | null
    _sum: StockLogSumAggregateOutputType | null
    _min: StockLogMinAggregateOutputType | null
    _max: StockLogMaxAggregateOutputType | null
  }

  export type StockLogAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    quantity: number | null
    userId: number | null
  }

  export type StockLogSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    quantity: number | null
    userId: number | null
  }

  export type StockLogMinAggregateOutputType = {
    id: number | null
    type: string | null
    itemId: number | null
    quantity: number | null
    operation: $Enums.StockOperation | null
    createdAt: Date | null
    userId: number | null
  }

  export type StockLogMaxAggregateOutputType = {
    id: number | null
    type: string | null
    itemId: number | null
    quantity: number | null
    operation: $Enums.StockOperation | null
    createdAt: Date | null
    userId: number | null
  }

  export type StockLogCountAggregateOutputType = {
    id: number
    type: number
    itemId: number
    quantity: number
    operation: number
    createdAt: number
    userId: number
    _all: number
  }


  export type StockLogAvgAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    userId?: true
  }

  export type StockLogSumAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    userId?: true
  }

  export type StockLogMinAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    quantity?: true
    operation?: true
    createdAt?: true
    userId?: true
  }

  export type StockLogMaxAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    quantity?: true
    operation?: true
    createdAt?: true
    userId?: true
  }

  export type StockLogCountAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    quantity?: true
    operation?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type StockLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLog to aggregate.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockLogs
    **/
    _count?: true | StockLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockLogMaxAggregateInputType
  }

  export type GetStockLogAggregateType<T extends StockLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStockLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockLog[P]>
      : GetScalarType<T[P], AggregateStockLog[P]>
  }




  export type StockLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLogWhereInput
    orderBy?: StockLogOrderByWithAggregationInput | StockLogOrderByWithAggregationInput[]
    by: StockLogScalarFieldEnum[] | StockLogScalarFieldEnum
    having?: StockLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockLogCountAggregateInputType | true
    _avg?: StockLogAvgAggregateInputType
    _sum?: StockLogSumAggregateInputType
    _min?: StockLogMinAggregateInputType
    _max?: StockLogMaxAggregateInputType
  }

  export type StockLogGroupByOutputType = {
    id: number
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt: Date
    userId: number | null
    _count: StockLogCountAggregateOutputType | null
    _avg: StockLogAvgAggregateOutputType | null
    _sum: StockLogSumAggregateOutputType | null
    _min: StockLogMinAggregateOutputType | null
    _max: StockLogMaxAggregateOutputType | null
  }

  type GetStockLogGroupByPayload<T extends StockLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockLogGroupByOutputType[P]>
            : GetScalarType<T[P], StockLogGroupByOutputType[P]>
        }
      >
    >


  export type StockLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    itemId?: boolean
    quantity?: boolean
    operation?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | StockLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["stockLog"]>

  export type StockLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    itemId?: boolean
    quantity?: boolean
    operation?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | StockLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["stockLog"]>

  export type StockLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    itemId?: boolean
    quantity?: boolean
    operation?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | StockLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["stockLog"]>

  export type StockLogSelectScalar = {
    id?: boolean
    type?: boolean
    itemId?: boolean
    quantity?: boolean
    operation?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type StockLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "itemId" | "quantity" | "operation" | "createdAt" | "userId", ExtArgs["result"]["stockLog"]>
  export type StockLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StockLog$userArgs<ExtArgs>
  }
  export type StockLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StockLog$userArgs<ExtArgs>
  }
  export type StockLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StockLog$userArgs<ExtArgs>
  }

  export type $StockLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      itemId: number
      quantity: number
      operation: $Enums.StockOperation
      createdAt: Date
      userId: number | null
    }, ExtArgs["result"]["stockLog"]>
    composites: {}
  }

  type StockLogGetPayload<S extends boolean | null | undefined | StockLogDefaultArgs> = $Result.GetResult<Prisma.$StockLogPayload, S>

  type StockLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockLogCountAggregateInputType | true
    }

  export interface StockLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockLog'], meta: { name: 'StockLog' } }
    /**
     * Find zero or one StockLog that matches the filter.
     * @param {StockLogFindUniqueArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockLogFindUniqueArgs>(args: SelectSubset<T, StockLogFindUniqueArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockLogFindUniqueOrThrowArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StockLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogFindFirstArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockLogFindFirstArgs>(args?: SelectSubset<T, StockLogFindFirstArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogFindFirstOrThrowArgs} args - Arguments to find a StockLog
     * @example
     * // Get one StockLog
     * const stockLog = await prisma.stockLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StockLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockLogs
     * const stockLogs = await prisma.stockLog.findMany()
     * 
     * // Get first 10 StockLogs
     * const stockLogs = await prisma.stockLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockLogWithIdOnly = await prisma.stockLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockLogFindManyArgs>(args?: SelectSubset<T, StockLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockLog.
     * @param {StockLogCreateArgs} args - Arguments to create a StockLog.
     * @example
     * // Create one StockLog
     * const StockLog = await prisma.stockLog.create({
     *   data: {
     *     // ... data to create a StockLog
     *   }
     * })
     * 
     */
    create<T extends StockLogCreateArgs>(args: SelectSubset<T, StockLogCreateArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockLogs.
     * @param {StockLogCreateManyArgs} args - Arguments to create many StockLogs.
     * @example
     * // Create many StockLogs
     * const stockLog = await prisma.stockLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockLogCreateManyArgs>(args?: SelectSubset<T, StockLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockLogs and returns the data saved in the database.
     * @param {StockLogCreateManyAndReturnArgs} args - Arguments to create many StockLogs.
     * @example
     * // Create many StockLogs
     * const stockLog = await prisma.stockLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockLogs and only return the `id`
     * const stockLogWithIdOnly = await prisma.stockLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StockLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockLog.
     * @param {StockLogDeleteArgs} args - Arguments to delete one StockLog.
     * @example
     * // Delete one StockLog
     * const StockLog = await prisma.stockLog.delete({
     *   where: {
     *     // ... filter to delete one StockLog
     *   }
     * })
     * 
     */
    delete<T extends StockLogDeleteArgs>(args: SelectSubset<T, StockLogDeleteArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockLog.
     * @param {StockLogUpdateArgs} args - Arguments to update one StockLog.
     * @example
     * // Update one StockLog
     * const stockLog = await prisma.stockLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockLogUpdateArgs>(args: SelectSubset<T, StockLogUpdateArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockLogs.
     * @param {StockLogDeleteManyArgs} args - Arguments to filter StockLogs to delete.
     * @example
     * // Delete a few StockLogs
     * const { count } = await prisma.stockLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockLogDeleteManyArgs>(args?: SelectSubset<T, StockLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockLogs
     * const stockLog = await prisma.stockLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockLogUpdateManyArgs>(args: SelectSubset<T, StockLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLogs and returns the data updated in the database.
     * @param {StockLogUpdateManyAndReturnArgs} args - Arguments to update many StockLogs.
     * @example
     * // Update many StockLogs
     * const stockLog = await prisma.stockLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockLogs and only return the `id`
     * const stockLogWithIdOnly = await prisma.stockLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockLogUpdateManyAndReturnArgs>(args: SelectSubset<T, StockLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockLog.
     * @param {StockLogUpsertArgs} args - Arguments to update or create a StockLog.
     * @example
     * // Update or create a StockLog
     * const stockLog = await prisma.stockLog.upsert({
     *   create: {
     *     // ... data to create a StockLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockLog we want to update
     *   }
     * })
     */
    upsert<T extends StockLogUpsertArgs>(args: SelectSubset<T, StockLogUpsertArgs<ExtArgs>>): Prisma__StockLogClient<$Result.GetResult<Prisma.$StockLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogCountArgs} args - Arguments to filter StockLogs to count.
     * @example
     * // Count the number of StockLogs
     * const count = await prisma.stockLog.count({
     *   where: {
     *     // ... the filter for the StockLogs we want to count
     *   }
     * })
    **/
    count<T extends StockLogCountArgs>(
      args?: Subset<T, StockLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockLogAggregateArgs>(args: Subset<T, StockLogAggregateArgs>): Prisma.PrismaPromise<GetStockLogAggregateType<T>>

    /**
     * Group by StockLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockLogGroupByArgs['orderBy'] }
        : { orderBy?: StockLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockLog model
   */
  readonly fields: StockLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends StockLog$userArgs<ExtArgs> = {}>(args?: Subset<T, StockLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockLog model
   */
  interface StockLogFieldRefs {
    readonly id: FieldRef<"StockLog", 'Int'>
    readonly type: FieldRef<"StockLog", 'String'>
    readonly itemId: FieldRef<"StockLog", 'Int'>
    readonly quantity: FieldRef<"StockLog", 'Int'>
    readonly operation: FieldRef<"StockLog", 'StockOperation'>
    readonly createdAt: FieldRef<"StockLog", 'DateTime'>
    readonly userId: FieldRef<"StockLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StockLog findUnique
   */
  export type StockLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog findUniqueOrThrow
   */
  export type StockLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog findFirst
   */
  export type StockLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLogs.
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLogs.
     */
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * StockLog findFirstOrThrow
   */
  export type StockLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLog to fetch.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLogs.
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLogs.
     */
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * StockLog findMany
   */
  export type StockLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter, which StockLogs to fetch.
     */
    where?: StockLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLogs to fetch.
     */
    orderBy?: StockLogOrderByWithRelationInput | StockLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockLogs.
     */
    cursor?: StockLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLogs.
     */
    skip?: number
    distinct?: StockLogScalarFieldEnum | StockLogScalarFieldEnum[]
  }

  /**
   * StockLog create
   */
  export type StockLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StockLog.
     */
    data: XOR<StockLogCreateInput, StockLogUncheckedCreateInput>
  }

  /**
   * StockLog createMany
   */
  export type StockLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockLogs.
     */
    data: StockLogCreateManyInput | StockLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockLog createManyAndReturn
   */
  export type StockLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * The data used to create many StockLogs.
     */
    data: StockLogCreateManyInput | StockLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLog update
   */
  export type StockLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StockLog.
     */
    data: XOR<StockLogUpdateInput, StockLogUncheckedUpdateInput>
    /**
     * Choose, which StockLog to update.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog updateMany
   */
  export type StockLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockLogs.
     */
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyInput>
    /**
     * Filter which StockLogs to update
     */
    where?: StockLogWhereInput
    /**
     * Limit how many StockLogs to update.
     */
    limit?: number
  }

  /**
   * StockLog updateManyAndReturn
   */
  export type StockLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * The data used to update StockLogs.
     */
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyInput>
    /**
     * Filter which StockLogs to update
     */
    where?: StockLogWhereInput
    /**
     * Limit how many StockLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLog upsert
   */
  export type StockLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StockLog to update in case it exists.
     */
    where: StockLogWhereUniqueInput
    /**
     * In case the StockLog found by the `where` argument doesn't exist, create a new StockLog with this data.
     */
    create: XOR<StockLogCreateInput, StockLogUncheckedCreateInput>
    /**
     * In case the StockLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockLogUpdateInput, StockLogUncheckedUpdateInput>
  }

  /**
   * StockLog delete
   */
  export type StockLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
    /**
     * Filter which StockLog to delete.
     */
    where: StockLogWhereUniqueInput
  }

  /**
   * StockLog deleteMany
   */
  export type StockLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLogs to delete
     */
    where?: StockLogWhereInput
    /**
     * Limit how many StockLogs to delete.
     */
    limit?: number
  }

  /**
   * StockLog.user
   */
  export type StockLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockLog without action
   */
  export type StockLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLog
     */
    select?: StockLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLog
     */
    omit?: StockLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLogInclude<ExtArgs> | null
  }


  /**
   * Model TaskTemplate
   */

  export type AggregateTaskTemplate = {
    _count: TaskTemplateCountAggregateOutputType | null
    _avg: TaskTemplateAvgAggregateOutputType | null
    _sum: TaskTemplateSumAggregateOutputType | null
    _min: TaskTemplateMinAggregateOutputType | null
    _max: TaskTemplateMaxAggregateOutputType | null
  }

  export type TaskTemplateAvgAggregateOutputType = {
    id: number | null
    borneId: number | null
    order: number | null
    estimatedMinutesPerUnit: number | null
  }

  export type TaskTemplateSumAggregateOutputType = {
    id: number | null
    borneId: number | null
    order: number | null
    estimatedMinutesPerUnit: number | null
  }

  export type TaskTemplateMinAggregateOutputType = {
    id: number | null
    borneId: number | null
    label: string | null
    description: string | null
    order: number | null
    estimatedMinutesPerUnit: number | null
    active: boolean | null
  }

  export type TaskTemplateMaxAggregateOutputType = {
    id: number | null
    borneId: number | null
    label: string | null
    description: string | null
    order: number | null
    estimatedMinutesPerUnit: number | null
    active: boolean | null
  }

  export type TaskTemplateCountAggregateOutputType = {
    id: number
    borneId: number
    label: number
    description: number
    order: number
    estimatedMinutesPerUnit: number
    active: number
    _all: number
  }


  export type TaskTemplateAvgAggregateInputType = {
    id?: true
    borneId?: true
    order?: true
    estimatedMinutesPerUnit?: true
  }

  export type TaskTemplateSumAggregateInputType = {
    id?: true
    borneId?: true
    order?: true
    estimatedMinutesPerUnit?: true
  }

  export type TaskTemplateMinAggregateInputType = {
    id?: true
    borneId?: true
    label?: true
    description?: true
    order?: true
    estimatedMinutesPerUnit?: true
    active?: true
  }

  export type TaskTemplateMaxAggregateInputType = {
    id?: true
    borneId?: true
    label?: true
    description?: true
    order?: true
    estimatedMinutesPerUnit?: true
    active?: true
  }

  export type TaskTemplateCountAggregateInputType = {
    id?: true
    borneId?: true
    label?: true
    description?: true
    order?: true
    estimatedMinutesPerUnit?: true
    active?: true
    _all?: true
  }

  export type TaskTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplate to aggregate.
     */
    where?: TaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplates to fetch.
     */
    orderBy?: TaskTemplateOrderByWithRelationInput | TaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTemplates
    **/
    _count?: true | TaskTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTemplateMaxAggregateInputType
  }

  export type GetTaskTemplateAggregateType<T extends TaskTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTemplate[P]>
      : GetScalarType<T[P], AggregateTaskTemplate[P]>
  }




  export type TaskTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateWhereInput
    orderBy?: TaskTemplateOrderByWithAggregationInput | TaskTemplateOrderByWithAggregationInput[]
    by: TaskTemplateScalarFieldEnum[] | TaskTemplateScalarFieldEnum
    having?: TaskTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTemplateCountAggregateInputType | true
    _avg?: TaskTemplateAvgAggregateInputType
    _sum?: TaskTemplateSumAggregateInputType
    _min?: TaskTemplateMinAggregateInputType
    _max?: TaskTemplateMaxAggregateInputType
  }

  export type TaskTemplateGroupByOutputType = {
    id: number
    borneId: number | null
    label: string
    description: string | null
    order: number | null
    estimatedMinutesPerUnit: number | null
    active: boolean
    _count: TaskTemplateCountAggregateOutputType | null
    _avg: TaskTemplateAvgAggregateOutputType | null
    _sum: TaskTemplateSumAggregateOutputType | null
    _min: TaskTemplateMinAggregateOutputType | null
    _max: TaskTemplateMaxAggregateOutputType | null
  }

  type GetTaskTemplateGroupByPayload<T extends TaskTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTemplateGroupByOutputType[P]>
        }
      >
    >


  export type TaskTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borneId?: boolean
    label?: boolean
    description?: boolean
    order?: boolean
    estimatedMinutesPerUnit?: boolean
    active?: boolean
    productionTasks?: boolean | TaskTemplate$productionTasksArgs<ExtArgs>
    borne?: boolean | TaskTemplate$borneArgs<ExtArgs>
    logs?: boolean | TaskTemplate$logsArgs<ExtArgs>
    pieces?: boolean | TaskTemplate$piecesArgs<ExtArgs>
    sousAssemblages?: boolean | TaskTemplate$sousAssemblagesArgs<ExtArgs>
    sousSousAssemblages?: boolean | TaskTemplate$sousSousAssemblagesArgs<ExtArgs>
    _count?: boolean | TaskTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplate"]>

  export type TaskTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borneId?: boolean
    label?: boolean
    description?: boolean
    order?: boolean
    estimatedMinutesPerUnit?: boolean
    active?: boolean
    borne?: boolean | TaskTemplate$borneArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplate"]>

  export type TaskTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borneId?: boolean
    label?: boolean
    description?: boolean
    order?: boolean
    estimatedMinutesPerUnit?: boolean
    active?: boolean
    borne?: boolean | TaskTemplate$borneArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplate"]>

  export type TaskTemplateSelectScalar = {
    id?: boolean
    borneId?: boolean
    label?: boolean
    description?: boolean
    order?: boolean
    estimatedMinutesPerUnit?: boolean
    active?: boolean
  }

  export type TaskTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "borneId" | "label" | "description" | "order" | "estimatedMinutesPerUnit" | "active", ExtArgs["result"]["taskTemplate"]>
  export type TaskTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTasks?: boolean | TaskTemplate$productionTasksArgs<ExtArgs>
    borne?: boolean | TaskTemplate$borneArgs<ExtArgs>
    logs?: boolean | TaskTemplate$logsArgs<ExtArgs>
    pieces?: boolean | TaskTemplate$piecesArgs<ExtArgs>
    sousAssemblages?: boolean | TaskTemplate$sousAssemblagesArgs<ExtArgs>
    sousSousAssemblages?: boolean | TaskTemplate$sousSousAssemblagesArgs<ExtArgs>
    _count?: boolean | TaskTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borne?: boolean | TaskTemplate$borneArgs<ExtArgs>
  }
  export type TaskTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borne?: boolean | TaskTemplate$borneArgs<ExtArgs>
  }

  export type $TaskTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTemplate"
    objects: {
      productionTasks: Prisma.$ProductionTaskPayload<ExtArgs>[]
      borne: Prisma.$BornePayload<ExtArgs> | null
      logs: Prisma.$TaskTemplateLogPayload<ExtArgs>[]
      pieces: Prisma.$TaskTemplatePiecePayload<ExtArgs>[]
      sousAssemblages: Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>[]
      sousSousAssemblages: Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      borneId: number | null
      label: string
      description: string | null
      order: number | null
      estimatedMinutesPerUnit: number | null
      active: boolean
    }, ExtArgs["result"]["taskTemplate"]>
    composites: {}
  }

  type TaskTemplateGetPayload<S extends boolean | null | undefined | TaskTemplateDefaultArgs> = $Result.GetResult<Prisma.$TaskTemplatePayload, S>

  type TaskTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTemplateCountAggregateInputType | true
    }

  export interface TaskTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTemplate'], meta: { name: 'TaskTemplate' } }
    /**
     * Find zero or one TaskTemplate that matches the filter.
     * @param {TaskTemplateFindUniqueArgs} args - Arguments to find a TaskTemplate
     * @example
     * // Get one TaskTemplate
     * const taskTemplate = await prisma.taskTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTemplateFindUniqueArgs>(args: SelectSubset<T, TaskTemplateFindUniqueArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTemplateFindUniqueOrThrowArgs} args - Arguments to find a TaskTemplate
     * @example
     * // Get one TaskTemplate
     * const taskTemplate = await prisma.taskTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateFindFirstArgs} args - Arguments to find a TaskTemplate
     * @example
     * // Get one TaskTemplate
     * const taskTemplate = await prisma.taskTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTemplateFindFirstArgs>(args?: SelectSubset<T, TaskTemplateFindFirstArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateFindFirstOrThrowArgs} args - Arguments to find a TaskTemplate
     * @example
     * // Get one TaskTemplate
     * const taskTemplate = await prisma.taskTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTemplates
     * const taskTemplates = await prisma.taskTemplate.findMany()
     * 
     * // Get first 10 TaskTemplates
     * const taskTemplates = await prisma.taskTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTemplateWithIdOnly = await prisma.taskTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTemplateFindManyArgs>(args?: SelectSubset<T, TaskTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTemplate.
     * @param {TaskTemplateCreateArgs} args - Arguments to create a TaskTemplate.
     * @example
     * // Create one TaskTemplate
     * const TaskTemplate = await prisma.taskTemplate.create({
     *   data: {
     *     // ... data to create a TaskTemplate
     *   }
     * })
     * 
     */
    create<T extends TaskTemplateCreateArgs>(args: SelectSubset<T, TaskTemplateCreateArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTemplates.
     * @param {TaskTemplateCreateManyArgs} args - Arguments to create many TaskTemplates.
     * @example
     * // Create many TaskTemplates
     * const taskTemplate = await prisma.taskTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTemplateCreateManyArgs>(args?: SelectSubset<T, TaskTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTemplates and returns the data saved in the database.
     * @param {TaskTemplateCreateManyAndReturnArgs} args - Arguments to create many TaskTemplates.
     * @example
     * // Create many TaskTemplates
     * const taskTemplate = await prisma.taskTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTemplates and only return the `id`
     * const taskTemplateWithIdOnly = await prisma.taskTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTemplate.
     * @param {TaskTemplateDeleteArgs} args - Arguments to delete one TaskTemplate.
     * @example
     * // Delete one TaskTemplate
     * const TaskTemplate = await prisma.taskTemplate.delete({
     *   where: {
     *     // ... filter to delete one TaskTemplate
     *   }
     * })
     * 
     */
    delete<T extends TaskTemplateDeleteArgs>(args: SelectSubset<T, TaskTemplateDeleteArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTemplate.
     * @param {TaskTemplateUpdateArgs} args - Arguments to update one TaskTemplate.
     * @example
     * // Update one TaskTemplate
     * const taskTemplate = await prisma.taskTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTemplateUpdateArgs>(args: SelectSubset<T, TaskTemplateUpdateArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTemplates.
     * @param {TaskTemplateDeleteManyArgs} args - Arguments to filter TaskTemplates to delete.
     * @example
     * // Delete a few TaskTemplates
     * const { count } = await prisma.taskTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTemplateDeleteManyArgs>(args?: SelectSubset<T, TaskTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTemplates
     * const taskTemplate = await prisma.taskTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTemplateUpdateManyArgs>(args: SelectSubset<T, TaskTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplates and returns the data updated in the database.
     * @param {TaskTemplateUpdateManyAndReturnArgs} args - Arguments to update many TaskTemplates.
     * @example
     * // Update many TaskTemplates
     * const taskTemplate = await prisma.taskTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTemplates and only return the `id`
     * const taskTemplateWithIdOnly = await prisma.taskTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTemplate.
     * @param {TaskTemplateUpsertArgs} args - Arguments to update or create a TaskTemplate.
     * @example
     * // Update or create a TaskTemplate
     * const taskTemplate = await prisma.taskTemplate.upsert({
     *   create: {
     *     // ... data to create a TaskTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTemplate we want to update
     *   }
     * })
     */
    upsert<T extends TaskTemplateUpsertArgs>(args: SelectSubset<T, TaskTemplateUpsertArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateCountArgs} args - Arguments to filter TaskTemplates to count.
     * @example
     * // Count the number of TaskTemplates
     * const count = await prisma.taskTemplate.count({
     *   where: {
     *     // ... the filter for the TaskTemplates we want to count
     *   }
     * })
    **/
    count<T extends TaskTemplateCountArgs>(
      args?: Subset<T, TaskTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTemplateAggregateArgs>(args: Subset<T, TaskTemplateAggregateArgs>): Prisma.PrismaPromise<GetTaskTemplateAggregateType<T>>

    /**
     * Group by TaskTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTemplateGroupByArgs['orderBy'] }
        : { orderBy?: TaskTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTemplate model
   */
  readonly fields: TaskTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionTasks<T extends TaskTemplate$productionTasksArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplate$productionTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    borne<T extends TaskTemplate$borneArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplate$borneArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logs<T extends TaskTemplate$logsArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplate$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pieces<T extends TaskTemplate$piecesArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplate$piecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousAssemblages<T extends TaskTemplate$sousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplate$sousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sousSousAssemblages<T extends TaskTemplate$sousSousAssemblagesArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplate$sousSousAssemblagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTemplate model
   */
  interface TaskTemplateFieldRefs {
    readonly id: FieldRef<"TaskTemplate", 'Int'>
    readonly borneId: FieldRef<"TaskTemplate", 'Int'>
    readonly label: FieldRef<"TaskTemplate", 'String'>
    readonly description: FieldRef<"TaskTemplate", 'String'>
    readonly order: FieldRef<"TaskTemplate", 'Int'>
    readonly estimatedMinutesPerUnit: FieldRef<"TaskTemplate", 'Int'>
    readonly active: FieldRef<"TaskTemplate", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TaskTemplate findUnique
   */
  export type TaskTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplate to fetch.
     */
    where: TaskTemplateWhereUniqueInput
  }

  /**
   * TaskTemplate findUniqueOrThrow
   */
  export type TaskTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplate to fetch.
     */
    where: TaskTemplateWhereUniqueInput
  }

  /**
   * TaskTemplate findFirst
   */
  export type TaskTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplate to fetch.
     */
    where?: TaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplates to fetch.
     */
    orderBy?: TaskTemplateOrderByWithRelationInput | TaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplates.
     */
    cursor?: TaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplates.
     */
    distinct?: TaskTemplateScalarFieldEnum | TaskTemplateScalarFieldEnum[]
  }

  /**
   * TaskTemplate findFirstOrThrow
   */
  export type TaskTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplate to fetch.
     */
    where?: TaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplates to fetch.
     */
    orderBy?: TaskTemplateOrderByWithRelationInput | TaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplates.
     */
    cursor?: TaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplates.
     */
    distinct?: TaskTemplateScalarFieldEnum | TaskTemplateScalarFieldEnum[]
  }

  /**
   * TaskTemplate findMany
   */
  export type TaskTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplates to fetch.
     */
    where?: TaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplates to fetch.
     */
    orderBy?: TaskTemplateOrderByWithRelationInput | TaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTemplates.
     */
    cursor?: TaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplates.
     */
    skip?: number
    distinct?: TaskTemplateScalarFieldEnum | TaskTemplateScalarFieldEnum[]
  }

  /**
   * TaskTemplate create
   */
  export type TaskTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTemplate.
     */
    data: XOR<TaskTemplateCreateInput, TaskTemplateUncheckedCreateInput>
  }

  /**
   * TaskTemplate createMany
   */
  export type TaskTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTemplates.
     */
    data: TaskTemplateCreateManyInput | TaskTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTemplate createManyAndReturn
   */
  export type TaskTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTemplates.
     */
    data: TaskTemplateCreateManyInput | TaskTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplate update
   */
  export type TaskTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTemplate.
     */
    data: XOR<TaskTemplateUpdateInput, TaskTemplateUncheckedUpdateInput>
    /**
     * Choose, which TaskTemplate to update.
     */
    where: TaskTemplateWhereUniqueInput
  }

  /**
   * TaskTemplate updateMany
   */
  export type TaskTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTemplates.
     */
    data: XOR<TaskTemplateUpdateManyMutationInput, TaskTemplateUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplates to update
     */
    where?: TaskTemplateWhereInput
    /**
     * Limit how many TaskTemplates to update.
     */
    limit?: number
  }

  /**
   * TaskTemplate updateManyAndReturn
   */
  export type TaskTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * The data used to update TaskTemplates.
     */
    data: XOR<TaskTemplateUpdateManyMutationInput, TaskTemplateUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplates to update
     */
    where?: TaskTemplateWhereInput
    /**
     * Limit how many TaskTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplate upsert
   */
  export type TaskTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTemplate to update in case it exists.
     */
    where: TaskTemplateWhereUniqueInput
    /**
     * In case the TaskTemplate found by the `where` argument doesn't exist, create a new TaskTemplate with this data.
     */
    create: XOR<TaskTemplateCreateInput, TaskTemplateUncheckedCreateInput>
    /**
     * In case the TaskTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTemplateUpdateInput, TaskTemplateUncheckedUpdateInput>
  }

  /**
   * TaskTemplate delete
   */
  export type TaskTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    /**
     * Filter which TaskTemplate to delete.
     */
    where: TaskTemplateWhereUniqueInput
  }

  /**
   * TaskTemplate deleteMany
   */
  export type TaskTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplates to delete
     */
    where?: TaskTemplateWhereInput
    /**
     * Limit how many TaskTemplates to delete.
     */
    limit?: number
  }

  /**
   * TaskTemplate.productionTasks
   */
  export type TaskTemplate$productionTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    where?: ProductionTaskWhereInput
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    cursor?: ProductionTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * TaskTemplate.borne
   */
  export type TaskTemplate$borneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borne
     */
    select?: BorneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borne
     */
    omit?: BorneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorneInclude<ExtArgs> | null
    where?: BorneWhereInput
  }

  /**
   * TaskTemplate.logs
   */
  export type TaskTemplate$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    where?: TaskTemplateLogWhereInput
    orderBy?: TaskTemplateLogOrderByWithRelationInput | TaskTemplateLogOrderByWithRelationInput[]
    cursor?: TaskTemplateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateLogScalarFieldEnum | TaskTemplateLogScalarFieldEnum[]
  }

  /**
   * TaskTemplate.pieces
   */
  export type TaskTemplate$piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    where?: TaskTemplatePieceWhereInput
    orderBy?: TaskTemplatePieceOrderByWithRelationInput | TaskTemplatePieceOrderByWithRelationInput[]
    cursor?: TaskTemplatePieceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplatePieceScalarFieldEnum | TaskTemplatePieceScalarFieldEnum[]
  }

  /**
   * TaskTemplate.sousAssemblages
   */
  export type TaskTemplate$sousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    where?: TaskTemplateSousAssemblageWhereInput
    orderBy?: TaskTemplateSousAssemblageOrderByWithRelationInput | TaskTemplateSousAssemblageOrderByWithRelationInput[]
    cursor?: TaskTemplateSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateSousAssemblageScalarFieldEnum | TaskTemplateSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplate.sousSousAssemblages
   */
  export type TaskTemplate$sousSousAssemblagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    where?: TaskTemplateSousSousAssemblageWhereInput
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithRelationInput | TaskTemplateSousSousAssemblageOrderByWithRelationInput[]
    cursor?: TaskTemplateSousSousAssemblageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTemplateSousSousAssemblageScalarFieldEnum | TaskTemplateSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplate without action
   */
  export type TaskTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Production
   */

  export type AggregateProduction = {
    _count: ProductionCountAggregateOutputType | null
    _avg: ProductionAvgAggregateOutputType | null
    _sum: ProductionSumAggregateOutputType | null
    _min: ProductionMinAggregateOutputType | null
    _max: ProductionMaxAggregateOutputType | null
  }

  export type ProductionAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductionSumAggregateOutputType = {
    id: number | null
  }

  export type ProductionMinAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    description: string | null
    status: $Enums.ProductionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: Date | null
  }

  export type ProductionMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    reference: string | null
    description: string | null
    status: $Enums.ProductionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: Date | null
  }

  export type ProductionCountAggregateOutputType = {
    id: number
    nom: number
    reference: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    dueDate: number
    _all: number
  }


  export type ProductionAvgAggregateInputType = {
    id?: true
  }

  export type ProductionSumAggregateInputType = {
    id?: true
  }

  export type ProductionMinAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
  }

  export type ProductionMaxAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
  }

  export type ProductionCountAggregateInputType = {
    id?: true
    nom?: true
    reference?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    _all?: true
  }

  export type ProductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Production to aggregate.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productions
    **/
    _count?: true | ProductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionMaxAggregateInputType
  }

  export type GetProductionAggregateType<T extends ProductionAggregateArgs> = {
        [P in keyof T & keyof AggregateProduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduction[P]>
      : GetScalarType<T[P], AggregateProduction[P]>
  }




  export type ProductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionWhereInput
    orderBy?: ProductionOrderByWithAggregationInput | ProductionOrderByWithAggregationInput[]
    by: ProductionScalarFieldEnum[] | ProductionScalarFieldEnum
    having?: ProductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionCountAggregateInputType | true
    _avg?: ProductionAvgAggregateInputType
    _sum?: ProductionSumAggregateInputType
    _min?: ProductionMinAggregateInputType
    _max?: ProductionMaxAggregateInputType
  }

  export type ProductionGroupByOutputType = {
    id: number
    nom: string
    reference: string | null
    description: string | null
    status: $Enums.ProductionStatus
    createdAt: Date
    updatedAt: Date
    dueDate: Date | null
    _count: ProductionCountAggregateOutputType | null
    _avg: ProductionAvgAggregateOutputType | null
    _sum: ProductionSumAggregateOutputType | null
    _min: ProductionMinAggregateOutputType | null
    _max: ProductionMaxAggregateOutputType | null
  }

  type GetProductionGroupByPayload<T extends ProductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionGroupByOutputType[P]>
        }
      >
    >


  export type ProductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    lines?: boolean | Production$linesArgs<ExtArgs>
    tasks?: boolean | Production$tasksArgs<ExtArgs>
    _count?: boolean | ProductionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["production"]>

  export type ProductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
  }, ExtArgs["result"]["production"]>

  export type ProductionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    reference?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
  }, ExtArgs["result"]["production"]>

  export type ProductionSelectScalar = {
    id?: boolean
    nom?: boolean
    reference?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
  }

  export type ProductionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "reference" | "description" | "status" | "createdAt" | "updatedAt" | "dueDate", ExtArgs["result"]["production"]>
  export type ProductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | Production$linesArgs<ExtArgs>
    tasks?: boolean | Production$tasksArgs<ExtArgs>
    _count?: boolean | ProductionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Production"
    objects: {
      lines: Prisma.$ProductionLinePayload<ExtArgs>[]
      tasks: Prisma.$ProductionTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      reference: string | null
      description: string | null
      status: $Enums.ProductionStatus
      createdAt: Date
      updatedAt: Date
      dueDate: Date | null
    }, ExtArgs["result"]["production"]>
    composites: {}
  }

  type ProductionGetPayload<S extends boolean | null | undefined | ProductionDefaultArgs> = $Result.GetResult<Prisma.$ProductionPayload, S>

  type ProductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionCountAggregateInputType | true
    }

  export interface ProductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Production'], meta: { name: 'Production' } }
    /**
     * Find zero or one Production that matches the filter.
     * @param {ProductionFindUniqueArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionFindUniqueArgs>(args: SelectSubset<T, ProductionFindUniqueArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Production that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionFindUniqueOrThrowArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Production that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionFindFirstArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionFindFirstArgs>(args?: SelectSubset<T, ProductionFindFirstArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Production that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionFindFirstOrThrowArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productions
     * const productions = await prisma.production.findMany()
     * 
     * // Get first 10 Productions
     * const productions = await prisma.production.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionWithIdOnly = await prisma.production.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionFindManyArgs>(args?: SelectSubset<T, ProductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Production.
     * @param {ProductionCreateArgs} args - Arguments to create a Production.
     * @example
     * // Create one Production
     * const Production = await prisma.production.create({
     *   data: {
     *     // ... data to create a Production
     *   }
     * })
     * 
     */
    create<T extends ProductionCreateArgs>(args: SelectSubset<T, ProductionCreateArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productions.
     * @param {ProductionCreateManyArgs} args - Arguments to create many Productions.
     * @example
     * // Create many Productions
     * const production = await prisma.production.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionCreateManyArgs>(args?: SelectSubset<T, ProductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productions and returns the data saved in the database.
     * @param {ProductionCreateManyAndReturnArgs} args - Arguments to create many Productions.
     * @example
     * // Create many Productions
     * const production = await prisma.production.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productions and only return the `id`
     * const productionWithIdOnly = await prisma.production.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Production.
     * @param {ProductionDeleteArgs} args - Arguments to delete one Production.
     * @example
     * // Delete one Production
     * const Production = await prisma.production.delete({
     *   where: {
     *     // ... filter to delete one Production
     *   }
     * })
     * 
     */
    delete<T extends ProductionDeleteArgs>(args: SelectSubset<T, ProductionDeleteArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Production.
     * @param {ProductionUpdateArgs} args - Arguments to update one Production.
     * @example
     * // Update one Production
     * const production = await prisma.production.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionUpdateArgs>(args: SelectSubset<T, ProductionUpdateArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productions.
     * @param {ProductionDeleteManyArgs} args - Arguments to filter Productions to delete.
     * @example
     * // Delete a few Productions
     * const { count } = await prisma.production.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionDeleteManyArgs>(args?: SelectSubset<T, ProductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productions
     * const production = await prisma.production.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionUpdateManyArgs>(args: SelectSubset<T, ProductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productions and returns the data updated in the database.
     * @param {ProductionUpdateManyAndReturnArgs} args - Arguments to update many Productions.
     * @example
     * // Update many Productions
     * const production = await prisma.production.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Productions and only return the `id`
     * const productionWithIdOnly = await prisma.production.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Production.
     * @param {ProductionUpsertArgs} args - Arguments to update or create a Production.
     * @example
     * // Update or create a Production
     * const production = await prisma.production.upsert({
     *   create: {
     *     // ... data to create a Production
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Production we want to update
     *   }
     * })
     */
    upsert<T extends ProductionUpsertArgs>(args: SelectSubset<T, ProductionUpsertArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCountArgs} args - Arguments to filter Productions to count.
     * @example
     * // Count the number of Productions
     * const count = await prisma.production.count({
     *   where: {
     *     // ... the filter for the Productions we want to count
     *   }
     * })
    **/
    count<T extends ProductionCountArgs>(
      args?: Subset<T, ProductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Production.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionAggregateArgs>(args: Subset<T, ProductionAggregateArgs>): Prisma.PrismaPromise<GetProductionAggregateType<T>>

    /**
     * Group by Production.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionGroupByArgs['orderBy'] }
        : { orderBy?: ProductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Production model
   */
  readonly fields: ProductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Production.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lines<T extends Production$linesArgs<ExtArgs> = {}>(args?: Subset<T, Production$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Production$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Production$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Production model
   */
  interface ProductionFieldRefs {
    readonly id: FieldRef<"Production", 'Int'>
    readonly nom: FieldRef<"Production", 'String'>
    readonly reference: FieldRef<"Production", 'String'>
    readonly description: FieldRef<"Production", 'String'>
    readonly status: FieldRef<"Production", 'ProductionStatus'>
    readonly createdAt: FieldRef<"Production", 'DateTime'>
    readonly updatedAt: FieldRef<"Production", 'DateTime'>
    readonly dueDate: FieldRef<"Production", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Production findUnique
   */
  export type ProductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production findUniqueOrThrow
   */
  export type ProductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production findFirst
   */
  export type ProductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productions.
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productions.
     */
    distinct?: ProductionScalarFieldEnum | ProductionScalarFieldEnum[]
  }

  /**
   * Production findFirstOrThrow
   */
  export type ProductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productions.
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productions.
     */
    distinct?: ProductionScalarFieldEnum | ProductionScalarFieldEnum[]
  }

  /**
   * Production findMany
   */
  export type ProductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Productions to fetch.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productions.
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    distinct?: ProductionScalarFieldEnum | ProductionScalarFieldEnum[]
  }

  /**
   * Production create
   */
  export type ProductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * The data needed to create a Production.
     */
    data: XOR<ProductionCreateInput, ProductionUncheckedCreateInput>
  }

  /**
   * Production createMany
   */
  export type ProductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productions.
     */
    data: ProductionCreateManyInput | ProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Production createManyAndReturn
   */
  export type ProductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * The data used to create many Productions.
     */
    data: ProductionCreateManyInput | ProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Production update
   */
  export type ProductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * The data needed to update a Production.
     */
    data: XOR<ProductionUpdateInput, ProductionUncheckedUpdateInput>
    /**
     * Choose, which Production to update.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production updateMany
   */
  export type ProductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productions.
     */
    data: XOR<ProductionUpdateManyMutationInput, ProductionUncheckedUpdateManyInput>
    /**
     * Filter which Productions to update
     */
    where?: ProductionWhereInput
    /**
     * Limit how many Productions to update.
     */
    limit?: number
  }

  /**
   * Production updateManyAndReturn
   */
  export type ProductionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * The data used to update Productions.
     */
    data: XOR<ProductionUpdateManyMutationInput, ProductionUncheckedUpdateManyInput>
    /**
     * Filter which Productions to update
     */
    where?: ProductionWhereInput
    /**
     * Limit how many Productions to update.
     */
    limit?: number
  }

  /**
   * Production upsert
   */
  export type ProductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * The filter to search for the Production to update in case it exists.
     */
    where: ProductionWhereUniqueInput
    /**
     * In case the Production found by the `where` argument doesn't exist, create a new Production with this data.
     */
    create: XOR<ProductionCreateInput, ProductionUncheckedCreateInput>
    /**
     * In case the Production was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionUpdateInput, ProductionUncheckedUpdateInput>
  }

  /**
   * Production delete
   */
  export type ProductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter which Production to delete.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production deleteMany
   */
  export type ProductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productions to delete
     */
    where?: ProductionWhereInput
    /**
     * Limit how many Productions to delete.
     */
    limit?: number
  }

  /**
   * Production.lines
   */
  export type Production$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    where?: ProductionLineWhereInput
    orderBy?: ProductionLineOrderByWithRelationInput | ProductionLineOrderByWithRelationInput[]
    cursor?: ProductionLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionLineScalarFieldEnum | ProductionLineScalarFieldEnum[]
  }

  /**
   * Production.tasks
   */
  export type Production$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    where?: ProductionTaskWhereInput
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    cursor?: ProductionTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * Production without action
   */
  export type ProductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
  }


  /**
   * Model ProductionLine
   */

  export type AggregateProductionLine = {
    _count: ProductionLineCountAggregateOutputType | null
    _avg: ProductionLineAvgAggregateOutputType | null
    _sum: ProductionLineSumAggregateOutputType | null
    _min: ProductionLineMinAggregateOutputType | null
    _max: ProductionLineMaxAggregateOutputType | null
  }

  export type ProductionLineAvgAggregateOutputType = {
    id: number | null
    productionId: number | null
    borneId: number | null
    quantity: number | null
  }

  export type ProductionLineSumAggregateOutputType = {
    id: number | null
    productionId: number | null
    borneId: number | null
    quantity: number | null
  }

  export type ProductionLineMinAggregateOutputType = {
    id: number | null
    productionId: number | null
    borneId: number | null
    quantity: number | null
  }

  export type ProductionLineMaxAggregateOutputType = {
    id: number | null
    productionId: number | null
    borneId: number | null
    quantity: number | null
  }

  export type ProductionLineCountAggregateOutputType = {
    id: number
    productionId: number
    borneId: number
    quantity: number
    _all: number
  }


  export type ProductionLineAvgAggregateInputType = {
    id?: true
    productionId?: true
    borneId?: true
    quantity?: true
  }

  export type ProductionLineSumAggregateInputType = {
    id?: true
    productionId?: true
    borneId?: true
    quantity?: true
  }

  export type ProductionLineMinAggregateInputType = {
    id?: true
    productionId?: true
    borneId?: true
    quantity?: true
  }

  export type ProductionLineMaxAggregateInputType = {
    id?: true
    productionId?: true
    borneId?: true
    quantity?: true
  }

  export type ProductionLineCountAggregateInputType = {
    id?: true
    productionId?: true
    borneId?: true
    quantity?: true
    _all?: true
  }

  export type ProductionLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionLine to aggregate.
     */
    where?: ProductionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionLines to fetch.
     */
    orderBy?: ProductionLineOrderByWithRelationInput | ProductionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionLines
    **/
    _count?: true | ProductionLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionLineMaxAggregateInputType
  }

  export type GetProductionLineAggregateType<T extends ProductionLineAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionLine[P]>
      : GetScalarType<T[P], AggregateProductionLine[P]>
  }




  export type ProductionLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionLineWhereInput
    orderBy?: ProductionLineOrderByWithAggregationInput | ProductionLineOrderByWithAggregationInput[]
    by: ProductionLineScalarFieldEnum[] | ProductionLineScalarFieldEnum
    having?: ProductionLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionLineCountAggregateInputType | true
    _avg?: ProductionLineAvgAggregateInputType
    _sum?: ProductionLineSumAggregateInputType
    _min?: ProductionLineMinAggregateInputType
    _max?: ProductionLineMaxAggregateInputType
  }

  export type ProductionLineGroupByOutputType = {
    id: number
    productionId: number
    borneId: number
    quantity: number
    _count: ProductionLineCountAggregateOutputType | null
    _avg: ProductionLineAvgAggregateOutputType | null
    _sum: ProductionLineSumAggregateOutputType | null
    _min: ProductionLineMinAggregateOutputType | null
    _max: ProductionLineMaxAggregateOutputType | null
  }

  type GetProductionLineGroupByPayload<T extends ProductionLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionLineGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionLineGroupByOutputType[P]>
        }
      >
    >


  export type ProductionLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    borneId?: boolean
    quantity?: boolean
    borne?: boolean | BorneDefaultArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionLine"]>

  export type ProductionLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    borneId?: boolean
    quantity?: boolean
    borne?: boolean | BorneDefaultArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionLine"]>

  export type ProductionLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    borneId?: boolean
    quantity?: boolean
    borne?: boolean | BorneDefaultArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionLine"]>

  export type ProductionLineSelectScalar = {
    id?: boolean
    productionId?: boolean
    borneId?: boolean
    quantity?: boolean
  }

  export type ProductionLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionId" | "borneId" | "quantity", ExtArgs["result"]["productionLine"]>
  export type ProductionLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borne?: boolean | BorneDefaultArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
  }
  export type ProductionLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borne?: boolean | BorneDefaultArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
  }
  export type ProductionLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borne?: boolean | BorneDefaultArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
  }

  export type $ProductionLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionLine"
    objects: {
      borne: Prisma.$BornePayload<ExtArgs>
      production: Prisma.$ProductionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionId: number
      borneId: number
      quantity: number
    }, ExtArgs["result"]["productionLine"]>
    composites: {}
  }

  type ProductionLineGetPayload<S extends boolean | null | undefined | ProductionLineDefaultArgs> = $Result.GetResult<Prisma.$ProductionLinePayload, S>

  type ProductionLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionLineCountAggregateInputType | true
    }

  export interface ProductionLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionLine'], meta: { name: 'ProductionLine' } }
    /**
     * Find zero or one ProductionLine that matches the filter.
     * @param {ProductionLineFindUniqueArgs} args - Arguments to find a ProductionLine
     * @example
     * // Get one ProductionLine
     * const productionLine = await prisma.productionLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionLineFindUniqueArgs>(args: SelectSubset<T, ProductionLineFindUniqueArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionLineFindUniqueOrThrowArgs} args - Arguments to find a ProductionLine
     * @example
     * // Get one ProductionLine
     * const productionLine = await prisma.productionLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionLineFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineFindFirstArgs} args - Arguments to find a ProductionLine
     * @example
     * // Get one ProductionLine
     * const productionLine = await prisma.productionLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionLineFindFirstArgs>(args?: SelectSubset<T, ProductionLineFindFirstArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineFindFirstOrThrowArgs} args - Arguments to find a ProductionLine
     * @example
     * // Get one ProductionLine
     * const productionLine = await prisma.productionLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionLineFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionLines
     * const productionLines = await prisma.productionLine.findMany()
     * 
     * // Get first 10 ProductionLines
     * const productionLines = await prisma.productionLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionLineWithIdOnly = await prisma.productionLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionLineFindManyArgs>(args?: SelectSubset<T, ProductionLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionLine.
     * @param {ProductionLineCreateArgs} args - Arguments to create a ProductionLine.
     * @example
     * // Create one ProductionLine
     * const ProductionLine = await prisma.productionLine.create({
     *   data: {
     *     // ... data to create a ProductionLine
     *   }
     * })
     * 
     */
    create<T extends ProductionLineCreateArgs>(args: SelectSubset<T, ProductionLineCreateArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionLines.
     * @param {ProductionLineCreateManyArgs} args - Arguments to create many ProductionLines.
     * @example
     * // Create many ProductionLines
     * const productionLine = await prisma.productionLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionLineCreateManyArgs>(args?: SelectSubset<T, ProductionLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionLines and returns the data saved in the database.
     * @param {ProductionLineCreateManyAndReturnArgs} args - Arguments to create many ProductionLines.
     * @example
     * // Create many ProductionLines
     * const productionLine = await prisma.productionLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionLines and only return the `id`
     * const productionLineWithIdOnly = await prisma.productionLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionLineCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionLine.
     * @param {ProductionLineDeleteArgs} args - Arguments to delete one ProductionLine.
     * @example
     * // Delete one ProductionLine
     * const ProductionLine = await prisma.productionLine.delete({
     *   where: {
     *     // ... filter to delete one ProductionLine
     *   }
     * })
     * 
     */
    delete<T extends ProductionLineDeleteArgs>(args: SelectSubset<T, ProductionLineDeleteArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionLine.
     * @param {ProductionLineUpdateArgs} args - Arguments to update one ProductionLine.
     * @example
     * // Update one ProductionLine
     * const productionLine = await prisma.productionLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionLineUpdateArgs>(args: SelectSubset<T, ProductionLineUpdateArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionLines.
     * @param {ProductionLineDeleteManyArgs} args - Arguments to filter ProductionLines to delete.
     * @example
     * // Delete a few ProductionLines
     * const { count } = await prisma.productionLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionLineDeleteManyArgs>(args?: SelectSubset<T, ProductionLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionLines
     * const productionLine = await prisma.productionLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionLineUpdateManyArgs>(args: SelectSubset<T, ProductionLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionLines and returns the data updated in the database.
     * @param {ProductionLineUpdateManyAndReturnArgs} args - Arguments to update many ProductionLines.
     * @example
     * // Update many ProductionLines
     * const productionLine = await prisma.productionLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionLines and only return the `id`
     * const productionLineWithIdOnly = await prisma.productionLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionLineUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionLine.
     * @param {ProductionLineUpsertArgs} args - Arguments to update or create a ProductionLine.
     * @example
     * // Update or create a ProductionLine
     * const productionLine = await prisma.productionLine.upsert({
     *   create: {
     *     // ... data to create a ProductionLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionLine we want to update
     *   }
     * })
     */
    upsert<T extends ProductionLineUpsertArgs>(args: SelectSubset<T, ProductionLineUpsertArgs<ExtArgs>>): Prisma__ProductionLineClient<$Result.GetResult<Prisma.$ProductionLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineCountArgs} args - Arguments to filter ProductionLines to count.
     * @example
     * // Count the number of ProductionLines
     * const count = await prisma.productionLine.count({
     *   where: {
     *     // ... the filter for the ProductionLines we want to count
     *   }
     * })
    **/
    count<T extends ProductionLineCountArgs>(
      args?: Subset<T, ProductionLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionLineAggregateArgs>(args: Subset<T, ProductionLineAggregateArgs>): Prisma.PrismaPromise<GetProductionLineAggregateType<T>>

    /**
     * Group by ProductionLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionLineGroupByArgs['orderBy'] }
        : { orderBy?: ProductionLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionLine model
   */
  readonly fields: ProductionLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    borne<T extends BorneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BorneDefaultArgs<ExtArgs>>): Prisma__BorneClient<$Result.GetResult<Prisma.$BornePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    production<T extends ProductionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDefaultArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionLine model
   */
  interface ProductionLineFieldRefs {
    readonly id: FieldRef<"ProductionLine", 'Int'>
    readonly productionId: FieldRef<"ProductionLine", 'Int'>
    readonly borneId: FieldRef<"ProductionLine", 'Int'>
    readonly quantity: FieldRef<"ProductionLine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductionLine findUnique
   */
  export type ProductionLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionLine to fetch.
     */
    where: ProductionLineWhereUniqueInput
  }

  /**
   * ProductionLine findUniqueOrThrow
   */
  export type ProductionLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionLine to fetch.
     */
    where: ProductionLineWhereUniqueInput
  }

  /**
   * ProductionLine findFirst
   */
  export type ProductionLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionLine to fetch.
     */
    where?: ProductionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionLines to fetch.
     */
    orderBy?: ProductionLineOrderByWithRelationInput | ProductionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionLines.
     */
    cursor?: ProductionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionLines.
     */
    distinct?: ProductionLineScalarFieldEnum | ProductionLineScalarFieldEnum[]
  }

  /**
   * ProductionLine findFirstOrThrow
   */
  export type ProductionLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionLine to fetch.
     */
    where?: ProductionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionLines to fetch.
     */
    orderBy?: ProductionLineOrderByWithRelationInput | ProductionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionLines.
     */
    cursor?: ProductionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionLines.
     */
    distinct?: ProductionLineScalarFieldEnum | ProductionLineScalarFieldEnum[]
  }

  /**
   * ProductionLine findMany
   */
  export type ProductionLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductionLines to fetch.
     */
    where?: ProductionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionLines to fetch.
     */
    orderBy?: ProductionLineOrderByWithRelationInput | ProductionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionLines.
     */
    cursor?: ProductionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionLines.
     */
    skip?: number
    distinct?: ProductionLineScalarFieldEnum | ProductionLineScalarFieldEnum[]
  }

  /**
   * ProductionLine create
   */
  export type ProductionLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionLine.
     */
    data: XOR<ProductionLineCreateInput, ProductionLineUncheckedCreateInput>
  }

  /**
   * ProductionLine createMany
   */
  export type ProductionLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionLines.
     */
    data: ProductionLineCreateManyInput | ProductionLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionLine createManyAndReturn
   */
  export type ProductionLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionLines.
     */
    data: ProductionLineCreateManyInput | ProductionLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionLine update
   */
  export type ProductionLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionLine.
     */
    data: XOR<ProductionLineUpdateInput, ProductionLineUncheckedUpdateInput>
    /**
     * Choose, which ProductionLine to update.
     */
    where: ProductionLineWhereUniqueInput
  }

  /**
   * ProductionLine updateMany
   */
  export type ProductionLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionLines.
     */
    data: XOR<ProductionLineUpdateManyMutationInput, ProductionLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductionLines to update
     */
    where?: ProductionLineWhereInput
    /**
     * Limit how many ProductionLines to update.
     */
    limit?: number
  }

  /**
   * ProductionLine updateManyAndReturn
   */
  export type ProductionLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * The data used to update ProductionLines.
     */
    data: XOR<ProductionLineUpdateManyMutationInput, ProductionLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductionLines to update
     */
    where?: ProductionLineWhereInput
    /**
     * Limit how many ProductionLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionLine upsert
   */
  export type ProductionLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionLine to update in case it exists.
     */
    where: ProductionLineWhereUniqueInput
    /**
     * In case the ProductionLine found by the `where` argument doesn't exist, create a new ProductionLine with this data.
     */
    create: XOR<ProductionLineCreateInput, ProductionLineUncheckedCreateInput>
    /**
     * In case the ProductionLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionLineUpdateInput, ProductionLineUncheckedUpdateInput>
  }

  /**
   * ProductionLine delete
   */
  export type ProductionLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
    /**
     * Filter which ProductionLine to delete.
     */
    where: ProductionLineWhereUniqueInput
  }

  /**
   * ProductionLine deleteMany
   */
  export type ProductionLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionLines to delete
     */
    where?: ProductionLineWhereInput
    /**
     * Limit how many ProductionLines to delete.
     */
    limit?: number
  }

  /**
   * ProductionLine without action
   */
  export type ProductionLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionLine
     */
    select?: ProductionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionLine
     */
    omit?: ProductionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionLineInclude<ExtArgs> | null
  }


  /**
   * Model ProductionTask
   */

  export type AggregateProductionTask = {
    _count: ProductionTaskCountAggregateOutputType | null
    _avg: ProductionTaskAvgAggregateOutputType | null
    _sum: ProductionTaskSumAggregateOutputType | null
    _min: ProductionTaskMinAggregateOutputType | null
    _max: ProductionTaskMaxAggregateOutputType | null
  }

  export type ProductionTaskAvgAggregateOutputType = {
    id: number | null
    productionId: number | null
    taskTemplateId: number | null
    totalSeconds: number | null
    assignedToId: number | null
  }

  export type ProductionTaskSumAggregateOutputType = {
    id: number | null
    productionId: number | null
    taskTemplateId: number | null
    totalSeconds: number | null
    assignedToId: number | null
  }

  export type ProductionTaskMinAggregateOutputType = {
    id: number | null
    productionId: number | null
    taskTemplateId: number | null
    label: string | null
    description: string | null
    isDone: boolean | null
    totalSeconds: number | null
    running: boolean | null
    lastStartedAt: Date | null
    assignedToId: number | null
  }

  export type ProductionTaskMaxAggregateOutputType = {
    id: number | null
    productionId: number | null
    taskTemplateId: number | null
    label: string | null
    description: string | null
    isDone: boolean | null
    totalSeconds: number | null
    running: boolean | null
    lastStartedAt: Date | null
    assignedToId: number | null
  }

  export type ProductionTaskCountAggregateOutputType = {
    id: number
    productionId: number
    taskTemplateId: number
    label: number
    description: number
    isDone: number
    totalSeconds: number
    running: number
    lastStartedAt: number
    assignedToId: number
    _all: number
  }


  export type ProductionTaskAvgAggregateInputType = {
    id?: true
    productionId?: true
    taskTemplateId?: true
    totalSeconds?: true
    assignedToId?: true
  }

  export type ProductionTaskSumAggregateInputType = {
    id?: true
    productionId?: true
    taskTemplateId?: true
    totalSeconds?: true
    assignedToId?: true
  }

  export type ProductionTaskMinAggregateInputType = {
    id?: true
    productionId?: true
    taskTemplateId?: true
    label?: true
    description?: true
    isDone?: true
    totalSeconds?: true
    running?: true
    lastStartedAt?: true
    assignedToId?: true
  }

  export type ProductionTaskMaxAggregateInputType = {
    id?: true
    productionId?: true
    taskTemplateId?: true
    label?: true
    description?: true
    isDone?: true
    totalSeconds?: true
    running?: true
    lastStartedAt?: true
    assignedToId?: true
  }

  export type ProductionTaskCountAggregateInputType = {
    id?: true
    productionId?: true
    taskTemplateId?: true
    label?: true
    description?: true
    isDone?: true
    totalSeconds?: true
    running?: true
    lastStartedAt?: true
    assignedToId?: true
    _all?: true
  }

  export type ProductionTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionTask to aggregate.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionTasks
    **/
    _count?: true | ProductionTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionTaskMaxAggregateInputType
  }

  export type GetProductionTaskAggregateType<T extends ProductionTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionTask[P]>
      : GetScalarType<T[P], AggregateProductionTask[P]>
  }




  export type ProductionTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskWhereInput
    orderBy?: ProductionTaskOrderByWithAggregationInput | ProductionTaskOrderByWithAggregationInput[]
    by: ProductionTaskScalarFieldEnum[] | ProductionTaskScalarFieldEnum
    having?: ProductionTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionTaskCountAggregateInputType | true
    _avg?: ProductionTaskAvgAggregateInputType
    _sum?: ProductionTaskSumAggregateInputType
    _min?: ProductionTaskMinAggregateInputType
    _max?: ProductionTaskMaxAggregateInputType
  }

  export type ProductionTaskGroupByOutputType = {
    id: number
    productionId: number
    taskTemplateId: number | null
    label: string
    description: string | null
    isDone: boolean
    totalSeconds: number
    running: boolean
    lastStartedAt: Date | null
    assignedToId: number | null
    _count: ProductionTaskCountAggregateOutputType | null
    _avg: ProductionTaskAvgAggregateOutputType | null
    _sum: ProductionTaskSumAggregateOutputType | null
    _min: ProductionTaskMinAggregateOutputType | null
    _max: ProductionTaskMaxAggregateOutputType | null
  }

  type GetProductionTaskGroupByPayload<T extends ProductionTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionTaskGroupByOutputType[P]>
        }
      >
    >


  export type ProductionTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    taskTemplateId?: boolean
    label?: boolean
    description?: boolean
    isDone?: boolean
    totalSeconds?: boolean
    running?: boolean
    lastStartedAt?: boolean
    assignedToId?: boolean
    assignedTo?: boolean | ProductionTask$assignedToArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
    template?: boolean | ProductionTask$templateArgs<ExtArgs>
    logs?: boolean | ProductionTask$logsArgs<ExtArgs>
    _count?: boolean | ProductionTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionTask"]>

  export type ProductionTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    taskTemplateId?: boolean
    label?: boolean
    description?: boolean
    isDone?: boolean
    totalSeconds?: boolean
    running?: boolean
    lastStartedAt?: boolean
    assignedToId?: boolean
    assignedTo?: boolean | ProductionTask$assignedToArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
    template?: boolean | ProductionTask$templateArgs<ExtArgs>
  }, ExtArgs["result"]["productionTask"]>

  export type ProductionTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    taskTemplateId?: boolean
    label?: boolean
    description?: boolean
    isDone?: boolean
    totalSeconds?: boolean
    running?: boolean
    lastStartedAt?: boolean
    assignedToId?: boolean
    assignedTo?: boolean | ProductionTask$assignedToArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
    template?: boolean | ProductionTask$templateArgs<ExtArgs>
  }, ExtArgs["result"]["productionTask"]>

  export type ProductionTaskSelectScalar = {
    id?: boolean
    productionId?: boolean
    taskTemplateId?: boolean
    label?: boolean
    description?: boolean
    isDone?: boolean
    totalSeconds?: boolean
    running?: boolean
    lastStartedAt?: boolean
    assignedToId?: boolean
  }

  export type ProductionTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionId" | "taskTemplateId" | "label" | "description" | "isDone" | "totalSeconds" | "running" | "lastStartedAt" | "assignedToId", ExtArgs["result"]["productionTask"]>
  export type ProductionTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ProductionTask$assignedToArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
    template?: boolean | ProductionTask$templateArgs<ExtArgs>
    logs?: boolean | ProductionTask$logsArgs<ExtArgs>
    _count?: boolean | ProductionTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ProductionTask$assignedToArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
    template?: boolean | ProductionTask$templateArgs<ExtArgs>
  }
  export type ProductionTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ProductionTask$assignedToArgs<ExtArgs>
    production?: boolean | ProductionDefaultArgs<ExtArgs>
    template?: boolean | ProductionTask$templateArgs<ExtArgs>
  }

  export type $ProductionTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionTask"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      production: Prisma.$ProductionPayload<ExtArgs>
      template: Prisma.$TaskTemplatePayload<ExtArgs> | null
      logs: Prisma.$ProductionTaskLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionId: number
      taskTemplateId: number | null
      label: string
      description: string | null
      isDone: boolean
      totalSeconds: number
      running: boolean
      lastStartedAt: Date | null
      assignedToId: number | null
    }, ExtArgs["result"]["productionTask"]>
    composites: {}
  }

  type ProductionTaskGetPayload<S extends boolean | null | undefined | ProductionTaskDefaultArgs> = $Result.GetResult<Prisma.$ProductionTaskPayload, S>

  type ProductionTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionTaskCountAggregateInputType | true
    }

  export interface ProductionTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionTask'], meta: { name: 'ProductionTask' } }
    /**
     * Find zero or one ProductionTask that matches the filter.
     * @param {ProductionTaskFindUniqueArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionTaskFindUniqueArgs>(args: SelectSubset<T, ProductionTaskFindUniqueArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionTaskFindUniqueOrThrowArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskFindFirstArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionTaskFindFirstArgs>(args?: SelectSubset<T, ProductionTaskFindFirstArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskFindFirstOrThrowArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionTasks
     * const productionTasks = await prisma.productionTask.findMany()
     * 
     * // Get first 10 ProductionTasks
     * const productionTasks = await prisma.productionTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionTaskWithIdOnly = await prisma.productionTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionTaskFindManyArgs>(args?: SelectSubset<T, ProductionTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionTask.
     * @param {ProductionTaskCreateArgs} args - Arguments to create a ProductionTask.
     * @example
     * // Create one ProductionTask
     * const ProductionTask = await prisma.productionTask.create({
     *   data: {
     *     // ... data to create a ProductionTask
     *   }
     * })
     * 
     */
    create<T extends ProductionTaskCreateArgs>(args: SelectSubset<T, ProductionTaskCreateArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionTasks.
     * @param {ProductionTaskCreateManyArgs} args - Arguments to create many ProductionTasks.
     * @example
     * // Create many ProductionTasks
     * const productionTask = await prisma.productionTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionTaskCreateManyArgs>(args?: SelectSubset<T, ProductionTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionTasks and returns the data saved in the database.
     * @param {ProductionTaskCreateManyAndReturnArgs} args - Arguments to create many ProductionTasks.
     * @example
     * // Create many ProductionTasks
     * const productionTask = await prisma.productionTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionTasks and only return the `id`
     * const productionTaskWithIdOnly = await prisma.productionTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionTask.
     * @param {ProductionTaskDeleteArgs} args - Arguments to delete one ProductionTask.
     * @example
     * // Delete one ProductionTask
     * const ProductionTask = await prisma.productionTask.delete({
     *   where: {
     *     // ... filter to delete one ProductionTask
     *   }
     * })
     * 
     */
    delete<T extends ProductionTaskDeleteArgs>(args: SelectSubset<T, ProductionTaskDeleteArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionTask.
     * @param {ProductionTaskUpdateArgs} args - Arguments to update one ProductionTask.
     * @example
     * // Update one ProductionTask
     * const productionTask = await prisma.productionTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionTaskUpdateArgs>(args: SelectSubset<T, ProductionTaskUpdateArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionTasks.
     * @param {ProductionTaskDeleteManyArgs} args - Arguments to filter ProductionTasks to delete.
     * @example
     * // Delete a few ProductionTasks
     * const { count } = await prisma.productionTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionTaskDeleteManyArgs>(args?: SelectSubset<T, ProductionTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionTasks
     * const productionTask = await prisma.productionTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionTaskUpdateManyArgs>(args: SelectSubset<T, ProductionTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionTasks and returns the data updated in the database.
     * @param {ProductionTaskUpdateManyAndReturnArgs} args - Arguments to update many ProductionTasks.
     * @example
     * // Update many ProductionTasks
     * const productionTask = await prisma.productionTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionTasks and only return the `id`
     * const productionTaskWithIdOnly = await prisma.productionTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionTask.
     * @param {ProductionTaskUpsertArgs} args - Arguments to update or create a ProductionTask.
     * @example
     * // Update or create a ProductionTask
     * const productionTask = await prisma.productionTask.upsert({
     *   create: {
     *     // ... data to create a ProductionTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionTask we want to update
     *   }
     * })
     */
    upsert<T extends ProductionTaskUpsertArgs>(args: SelectSubset<T, ProductionTaskUpsertArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskCountArgs} args - Arguments to filter ProductionTasks to count.
     * @example
     * // Count the number of ProductionTasks
     * const count = await prisma.productionTask.count({
     *   where: {
     *     // ... the filter for the ProductionTasks we want to count
     *   }
     * })
    **/
    count<T extends ProductionTaskCountArgs>(
      args?: Subset<T, ProductionTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionTaskAggregateArgs>(args: Subset<T, ProductionTaskAggregateArgs>): Prisma.PrismaPromise<GetProductionTaskAggregateType<T>>

    /**
     * Group by ProductionTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionTaskGroupByArgs['orderBy'] }
        : { orderBy?: ProductionTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionTask model
   */
  readonly fields: ProductionTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends ProductionTask$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTask$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    production<T extends ProductionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDefaultArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends ProductionTask$templateArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTask$templateArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logs<T extends ProductionTask$logsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTask$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionTask model
   */
  interface ProductionTaskFieldRefs {
    readonly id: FieldRef<"ProductionTask", 'Int'>
    readonly productionId: FieldRef<"ProductionTask", 'Int'>
    readonly taskTemplateId: FieldRef<"ProductionTask", 'Int'>
    readonly label: FieldRef<"ProductionTask", 'String'>
    readonly description: FieldRef<"ProductionTask", 'String'>
    readonly isDone: FieldRef<"ProductionTask", 'Boolean'>
    readonly totalSeconds: FieldRef<"ProductionTask", 'Int'>
    readonly running: FieldRef<"ProductionTask", 'Boolean'>
    readonly lastStartedAt: FieldRef<"ProductionTask", 'DateTime'>
    readonly assignedToId: FieldRef<"ProductionTask", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductionTask findUnique
   */
  export type ProductionTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask findUniqueOrThrow
   */
  export type ProductionTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask findFirst
   */
  export type ProductionTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionTasks.
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionTasks.
     */
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * ProductionTask findFirstOrThrow
   */
  export type ProductionTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionTasks.
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionTasks.
     */
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * ProductionTask findMany
   */
  export type ProductionTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTasks to fetch.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionTasks.
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * ProductionTask create
   */
  export type ProductionTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionTask.
     */
    data: XOR<ProductionTaskCreateInput, ProductionTaskUncheckedCreateInput>
  }

  /**
   * ProductionTask createMany
   */
  export type ProductionTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionTasks.
     */
    data: ProductionTaskCreateManyInput | ProductionTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionTask createManyAndReturn
   */
  export type ProductionTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionTasks.
     */
    data: ProductionTaskCreateManyInput | ProductionTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionTask update
   */
  export type ProductionTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionTask.
     */
    data: XOR<ProductionTaskUpdateInput, ProductionTaskUncheckedUpdateInput>
    /**
     * Choose, which ProductionTask to update.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask updateMany
   */
  export type ProductionTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionTasks.
     */
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyInput>
    /**
     * Filter which ProductionTasks to update
     */
    where?: ProductionTaskWhereInput
    /**
     * Limit how many ProductionTasks to update.
     */
    limit?: number
  }

  /**
   * ProductionTask updateManyAndReturn
   */
  export type ProductionTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * The data used to update ProductionTasks.
     */
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyInput>
    /**
     * Filter which ProductionTasks to update
     */
    where?: ProductionTaskWhereInput
    /**
     * Limit how many ProductionTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionTask upsert
   */
  export type ProductionTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionTask to update in case it exists.
     */
    where: ProductionTaskWhereUniqueInput
    /**
     * In case the ProductionTask found by the `where` argument doesn't exist, create a new ProductionTask with this data.
     */
    create: XOR<ProductionTaskCreateInput, ProductionTaskUncheckedCreateInput>
    /**
     * In case the ProductionTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionTaskUpdateInput, ProductionTaskUncheckedUpdateInput>
  }

  /**
   * ProductionTask delete
   */
  export type ProductionTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter which ProductionTask to delete.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask deleteMany
   */
  export type ProductionTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionTasks to delete
     */
    where?: ProductionTaskWhereInput
    /**
     * Limit how many ProductionTasks to delete.
     */
    limit?: number
  }

  /**
   * ProductionTask.assignedTo
   */
  export type ProductionTask$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductionTask.template
   */
  export type ProductionTask$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplate
     */
    select?: TaskTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplate
     */
    omit?: TaskTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateInclude<ExtArgs> | null
    where?: TaskTemplateWhereInput
  }

  /**
   * ProductionTask.logs
   */
  export type ProductionTask$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    where?: ProductionTaskLogWhereInput
    orderBy?: ProductionTaskLogOrderByWithRelationInput | ProductionTaskLogOrderByWithRelationInput[]
    cursor?: ProductionTaskLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionTaskLogScalarFieldEnum | ProductionTaskLogScalarFieldEnum[]
  }

  /**
   * ProductionTask without action
   */
  export type ProductionTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTask
     */
    omit?: ProductionTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
  }


  /**
   * Model ProductionTaskLog
   */

  export type AggregateProductionTaskLog = {
    _count: ProductionTaskLogCountAggregateOutputType | null
    _avg: ProductionTaskLogAvgAggregateOutputType | null
    _sum: ProductionTaskLogSumAggregateOutputType | null
    _min: ProductionTaskLogMinAggregateOutputType | null
    _max: ProductionTaskLogMaxAggregateOutputType | null
  }

  export type ProductionTaskLogAvgAggregateOutputType = {
    id: number | null
    productionTaskId: number | null
    userId: number | null
  }

  export type ProductionTaskLogSumAggregateOutputType = {
    id: number | null
    productionTaskId: number | null
    userId: number | null
  }

  export type ProductionTaskLogMinAggregateOutputType = {
    id: number | null
    productionTaskId: number | null
    userId: number | null
    eventType: $Enums.TaskEventType | null
    createdAt: Date | null
    note: string | null
  }

  export type ProductionTaskLogMaxAggregateOutputType = {
    id: number | null
    productionTaskId: number | null
    userId: number | null
    eventType: $Enums.TaskEventType | null
    createdAt: Date | null
    note: string | null
  }

  export type ProductionTaskLogCountAggregateOutputType = {
    id: number
    productionTaskId: number
    userId: number
    eventType: number
    createdAt: number
    note: number
    _all: number
  }


  export type ProductionTaskLogAvgAggregateInputType = {
    id?: true
    productionTaskId?: true
    userId?: true
  }

  export type ProductionTaskLogSumAggregateInputType = {
    id?: true
    productionTaskId?: true
    userId?: true
  }

  export type ProductionTaskLogMinAggregateInputType = {
    id?: true
    productionTaskId?: true
    userId?: true
    eventType?: true
    createdAt?: true
    note?: true
  }

  export type ProductionTaskLogMaxAggregateInputType = {
    id?: true
    productionTaskId?: true
    userId?: true
    eventType?: true
    createdAt?: true
    note?: true
  }

  export type ProductionTaskLogCountAggregateInputType = {
    id?: true
    productionTaskId?: true
    userId?: true
    eventType?: true
    createdAt?: true
    note?: true
    _all?: true
  }

  export type ProductionTaskLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionTaskLog to aggregate.
     */
    where?: ProductionTaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTaskLogs to fetch.
     */
    orderBy?: ProductionTaskLogOrderByWithRelationInput | ProductionTaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionTaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionTaskLogs
    **/
    _count?: true | ProductionTaskLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionTaskLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionTaskLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionTaskLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionTaskLogMaxAggregateInputType
  }

  export type GetProductionTaskLogAggregateType<T extends ProductionTaskLogAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionTaskLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionTaskLog[P]>
      : GetScalarType<T[P], AggregateProductionTaskLog[P]>
  }




  export type ProductionTaskLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskLogWhereInput
    orderBy?: ProductionTaskLogOrderByWithAggregationInput | ProductionTaskLogOrderByWithAggregationInput[]
    by: ProductionTaskLogScalarFieldEnum[] | ProductionTaskLogScalarFieldEnum
    having?: ProductionTaskLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionTaskLogCountAggregateInputType | true
    _avg?: ProductionTaskLogAvgAggregateInputType
    _sum?: ProductionTaskLogSumAggregateInputType
    _min?: ProductionTaskLogMinAggregateInputType
    _max?: ProductionTaskLogMaxAggregateInputType
  }

  export type ProductionTaskLogGroupByOutputType = {
    id: number
    productionTaskId: number
    userId: number | null
    eventType: $Enums.TaskEventType
    createdAt: Date
    note: string | null
    _count: ProductionTaskLogCountAggregateOutputType | null
    _avg: ProductionTaskLogAvgAggregateOutputType | null
    _sum: ProductionTaskLogSumAggregateOutputType | null
    _min: ProductionTaskLogMinAggregateOutputType | null
    _max: ProductionTaskLogMaxAggregateOutputType | null
  }

  type GetProductionTaskLogGroupByPayload<T extends ProductionTaskLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionTaskLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionTaskLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionTaskLogGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionTaskLogGroupByOutputType[P]>
        }
      >
    >


  export type ProductionTaskLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionTaskId?: boolean
    userId?: boolean
    eventType?: boolean
    createdAt?: boolean
    note?: boolean
    productionTask?: boolean | ProductionTaskDefaultArgs<ExtArgs>
    user?: boolean | ProductionTaskLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["productionTaskLog"]>

  export type ProductionTaskLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionTaskId?: boolean
    userId?: boolean
    eventType?: boolean
    createdAt?: boolean
    note?: boolean
    productionTask?: boolean | ProductionTaskDefaultArgs<ExtArgs>
    user?: boolean | ProductionTaskLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["productionTaskLog"]>

  export type ProductionTaskLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionTaskId?: boolean
    userId?: boolean
    eventType?: boolean
    createdAt?: boolean
    note?: boolean
    productionTask?: boolean | ProductionTaskDefaultArgs<ExtArgs>
    user?: boolean | ProductionTaskLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["productionTaskLog"]>

  export type ProductionTaskLogSelectScalar = {
    id?: boolean
    productionTaskId?: boolean
    userId?: boolean
    eventType?: boolean
    createdAt?: boolean
    note?: boolean
  }

  export type ProductionTaskLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionTaskId" | "userId" | "eventType" | "createdAt" | "note", ExtArgs["result"]["productionTaskLog"]>
  export type ProductionTaskLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTask?: boolean | ProductionTaskDefaultArgs<ExtArgs>
    user?: boolean | ProductionTaskLog$userArgs<ExtArgs>
  }
  export type ProductionTaskLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTask?: boolean | ProductionTaskDefaultArgs<ExtArgs>
    user?: boolean | ProductionTaskLog$userArgs<ExtArgs>
  }
  export type ProductionTaskLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTask?: boolean | ProductionTaskDefaultArgs<ExtArgs>
    user?: boolean | ProductionTaskLog$userArgs<ExtArgs>
  }

  export type $ProductionTaskLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionTaskLog"
    objects: {
      productionTask: Prisma.$ProductionTaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionTaskId: number
      userId: number | null
      eventType: $Enums.TaskEventType
      createdAt: Date
      note: string | null
    }, ExtArgs["result"]["productionTaskLog"]>
    composites: {}
  }

  type ProductionTaskLogGetPayload<S extends boolean | null | undefined | ProductionTaskLogDefaultArgs> = $Result.GetResult<Prisma.$ProductionTaskLogPayload, S>

  type ProductionTaskLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionTaskLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionTaskLogCountAggregateInputType | true
    }

  export interface ProductionTaskLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionTaskLog'], meta: { name: 'ProductionTaskLog' } }
    /**
     * Find zero or one ProductionTaskLog that matches the filter.
     * @param {ProductionTaskLogFindUniqueArgs} args - Arguments to find a ProductionTaskLog
     * @example
     * // Get one ProductionTaskLog
     * const productionTaskLog = await prisma.productionTaskLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionTaskLogFindUniqueArgs>(args: SelectSubset<T, ProductionTaskLogFindUniqueArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionTaskLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionTaskLogFindUniqueOrThrowArgs} args - Arguments to find a ProductionTaskLog
     * @example
     * // Get one ProductionTaskLog
     * const productionTaskLog = await prisma.productionTaskLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionTaskLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionTaskLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionTaskLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogFindFirstArgs} args - Arguments to find a ProductionTaskLog
     * @example
     * // Get one ProductionTaskLog
     * const productionTaskLog = await prisma.productionTaskLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionTaskLogFindFirstArgs>(args?: SelectSubset<T, ProductionTaskLogFindFirstArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionTaskLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogFindFirstOrThrowArgs} args - Arguments to find a ProductionTaskLog
     * @example
     * // Get one ProductionTaskLog
     * const productionTaskLog = await prisma.productionTaskLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionTaskLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionTaskLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionTaskLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionTaskLogs
     * const productionTaskLogs = await prisma.productionTaskLog.findMany()
     * 
     * // Get first 10 ProductionTaskLogs
     * const productionTaskLogs = await prisma.productionTaskLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionTaskLogWithIdOnly = await prisma.productionTaskLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionTaskLogFindManyArgs>(args?: SelectSubset<T, ProductionTaskLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionTaskLog.
     * @param {ProductionTaskLogCreateArgs} args - Arguments to create a ProductionTaskLog.
     * @example
     * // Create one ProductionTaskLog
     * const ProductionTaskLog = await prisma.productionTaskLog.create({
     *   data: {
     *     // ... data to create a ProductionTaskLog
     *   }
     * })
     * 
     */
    create<T extends ProductionTaskLogCreateArgs>(args: SelectSubset<T, ProductionTaskLogCreateArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionTaskLogs.
     * @param {ProductionTaskLogCreateManyArgs} args - Arguments to create many ProductionTaskLogs.
     * @example
     * // Create many ProductionTaskLogs
     * const productionTaskLog = await prisma.productionTaskLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionTaskLogCreateManyArgs>(args?: SelectSubset<T, ProductionTaskLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionTaskLogs and returns the data saved in the database.
     * @param {ProductionTaskLogCreateManyAndReturnArgs} args - Arguments to create many ProductionTaskLogs.
     * @example
     * // Create many ProductionTaskLogs
     * const productionTaskLog = await prisma.productionTaskLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionTaskLogs and only return the `id`
     * const productionTaskLogWithIdOnly = await prisma.productionTaskLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionTaskLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionTaskLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionTaskLog.
     * @param {ProductionTaskLogDeleteArgs} args - Arguments to delete one ProductionTaskLog.
     * @example
     * // Delete one ProductionTaskLog
     * const ProductionTaskLog = await prisma.productionTaskLog.delete({
     *   where: {
     *     // ... filter to delete one ProductionTaskLog
     *   }
     * })
     * 
     */
    delete<T extends ProductionTaskLogDeleteArgs>(args: SelectSubset<T, ProductionTaskLogDeleteArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionTaskLog.
     * @param {ProductionTaskLogUpdateArgs} args - Arguments to update one ProductionTaskLog.
     * @example
     * // Update one ProductionTaskLog
     * const productionTaskLog = await prisma.productionTaskLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionTaskLogUpdateArgs>(args: SelectSubset<T, ProductionTaskLogUpdateArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionTaskLogs.
     * @param {ProductionTaskLogDeleteManyArgs} args - Arguments to filter ProductionTaskLogs to delete.
     * @example
     * // Delete a few ProductionTaskLogs
     * const { count } = await prisma.productionTaskLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionTaskLogDeleteManyArgs>(args?: SelectSubset<T, ProductionTaskLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionTaskLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionTaskLogs
     * const productionTaskLog = await prisma.productionTaskLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionTaskLogUpdateManyArgs>(args: SelectSubset<T, ProductionTaskLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionTaskLogs and returns the data updated in the database.
     * @param {ProductionTaskLogUpdateManyAndReturnArgs} args - Arguments to update many ProductionTaskLogs.
     * @example
     * // Update many ProductionTaskLogs
     * const productionTaskLog = await prisma.productionTaskLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionTaskLogs and only return the `id`
     * const productionTaskLogWithIdOnly = await prisma.productionTaskLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionTaskLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionTaskLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionTaskLog.
     * @param {ProductionTaskLogUpsertArgs} args - Arguments to update or create a ProductionTaskLog.
     * @example
     * // Update or create a ProductionTaskLog
     * const productionTaskLog = await prisma.productionTaskLog.upsert({
     *   create: {
     *     // ... data to create a ProductionTaskLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionTaskLog we want to update
     *   }
     * })
     */
    upsert<T extends ProductionTaskLogUpsertArgs>(args: SelectSubset<T, ProductionTaskLogUpsertArgs<ExtArgs>>): Prisma__ProductionTaskLogClient<$Result.GetResult<Prisma.$ProductionTaskLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionTaskLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogCountArgs} args - Arguments to filter ProductionTaskLogs to count.
     * @example
     * // Count the number of ProductionTaskLogs
     * const count = await prisma.productionTaskLog.count({
     *   where: {
     *     // ... the filter for the ProductionTaskLogs we want to count
     *   }
     * })
    **/
    count<T extends ProductionTaskLogCountArgs>(
      args?: Subset<T, ProductionTaskLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionTaskLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionTaskLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionTaskLogAggregateArgs>(args: Subset<T, ProductionTaskLogAggregateArgs>): Prisma.PrismaPromise<GetProductionTaskLogAggregateType<T>>

    /**
     * Group by ProductionTaskLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionTaskLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionTaskLogGroupByArgs['orderBy'] }
        : { orderBy?: ProductionTaskLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionTaskLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionTaskLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionTaskLog model
   */
  readonly fields: ProductionTaskLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionTaskLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionTaskLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionTask<T extends ProductionTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTaskDefaultArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ProductionTaskLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTaskLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionTaskLog model
   */
  interface ProductionTaskLogFieldRefs {
    readonly id: FieldRef<"ProductionTaskLog", 'Int'>
    readonly productionTaskId: FieldRef<"ProductionTaskLog", 'Int'>
    readonly userId: FieldRef<"ProductionTaskLog", 'Int'>
    readonly eventType: FieldRef<"ProductionTaskLog", 'TaskEventType'>
    readonly createdAt: FieldRef<"ProductionTaskLog", 'DateTime'>
    readonly note: FieldRef<"ProductionTaskLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductionTaskLog findUnique
   */
  export type ProductionTaskLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTaskLog to fetch.
     */
    where: ProductionTaskLogWhereUniqueInput
  }

  /**
   * ProductionTaskLog findUniqueOrThrow
   */
  export type ProductionTaskLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTaskLog to fetch.
     */
    where: ProductionTaskLogWhereUniqueInput
  }

  /**
   * ProductionTaskLog findFirst
   */
  export type ProductionTaskLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTaskLog to fetch.
     */
    where?: ProductionTaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTaskLogs to fetch.
     */
    orderBy?: ProductionTaskLogOrderByWithRelationInput | ProductionTaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionTaskLogs.
     */
    cursor?: ProductionTaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionTaskLogs.
     */
    distinct?: ProductionTaskLogScalarFieldEnum | ProductionTaskLogScalarFieldEnum[]
  }

  /**
   * ProductionTaskLog findFirstOrThrow
   */
  export type ProductionTaskLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTaskLog to fetch.
     */
    where?: ProductionTaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTaskLogs to fetch.
     */
    orderBy?: ProductionTaskLogOrderByWithRelationInput | ProductionTaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionTaskLogs.
     */
    cursor?: ProductionTaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionTaskLogs.
     */
    distinct?: ProductionTaskLogScalarFieldEnum | ProductionTaskLogScalarFieldEnum[]
  }

  /**
   * ProductionTaskLog findMany
   */
  export type ProductionTaskLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTaskLogs to fetch.
     */
    where?: ProductionTaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTaskLogs to fetch.
     */
    orderBy?: ProductionTaskLogOrderByWithRelationInput | ProductionTaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionTaskLogs.
     */
    cursor?: ProductionTaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTaskLogs.
     */
    skip?: number
    distinct?: ProductionTaskLogScalarFieldEnum | ProductionTaskLogScalarFieldEnum[]
  }

  /**
   * ProductionTaskLog create
   */
  export type ProductionTaskLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionTaskLog.
     */
    data: XOR<ProductionTaskLogCreateInput, ProductionTaskLogUncheckedCreateInput>
  }

  /**
   * ProductionTaskLog createMany
   */
  export type ProductionTaskLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionTaskLogs.
     */
    data: ProductionTaskLogCreateManyInput | ProductionTaskLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionTaskLog createManyAndReturn
   */
  export type ProductionTaskLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionTaskLogs.
     */
    data: ProductionTaskLogCreateManyInput | ProductionTaskLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionTaskLog update
   */
  export type ProductionTaskLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionTaskLog.
     */
    data: XOR<ProductionTaskLogUpdateInput, ProductionTaskLogUncheckedUpdateInput>
    /**
     * Choose, which ProductionTaskLog to update.
     */
    where: ProductionTaskLogWhereUniqueInput
  }

  /**
   * ProductionTaskLog updateMany
   */
  export type ProductionTaskLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionTaskLogs.
     */
    data: XOR<ProductionTaskLogUpdateManyMutationInput, ProductionTaskLogUncheckedUpdateManyInput>
    /**
     * Filter which ProductionTaskLogs to update
     */
    where?: ProductionTaskLogWhereInput
    /**
     * Limit how many ProductionTaskLogs to update.
     */
    limit?: number
  }

  /**
   * ProductionTaskLog updateManyAndReturn
   */
  export type ProductionTaskLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * The data used to update ProductionTaskLogs.
     */
    data: XOR<ProductionTaskLogUpdateManyMutationInput, ProductionTaskLogUncheckedUpdateManyInput>
    /**
     * Filter which ProductionTaskLogs to update
     */
    where?: ProductionTaskLogWhereInput
    /**
     * Limit how many ProductionTaskLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionTaskLog upsert
   */
  export type ProductionTaskLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionTaskLog to update in case it exists.
     */
    where: ProductionTaskLogWhereUniqueInput
    /**
     * In case the ProductionTaskLog found by the `where` argument doesn't exist, create a new ProductionTaskLog with this data.
     */
    create: XOR<ProductionTaskLogCreateInput, ProductionTaskLogUncheckedCreateInput>
    /**
     * In case the ProductionTaskLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionTaskLogUpdateInput, ProductionTaskLogUncheckedUpdateInput>
  }

  /**
   * ProductionTaskLog delete
   */
  export type ProductionTaskLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
    /**
     * Filter which ProductionTaskLog to delete.
     */
    where: ProductionTaskLogWhereUniqueInput
  }

  /**
   * ProductionTaskLog deleteMany
   */
  export type ProductionTaskLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionTaskLogs to delete
     */
    where?: ProductionTaskLogWhereInput
    /**
     * Limit how many ProductionTaskLogs to delete.
     */
    limit?: number
  }

  /**
   * ProductionTaskLog.user
   */
  export type ProductionTaskLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductionTaskLog without action
   */
  export type ProductionTaskLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskLog
     */
    select?: ProductionTaskLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionTaskLog
     */
    omit?: ProductionTaskLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskLogInclude<ExtArgs> | null
  }


  /**
   * Model TaskTemplatePiece
   */

  export type AggregateTaskTemplatePiece = {
    _count: TaskTemplatePieceCountAggregateOutputType | null
    _avg: TaskTemplatePieceAvgAggregateOutputType | null
    _sum: TaskTemplatePieceSumAggregateOutputType | null
    _min: TaskTemplatePieceMinAggregateOutputType | null
    _max: TaskTemplatePieceMaxAggregateOutputType | null
  }

  export type TaskTemplatePieceAvgAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    pieceId: number | null
    quantity: number | null
  }

  export type TaskTemplatePieceSumAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    pieceId: number | null
    quantity: number | null
  }

  export type TaskTemplatePieceMinAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    pieceId: number | null
    quantity: number | null
  }

  export type TaskTemplatePieceMaxAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    pieceId: number | null
    quantity: number | null
  }

  export type TaskTemplatePieceCountAggregateOutputType = {
    id: number
    taskTemplateId: number
    pieceId: number
    quantity: number
    _all: number
  }


  export type TaskTemplatePieceAvgAggregateInputType = {
    id?: true
    taskTemplateId?: true
    pieceId?: true
    quantity?: true
  }

  export type TaskTemplatePieceSumAggregateInputType = {
    id?: true
    taskTemplateId?: true
    pieceId?: true
    quantity?: true
  }

  export type TaskTemplatePieceMinAggregateInputType = {
    id?: true
    taskTemplateId?: true
    pieceId?: true
    quantity?: true
  }

  export type TaskTemplatePieceMaxAggregateInputType = {
    id?: true
    taskTemplateId?: true
    pieceId?: true
    quantity?: true
  }

  export type TaskTemplatePieceCountAggregateInputType = {
    id?: true
    taskTemplateId?: true
    pieceId?: true
    quantity?: true
    _all?: true
  }

  export type TaskTemplatePieceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplatePiece to aggregate.
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplatePieces to fetch.
     */
    orderBy?: TaskTemplatePieceOrderByWithRelationInput | TaskTemplatePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTemplatePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplatePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplatePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTemplatePieces
    **/
    _count?: true | TaskTemplatePieceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTemplatePieceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTemplatePieceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTemplatePieceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTemplatePieceMaxAggregateInputType
  }

  export type GetTaskTemplatePieceAggregateType<T extends TaskTemplatePieceAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTemplatePiece]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTemplatePiece[P]>
      : GetScalarType<T[P], AggregateTaskTemplatePiece[P]>
  }




  export type TaskTemplatePieceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplatePieceWhereInput
    orderBy?: TaskTemplatePieceOrderByWithAggregationInput | TaskTemplatePieceOrderByWithAggregationInput[]
    by: TaskTemplatePieceScalarFieldEnum[] | TaskTemplatePieceScalarFieldEnum
    having?: TaskTemplatePieceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTemplatePieceCountAggregateInputType | true
    _avg?: TaskTemplatePieceAvgAggregateInputType
    _sum?: TaskTemplatePieceSumAggregateInputType
    _min?: TaskTemplatePieceMinAggregateInputType
    _max?: TaskTemplatePieceMaxAggregateInputType
  }

  export type TaskTemplatePieceGroupByOutputType = {
    id: number
    taskTemplateId: number
    pieceId: number
    quantity: number
    _count: TaskTemplatePieceCountAggregateOutputType | null
    _avg: TaskTemplatePieceAvgAggregateOutputType | null
    _sum: TaskTemplatePieceSumAggregateOutputType | null
    _min: TaskTemplatePieceMinAggregateOutputType | null
    _max: TaskTemplatePieceMaxAggregateOutputType | null
  }

  type GetTaskTemplatePieceGroupByPayload<T extends TaskTemplatePieceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTemplatePieceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTemplatePieceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTemplatePieceGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTemplatePieceGroupByOutputType[P]>
        }
      >
    >


  export type TaskTemplatePieceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    pieceId?: boolean
    quantity?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplatePiece"]>

  export type TaskTemplatePieceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    pieceId?: boolean
    quantity?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplatePiece"]>

  export type TaskTemplatePieceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    pieceId?: boolean
    quantity?: boolean
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplatePiece"]>

  export type TaskTemplatePieceSelectScalar = {
    id?: boolean
    taskTemplateId?: boolean
    pieceId?: boolean
    quantity?: boolean
  }

  export type TaskTemplatePieceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskTemplateId" | "pieceId" | "quantity", ExtArgs["result"]["taskTemplatePiece"]>
  export type TaskTemplatePieceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }
  export type TaskTemplatePieceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }
  export type TaskTemplatePieceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piece?: boolean | PieceDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }

  export type $TaskTemplatePiecePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTemplatePiece"
    objects: {
      piece: Prisma.$PiecePayload<ExtArgs>
      taskTemplate: Prisma.$TaskTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskTemplateId: number
      pieceId: number
      quantity: number
    }, ExtArgs["result"]["taskTemplatePiece"]>
    composites: {}
  }

  type TaskTemplatePieceGetPayload<S extends boolean | null | undefined | TaskTemplatePieceDefaultArgs> = $Result.GetResult<Prisma.$TaskTemplatePiecePayload, S>

  type TaskTemplatePieceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTemplatePieceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTemplatePieceCountAggregateInputType | true
    }

  export interface TaskTemplatePieceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTemplatePiece'], meta: { name: 'TaskTemplatePiece' } }
    /**
     * Find zero or one TaskTemplatePiece that matches the filter.
     * @param {TaskTemplatePieceFindUniqueArgs} args - Arguments to find a TaskTemplatePiece
     * @example
     * // Get one TaskTemplatePiece
     * const taskTemplatePiece = await prisma.taskTemplatePiece.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTemplatePieceFindUniqueArgs>(args: SelectSubset<T, TaskTemplatePieceFindUniqueArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTemplatePiece that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTemplatePieceFindUniqueOrThrowArgs} args - Arguments to find a TaskTemplatePiece
     * @example
     * // Get one TaskTemplatePiece
     * const taskTemplatePiece = await prisma.taskTemplatePiece.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTemplatePieceFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTemplatePieceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplatePiece that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceFindFirstArgs} args - Arguments to find a TaskTemplatePiece
     * @example
     * // Get one TaskTemplatePiece
     * const taskTemplatePiece = await prisma.taskTemplatePiece.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTemplatePieceFindFirstArgs>(args?: SelectSubset<T, TaskTemplatePieceFindFirstArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplatePiece that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceFindFirstOrThrowArgs} args - Arguments to find a TaskTemplatePiece
     * @example
     * // Get one TaskTemplatePiece
     * const taskTemplatePiece = await prisma.taskTemplatePiece.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTemplatePieceFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTemplatePieceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTemplatePieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTemplatePieces
     * const taskTemplatePieces = await prisma.taskTemplatePiece.findMany()
     * 
     * // Get first 10 TaskTemplatePieces
     * const taskTemplatePieces = await prisma.taskTemplatePiece.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTemplatePieceWithIdOnly = await prisma.taskTemplatePiece.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTemplatePieceFindManyArgs>(args?: SelectSubset<T, TaskTemplatePieceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTemplatePiece.
     * @param {TaskTemplatePieceCreateArgs} args - Arguments to create a TaskTemplatePiece.
     * @example
     * // Create one TaskTemplatePiece
     * const TaskTemplatePiece = await prisma.taskTemplatePiece.create({
     *   data: {
     *     // ... data to create a TaskTemplatePiece
     *   }
     * })
     * 
     */
    create<T extends TaskTemplatePieceCreateArgs>(args: SelectSubset<T, TaskTemplatePieceCreateArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTemplatePieces.
     * @param {TaskTemplatePieceCreateManyArgs} args - Arguments to create many TaskTemplatePieces.
     * @example
     * // Create many TaskTemplatePieces
     * const taskTemplatePiece = await prisma.taskTemplatePiece.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTemplatePieceCreateManyArgs>(args?: SelectSubset<T, TaskTemplatePieceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTemplatePieces and returns the data saved in the database.
     * @param {TaskTemplatePieceCreateManyAndReturnArgs} args - Arguments to create many TaskTemplatePieces.
     * @example
     * // Create many TaskTemplatePieces
     * const taskTemplatePiece = await prisma.taskTemplatePiece.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTemplatePieces and only return the `id`
     * const taskTemplatePieceWithIdOnly = await prisma.taskTemplatePiece.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTemplatePieceCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTemplatePieceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTemplatePiece.
     * @param {TaskTemplatePieceDeleteArgs} args - Arguments to delete one TaskTemplatePiece.
     * @example
     * // Delete one TaskTemplatePiece
     * const TaskTemplatePiece = await prisma.taskTemplatePiece.delete({
     *   where: {
     *     // ... filter to delete one TaskTemplatePiece
     *   }
     * })
     * 
     */
    delete<T extends TaskTemplatePieceDeleteArgs>(args: SelectSubset<T, TaskTemplatePieceDeleteArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTemplatePiece.
     * @param {TaskTemplatePieceUpdateArgs} args - Arguments to update one TaskTemplatePiece.
     * @example
     * // Update one TaskTemplatePiece
     * const taskTemplatePiece = await prisma.taskTemplatePiece.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTemplatePieceUpdateArgs>(args: SelectSubset<T, TaskTemplatePieceUpdateArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTemplatePieces.
     * @param {TaskTemplatePieceDeleteManyArgs} args - Arguments to filter TaskTemplatePieces to delete.
     * @example
     * // Delete a few TaskTemplatePieces
     * const { count } = await prisma.taskTemplatePiece.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTemplatePieceDeleteManyArgs>(args?: SelectSubset<T, TaskTemplatePieceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplatePieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTemplatePieces
     * const taskTemplatePiece = await prisma.taskTemplatePiece.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTemplatePieceUpdateManyArgs>(args: SelectSubset<T, TaskTemplatePieceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplatePieces and returns the data updated in the database.
     * @param {TaskTemplatePieceUpdateManyAndReturnArgs} args - Arguments to update many TaskTemplatePieces.
     * @example
     * // Update many TaskTemplatePieces
     * const taskTemplatePiece = await prisma.taskTemplatePiece.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTemplatePieces and only return the `id`
     * const taskTemplatePieceWithIdOnly = await prisma.taskTemplatePiece.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTemplatePieceUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTemplatePieceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTemplatePiece.
     * @param {TaskTemplatePieceUpsertArgs} args - Arguments to update or create a TaskTemplatePiece.
     * @example
     * // Update or create a TaskTemplatePiece
     * const taskTemplatePiece = await prisma.taskTemplatePiece.upsert({
     *   create: {
     *     // ... data to create a TaskTemplatePiece
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTemplatePiece we want to update
     *   }
     * })
     */
    upsert<T extends TaskTemplatePieceUpsertArgs>(args: SelectSubset<T, TaskTemplatePieceUpsertArgs<ExtArgs>>): Prisma__TaskTemplatePieceClient<$Result.GetResult<Prisma.$TaskTemplatePiecePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTemplatePieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceCountArgs} args - Arguments to filter TaskTemplatePieces to count.
     * @example
     * // Count the number of TaskTemplatePieces
     * const count = await prisma.taskTemplatePiece.count({
     *   where: {
     *     // ... the filter for the TaskTemplatePieces we want to count
     *   }
     * })
    **/
    count<T extends TaskTemplatePieceCountArgs>(
      args?: Subset<T, TaskTemplatePieceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTemplatePieceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTemplatePiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTemplatePieceAggregateArgs>(args: Subset<T, TaskTemplatePieceAggregateArgs>): Prisma.PrismaPromise<GetTaskTemplatePieceAggregateType<T>>

    /**
     * Group by TaskTemplatePiece.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplatePieceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTemplatePieceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTemplatePieceGroupByArgs['orderBy'] }
        : { orderBy?: TaskTemplatePieceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTemplatePieceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTemplatePieceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTemplatePiece model
   */
  readonly fields: TaskTemplatePieceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTemplatePiece.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTemplatePieceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    piece<T extends PieceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PieceDefaultArgs<ExtArgs>>): Prisma__PieceClient<$Result.GetResult<Prisma.$PiecePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taskTemplate<T extends TaskTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplateDefaultArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTemplatePiece model
   */
  interface TaskTemplatePieceFieldRefs {
    readonly id: FieldRef<"TaskTemplatePiece", 'Int'>
    readonly taskTemplateId: FieldRef<"TaskTemplatePiece", 'Int'>
    readonly pieceId: FieldRef<"TaskTemplatePiece", 'Int'>
    readonly quantity: FieldRef<"TaskTemplatePiece", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TaskTemplatePiece findUnique
   */
  export type TaskTemplatePieceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplatePiece to fetch.
     */
    where: TaskTemplatePieceWhereUniqueInput
  }

  /**
   * TaskTemplatePiece findUniqueOrThrow
   */
  export type TaskTemplatePieceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplatePiece to fetch.
     */
    where: TaskTemplatePieceWhereUniqueInput
  }

  /**
   * TaskTemplatePiece findFirst
   */
  export type TaskTemplatePieceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplatePiece to fetch.
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplatePieces to fetch.
     */
    orderBy?: TaskTemplatePieceOrderByWithRelationInput | TaskTemplatePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplatePieces.
     */
    cursor?: TaskTemplatePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplatePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplatePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplatePieces.
     */
    distinct?: TaskTemplatePieceScalarFieldEnum | TaskTemplatePieceScalarFieldEnum[]
  }

  /**
   * TaskTemplatePiece findFirstOrThrow
   */
  export type TaskTemplatePieceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplatePiece to fetch.
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplatePieces to fetch.
     */
    orderBy?: TaskTemplatePieceOrderByWithRelationInput | TaskTemplatePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplatePieces.
     */
    cursor?: TaskTemplatePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplatePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplatePieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplatePieces.
     */
    distinct?: TaskTemplatePieceScalarFieldEnum | TaskTemplatePieceScalarFieldEnum[]
  }

  /**
   * TaskTemplatePiece findMany
   */
  export type TaskTemplatePieceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplatePieces to fetch.
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplatePieces to fetch.
     */
    orderBy?: TaskTemplatePieceOrderByWithRelationInput | TaskTemplatePieceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTemplatePieces.
     */
    cursor?: TaskTemplatePieceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplatePieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplatePieces.
     */
    skip?: number
    distinct?: TaskTemplatePieceScalarFieldEnum | TaskTemplatePieceScalarFieldEnum[]
  }

  /**
   * TaskTemplatePiece create
   */
  export type TaskTemplatePieceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTemplatePiece.
     */
    data: XOR<TaskTemplatePieceCreateInput, TaskTemplatePieceUncheckedCreateInput>
  }

  /**
   * TaskTemplatePiece createMany
   */
  export type TaskTemplatePieceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTemplatePieces.
     */
    data: TaskTemplatePieceCreateManyInput | TaskTemplatePieceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTemplatePiece createManyAndReturn
   */
  export type TaskTemplatePieceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTemplatePieces.
     */
    data: TaskTemplatePieceCreateManyInput | TaskTemplatePieceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplatePiece update
   */
  export type TaskTemplatePieceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTemplatePiece.
     */
    data: XOR<TaskTemplatePieceUpdateInput, TaskTemplatePieceUncheckedUpdateInput>
    /**
     * Choose, which TaskTemplatePiece to update.
     */
    where: TaskTemplatePieceWhereUniqueInput
  }

  /**
   * TaskTemplatePiece updateMany
   */
  export type TaskTemplatePieceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTemplatePieces.
     */
    data: XOR<TaskTemplatePieceUpdateManyMutationInput, TaskTemplatePieceUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplatePieces to update
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * Limit how many TaskTemplatePieces to update.
     */
    limit?: number
  }

  /**
   * TaskTemplatePiece updateManyAndReturn
   */
  export type TaskTemplatePieceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * The data used to update TaskTemplatePieces.
     */
    data: XOR<TaskTemplatePieceUpdateManyMutationInput, TaskTemplatePieceUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplatePieces to update
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * Limit how many TaskTemplatePieces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplatePiece upsert
   */
  export type TaskTemplatePieceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTemplatePiece to update in case it exists.
     */
    where: TaskTemplatePieceWhereUniqueInput
    /**
     * In case the TaskTemplatePiece found by the `where` argument doesn't exist, create a new TaskTemplatePiece with this data.
     */
    create: XOR<TaskTemplatePieceCreateInput, TaskTemplatePieceUncheckedCreateInput>
    /**
     * In case the TaskTemplatePiece was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTemplatePieceUpdateInput, TaskTemplatePieceUncheckedUpdateInput>
  }

  /**
   * TaskTemplatePiece delete
   */
  export type TaskTemplatePieceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
    /**
     * Filter which TaskTemplatePiece to delete.
     */
    where: TaskTemplatePieceWhereUniqueInput
  }

  /**
   * TaskTemplatePiece deleteMany
   */
  export type TaskTemplatePieceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplatePieces to delete
     */
    where?: TaskTemplatePieceWhereInput
    /**
     * Limit how many TaskTemplatePieces to delete.
     */
    limit?: number
  }

  /**
   * TaskTemplatePiece without action
   */
  export type TaskTemplatePieceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplatePiece
     */
    select?: TaskTemplatePieceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplatePiece
     */
    omit?: TaskTemplatePieceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplatePieceInclude<ExtArgs> | null
  }


  /**
   * Model TaskTemplateSousAssemblage
   */

  export type AggregateTaskTemplateSousAssemblage = {
    _count: TaskTemplateSousAssemblageCountAggregateOutputType | null
    _avg: TaskTemplateSousAssemblageAvgAggregateOutputType | null
    _sum: TaskTemplateSousAssemblageSumAggregateOutputType | null
    _min: TaskTemplateSousAssemblageMinAggregateOutputType | null
    _max: TaskTemplateSousAssemblageMaxAggregateOutputType | null
  }

  export type TaskTemplateSousAssemblageAvgAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousAssemblageSumAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousAssemblageMinAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousAssemblageMaxAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousAssemblageCountAggregateOutputType = {
    id: number
    taskTemplateId: number
    sousAssemblageId: number
    quantity: number
    _all: number
  }


  export type TaskTemplateSousAssemblageAvgAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousAssemblageSumAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousAssemblageMinAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousAssemblageMaxAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousAssemblageCountAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousAssemblageId?: true
    quantity?: true
    _all?: true
  }

  export type TaskTemplateSousAssemblageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplateSousAssemblage to aggregate.
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousAssemblageOrderByWithRelationInput | TaskTemplateSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTemplateSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTemplateSousAssemblages
    **/
    _count?: true | TaskTemplateSousAssemblageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTemplateSousAssemblageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTemplateSousAssemblageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTemplateSousAssemblageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTemplateSousAssemblageMaxAggregateInputType
  }

  export type GetTaskTemplateSousAssemblageAggregateType<T extends TaskTemplateSousAssemblageAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTemplateSousAssemblage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTemplateSousAssemblage[P]>
      : GetScalarType<T[P], AggregateTaskTemplateSousAssemblage[P]>
  }




  export type TaskTemplateSousAssemblageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateSousAssemblageWhereInput
    orderBy?: TaskTemplateSousAssemblageOrderByWithAggregationInput | TaskTemplateSousAssemblageOrderByWithAggregationInput[]
    by: TaskTemplateSousAssemblageScalarFieldEnum[] | TaskTemplateSousAssemblageScalarFieldEnum
    having?: TaskTemplateSousAssemblageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTemplateSousAssemblageCountAggregateInputType | true
    _avg?: TaskTemplateSousAssemblageAvgAggregateInputType
    _sum?: TaskTemplateSousAssemblageSumAggregateInputType
    _min?: TaskTemplateSousAssemblageMinAggregateInputType
    _max?: TaskTemplateSousAssemblageMaxAggregateInputType
  }

  export type TaskTemplateSousAssemblageGroupByOutputType = {
    id: number
    taskTemplateId: number
    sousAssemblageId: number
    quantity: number
    _count: TaskTemplateSousAssemblageCountAggregateOutputType | null
    _avg: TaskTemplateSousAssemblageAvgAggregateOutputType | null
    _sum: TaskTemplateSousAssemblageSumAggregateOutputType | null
    _min: TaskTemplateSousAssemblageMinAggregateOutputType | null
    _max: TaskTemplateSousAssemblageMaxAggregateOutputType | null
  }

  type GetTaskTemplateSousAssemblageGroupByPayload<T extends TaskTemplateSousAssemblageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTemplateSousAssemblageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTemplateSousAssemblageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTemplateSousAssemblageGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTemplateSousAssemblageGroupByOutputType[P]>
        }
      >
    >


  export type TaskTemplateSousAssemblageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    sousAssemblageId?: boolean
    quantity?: boolean
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateSousAssemblage"]>

  export type TaskTemplateSousAssemblageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    sousAssemblageId?: boolean
    quantity?: boolean
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateSousAssemblage"]>

  export type TaskTemplateSousAssemblageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    sousAssemblageId?: boolean
    quantity?: boolean
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateSousAssemblage"]>

  export type TaskTemplateSousAssemblageSelectScalar = {
    id?: boolean
    taskTemplateId?: boolean
    sousAssemblageId?: boolean
    quantity?: boolean
  }

  export type TaskTemplateSousAssemblageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskTemplateId" | "sousAssemblageId" | "quantity", ExtArgs["result"]["taskTemplateSousAssemblage"]>
  export type TaskTemplateSousAssemblageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }
  export type TaskTemplateSousAssemblageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }
  export type TaskTemplateSousAssemblageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousAssemblage?: boolean | SousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }

  export type $TaskTemplateSousAssemblagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTemplateSousAssemblage"
    objects: {
      sousAssemblage: Prisma.$SousAssemblagePayload<ExtArgs>
      taskTemplate: Prisma.$TaskTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskTemplateId: number
      sousAssemblageId: number
      quantity: number
    }, ExtArgs["result"]["taskTemplateSousAssemblage"]>
    composites: {}
  }

  type TaskTemplateSousAssemblageGetPayload<S extends boolean | null | undefined | TaskTemplateSousAssemblageDefaultArgs> = $Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload, S>

  type TaskTemplateSousAssemblageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTemplateSousAssemblageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTemplateSousAssemblageCountAggregateInputType | true
    }

  export interface TaskTemplateSousAssemblageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTemplateSousAssemblage'], meta: { name: 'TaskTemplateSousAssemblage' } }
    /**
     * Find zero or one TaskTemplateSousAssemblage that matches the filter.
     * @param {TaskTemplateSousAssemblageFindUniqueArgs} args - Arguments to find a TaskTemplateSousAssemblage
     * @example
     * // Get one TaskTemplateSousAssemblage
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTemplateSousAssemblageFindUniqueArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageFindUniqueArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTemplateSousAssemblage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTemplateSousAssemblageFindUniqueOrThrowArgs} args - Arguments to find a TaskTemplateSousAssemblage
     * @example
     * // Get one TaskTemplateSousAssemblage
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTemplateSousAssemblageFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplateSousAssemblage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageFindFirstArgs} args - Arguments to find a TaskTemplateSousAssemblage
     * @example
     * // Get one TaskTemplateSousAssemblage
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTemplateSousAssemblageFindFirstArgs>(args?: SelectSubset<T, TaskTemplateSousAssemblageFindFirstArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplateSousAssemblage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageFindFirstOrThrowArgs} args - Arguments to find a TaskTemplateSousAssemblage
     * @example
     * // Get one TaskTemplateSousAssemblage
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTemplateSousAssemblageFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTemplateSousAssemblageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTemplateSousAssemblages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTemplateSousAssemblages
     * const taskTemplateSousAssemblages = await prisma.taskTemplateSousAssemblage.findMany()
     * 
     * // Get first 10 TaskTemplateSousAssemblages
     * const taskTemplateSousAssemblages = await prisma.taskTemplateSousAssemblage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTemplateSousAssemblageWithIdOnly = await prisma.taskTemplateSousAssemblage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTemplateSousAssemblageFindManyArgs>(args?: SelectSubset<T, TaskTemplateSousAssemblageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTemplateSousAssemblage.
     * @param {TaskTemplateSousAssemblageCreateArgs} args - Arguments to create a TaskTemplateSousAssemblage.
     * @example
     * // Create one TaskTemplateSousAssemblage
     * const TaskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.create({
     *   data: {
     *     // ... data to create a TaskTemplateSousAssemblage
     *   }
     * })
     * 
     */
    create<T extends TaskTemplateSousAssemblageCreateArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageCreateArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTemplateSousAssemblages.
     * @param {TaskTemplateSousAssemblageCreateManyArgs} args - Arguments to create many TaskTemplateSousAssemblages.
     * @example
     * // Create many TaskTemplateSousAssemblages
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTemplateSousAssemblageCreateManyArgs>(args?: SelectSubset<T, TaskTemplateSousAssemblageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTemplateSousAssemblages and returns the data saved in the database.
     * @param {TaskTemplateSousAssemblageCreateManyAndReturnArgs} args - Arguments to create many TaskTemplateSousAssemblages.
     * @example
     * // Create many TaskTemplateSousAssemblages
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTemplateSousAssemblages and only return the `id`
     * const taskTemplateSousAssemblageWithIdOnly = await prisma.taskTemplateSousAssemblage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTemplateSousAssemblageCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTemplateSousAssemblageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTemplateSousAssemblage.
     * @param {TaskTemplateSousAssemblageDeleteArgs} args - Arguments to delete one TaskTemplateSousAssemblage.
     * @example
     * // Delete one TaskTemplateSousAssemblage
     * const TaskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.delete({
     *   where: {
     *     // ... filter to delete one TaskTemplateSousAssemblage
     *   }
     * })
     * 
     */
    delete<T extends TaskTemplateSousAssemblageDeleteArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageDeleteArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTemplateSousAssemblage.
     * @param {TaskTemplateSousAssemblageUpdateArgs} args - Arguments to update one TaskTemplateSousAssemblage.
     * @example
     * // Update one TaskTemplateSousAssemblage
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTemplateSousAssemblageUpdateArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageUpdateArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTemplateSousAssemblages.
     * @param {TaskTemplateSousAssemblageDeleteManyArgs} args - Arguments to filter TaskTemplateSousAssemblages to delete.
     * @example
     * // Delete a few TaskTemplateSousAssemblages
     * const { count } = await prisma.taskTemplateSousAssemblage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTemplateSousAssemblageDeleteManyArgs>(args?: SelectSubset<T, TaskTemplateSousAssemblageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplateSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTemplateSousAssemblages
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTemplateSousAssemblageUpdateManyArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplateSousAssemblages and returns the data updated in the database.
     * @param {TaskTemplateSousAssemblageUpdateManyAndReturnArgs} args - Arguments to update many TaskTemplateSousAssemblages.
     * @example
     * // Update many TaskTemplateSousAssemblages
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTemplateSousAssemblages and only return the `id`
     * const taskTemplateSousAssemblageWithIdOnly = await prisma.taskTemplateSousAssemblage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTemplateSousAssemblageUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTemplateSousAssemblage.
     * @param {TaskTemplateSousAssemblageUpsertArgs} args - Arguments to update or create a TaskTemplateSousAssemblage.
     * @example
     * // Update or create a TaskTemplateSousAssemblage
     * const taskTemplateSousAssemblage = await prisma.taskTemplateSousAssemblage.upsert({
     *   create: {
     *     // ... data to create a TaskTemplateSousAssemblage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTemplateSousAssemblage we want to update
     *   }
     * })
     */
    upsert<T extends TaskTemplateSousAssemblageUpsertArgs>(args: SelectSubset<T, TaskTemplateSousAssemblageUpsertArgs<ExtArgs>>): Prisma__TaskTemplateSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousAssemblagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTemplateSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageCountArgs} args - Arguments to filter TaskTemplateSousAssemblages to count.
     * @example
     * // Count the number of TaskTemplateSousAssemblages
     * const count = await prisma.taskTemplateSousAssemblage.count({
     *   where: {
     *     // ... the filter for the TaskTemplateSousAssemblages we want to count
     *   }
     * })
    **/
    count<T extends TaskTemplateSousAssemblageCountArgs>(
      args?: Subset<T, TaskTemplateSousAssemblageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTemplateSousAssemblageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTemplateSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTemplateSousAssemblageAggregateArgs>(args: Subset<T, TaskTemplateSousAssemblageAggregateArgs>): Prisma.PrismaPromise<GetTaskTemplateSousAssemblageAggregateType<T>>

    /**
     * Group by TaskTemplateSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousAssemblageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTemplateSousAssemblageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTemplateSousAssemblageGroupByArgs['orderBy'] }
        : { orderBy?: TaskTemplateSousAssemblageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTemplateSousAssemblageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTemplateSousAssemblageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTemplateSousAssemblage model
   */
  readonly fields: TaskTemplateSousAssemblageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTemplateSousAssemblage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTemplateSousAssemblageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sousAssemblage<T extends SousAssemblageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SousAssemblageDefaultArgs<ExtArgs>>): Prisma__SousAssemblageClient<$Result.GetResult<Prisma.$SousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taskTemplate<T extends TaskTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplateDefaultArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTemplateSousAssemblage model
   */
  interface TaskTemplateSousAssemblageFieldRefs {
    readonly id: FieldRef<"TaskTemplateSousAssemblage", 'Int'>
    readonly taskTemplateId: FieldRef<"TaskTemplateSousAssemblage", 'Int'>
    readonly sousAssemblageId: FieldRef<"TaskTemplateSousAssemblage", 'Int'>
    readonly quantity: FieldRef<"TaskTemplateSousAssemblage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TaskTemplateSousAssemblage findUnique
   */
  export type TaskTemplateSousAssemblageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousAssemblage to fetch.
     */
    where: TaskTemplateSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousAssemblage findUniqueOrThrow
   */
  export type TaskTemplateSousAssemblageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousAssemblage to fetch.
     */
    where: TaskTemplateSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousAssemblage findFirst
   */
  export type TaskTemplateSousAssemblageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousAssemblage to fetch.
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousAssemblageOrderByWithRelationInput | TaskTemplateSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplateSousAssemblages.
     */
    cursor?: TaskTemplateSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplateSousAssemblages.
     */
    distinct?: TaskTemplateSousAssemblageScalarFieldEnum | TaskTemplateSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplateSousAssemblage findFirstOrThrow
   */
  export type TaskTemplateSousAssemblageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousAssemblage to fetch.
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousAssemblageOrderByWithRelationInput | TaskTemplateSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplateSousAssemblages.
     */
    cursor?: TaskTemplateSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplateSousAssemblages.
     */
    distinct?: TaskTemplateSousAssemblageScalarFieldEnum | TaskTemplateSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplateSousAssemblage findMany
   */
  export type TaskTemplateSousAssemblageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousAssemblages to fetch.
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousAssemblageOrderByWithRelationInput | TaskTemplateSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTemplateSousAssemblages.
     */
    cursor?: TaskTemplateSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousAssemblages.
     */
    skip?: number
    distinct?: TaskTemplateSousAssemblageScalarFieldEnum | TaskTemplateSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplateSousAssemblage create
   */
  export type TaskTemplateSousAssemblageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTemplateSousAssemblage.
     */
    data: XOR<TaskTemplateSousAssemblageCreateInput, TaskTemplateSousAssemblageUncheckedCreateInput>
  }

  /**
   * TaskTemplateSousAssemblage createMany
   */
  export type TaskTemplateSousAssemblageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTemplateSousAssemblages.
     */
    data: TaskTemplateSousAssemblageCreateManyInput | TaskTemplateSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTemplateSousAssemblage createManyAndReturn
   */
  export type TaskTemplateSousAssemblageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTemplateSousAssemblages.
     */
    data: TaskTemplateSousAssemblageCreateManyInput | TaskTemplateSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplateSousAssemblage update
   */
  export type TaskTemplateSousAssemblageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTemplateSousAssemblage.
     */
    data: XOR<TaskTemplateSousAssemblageUpdateInput, TaskTemplateSousAssemblageUncheckedUpdateInput>
    /**
     * Choose, which TaskTemplateSousAssemblage to update.
     */
    where: TaskTemplateSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousAssemblage updateMany
   */
  export type TaskTemplateSousAssemblageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTemplateSousAssemblages.
     */
    data: XOR<TaskTemplateSousAssemblageUpdateManyMutationInput, TaskTemplateSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplateSousAssemblages to update
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * Limit how many TaskTemplateSousAssemblages to update.
     */
    limit?: number
  }

  /**
   * TaskTemplateSousAssemblage updateManyAndReturn
   */
  export type TaskTemplateSousAssemblageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to update TaskTemplateSousAssemblages.
     */
    data: XOR<TaskTemplateSousAssemblageUpdateManyMutationInput, TaskTemplateSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplateSousAssemblages to update
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * Limit how many TaskTemplateSousAssemblages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplateSousAssemblage upsert
   */
  export type TaskTemplateSousAssemblageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTemplateSousAssemblage to update in case it exists.
     */
    where: TaskTemplateSousAssemblageWhereUniqueInput
    /**
     * In case the TaskTemplateSousAssemblage found by the `where` argument doesn't exist, create a new TaskTemplateSousAssemblage with this data.
     */
    create: XOR<TaskTemplateSousAssemblageCreateInput, TaskTemplateSousAssemblageUncheckedCreateInput>
    /**
     * In case the TaskTemplateSousAssemblage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTemplateSousAssemblageUpdateInput, TaskTemplateSousAssemblageUncheckedUpdateInput>
  }

  /**
   * TaskTemplateSousAssemblage delete
   */
  export type TaskTemplateSousAssemblageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter which TaskTemplateSousAssemblage to delete.
     */
    where: TaskTemplateSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousAssemblage deleteMany
   */
  export type TaskTemplateSousAssemblageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplateSousAssemblages to delete
     */
    where?: TaskTemplateSousAssemblageWhereInput
    /**
     * Limit how many TaskTemplateSousAssemblages to delete.
     */
    limit?: number
  }

  /**
   * TaskTemplateSousAssemblage without action
   */
  export type TaskTemplateSousAssemblageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousAssemblage
     */
    select?: TaskTemplateSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousAssemblage
     */
    omit?: TaskTemplateSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousAssemblageInclude<ExtArgs> | null
  }


  /**
   * Model TaskTemplateSousSousAssemblage
   */

  export type AggregateTaskTemplateSousSousAssemblage = {
    _count: TaskTemplateSousSousAssemblageCountAggregateOutputType | null
    _avg: TaskTemplateSousSousAssemblageAvgAggregateOutputType | null
    _sum: TaskTemplateSousSousAssemblageSumAggregateOutputType | null
    _min: TaskTemplateSousSousAssemblageMinAggregateOutputType | null
    _max: TaskTemplateSousSousAssemblageMaxAggregateOutputType | null
  }

  export type TaskTemplateSousSousAssemblageAvgAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousSousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousSousAssemblageSumAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousSousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousSousAssemblageMinAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousSousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousSousAssemblageMaxAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    sousSousAssemblageId: number | null
    quantity: number | null
  }

  export type TaskTemplateSousSousAssemblageCountAggregateOutputType = {
    id: number
    taskTemplateId: number
    sousSousAssemblageId: number
    quantity: number
    _all: number
  }


  export type TaskTemplateSousSousAssemblageAvgAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousSousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousSousAssemblageSumAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousSousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousSousAssemblageMinAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousSousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousSousAssemblageMaxAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousSousAssemblageId?: true
    quantity?: true
  }

  export type TaskTemplateSousSousAssemblageCountAggregateInputType = {
    id?: true
    taskTemplateId?: true
    sousSousAssemblageId?: true
    quantity?: true
    _all?: true
  }

  export type TaskTemplateSousSousAssemblageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplateSousSousAssemblage to aggregate.
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithRelationInput | TaskTemplateSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTemplateSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTemplateSousSousAssemblages
    **/
    _count?: true | TaskTemplateSousSousAssemblageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTemplateSousSousAssemblageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTemplateSousSousAssemblageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTemplateSousSousAssemblageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTemplateSousSousAssemblageMaxAggregateInputType
  }

  export type GetTaskTemplateSousSousAssemblageAggregateType<T extends TaskTemplateSousSousAssemblageAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTemplateSousSousAssemblage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTemplateSousSousAssemblage[P]>
      : GetScalarType<T[P], AggregateTaskTemplateSousSousAssemblage[P]>
  }




  export type TaskTemplateSousSousAssemblageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateSousSousAssemblageWhereInput
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithAggregationInput | TaskTemplateSousSousAssemblageOrderByWithAggregationInput[]
    by: TaskTemplateSousSousAssemblageScalarFieldEnum[] | TaskTemplateSousSousAssemblageScalarFieldEnum
    having?: TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTemplateSousSousAssemblageCountAggregateInputType | true
    _avg?: TaskTemplateSousSousAssemblageAvgAggregateInputType
    _sum?: TaskTemplateSousSousAssemblageSumAggregateInputType
    _min?: TaskTemplateSousSousAssemblageMinAggregateInputType
    _max?: TaskTemplateSousSousAssemblageMaxAggregateInputType
  }

  export type TaskTemplateSousSousAssemblageGroupByOutputType = {
    id: number
    taskTemplateId: number
    sousSousAssemblageId: number
    quantity: number
    _count: TaskTemplateSousSousAssemblageCountAggregateOutputType | null
    _avg: TaskTemplateSousSousAssemblageAvgAggregateOutputType | null
    _sum: TaskTemplateSousSousAssemblageSumAggregateOutputType | null
    _min: TaskTemplateSousSousAssemblageMinAggregateOutputType | null
    _max: TaskTemplateSousSousAssemblageMaxAggregateOutputType | null
  }

  type GetTaskTemplateSousSousAssemblageGroupByPayload<T extends TaskTemplateSousSousAssemblageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTemplateSousSousAssemblageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTemplateSousSousAssemblageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTemplateSousSousAssemblageGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTemplateSousSousAssemblageGroupByOutputType[P]>
        }
      >
    >


  export type TaskTemplateSousSousAssemblageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    sousSousAssemblageId?: boolean
    quantity?: boolean
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateSousSousAssemblage"]>

  export type TaskTemplateSousSousAssemblageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    sousSousAssemblageId?: boolean
    quantity?: boolean
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateSousSousAssemblage"]>

  export type TaskTemplateSousSousAssemblageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    sousSousAssemblageId?: boolean
    quantity?: boolean
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateSousSousAssemblage"]>

  export type TaskTemplateSousSousAssemblageSelectScalar = {
    id?: boolean
    taskTemplateId?: boolean
    sousSousAssemblageId?: boolean
    quantity?: boolean
  }

  export type TaskTemplateSousSousAssemblageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskTemplateId" | "sousSousAssemblageId" | "quantity", ExtArgs["result"]["taskTemplateSousSousAssemblage"]>
  export type TaskTemplateSousSousAssemblageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }
  export type TaskTemplateSousSousAssemblageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }
  export type TaskTemplateSousSousAssemblageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sousSousAssemblage?: boolean | SousSousAssemblageDefaultArgs<ExtArgs>
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
  }

  export type $TaskTemplateSousSousAssemblagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTemplateSousSousAssemblage"
    objects: {
      sousSousAssemblage: Prisma.$SousSousAssemblagePayload<ExtArgs>
      taskTemplate: Prisma.$TaskTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskTemplateId: number
      sousSousAssemblageId: number
      quantity: number
    }, ExtArgs["result"]["taskTemplateSousSousAssemblage"]>
    composites: {}
  }

  type TaskTemplateSousSousAssemblageGetPayload<S extends boolean | null | undefined | TaskTemplateSousSousAssemblageDefaultArgs> = $Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload, S>

  type TaskTemplateSousSousAssemblageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTemplateSousSousAssemblageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTemplateSousSousAssemblageCountAggregateInputType | true
    }

  export interface TaskTemplateSousSousAssemblageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTemplateSousSousAssemblage'], meta: { name: 'TaskTemplateSousSousAssemblage' } }
    /**
     * Find zero or one TaskTemplateSousSousAssemblage that matches the filter.
     * @param {TaskTemplateSousSousAssemblageFindUniqueArgs} args - Arguments to find a TaskTemplateSousSousAssemblage
     * @example
     * // Get one TaskTemplateSousSousAssemblage
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTemplateSousSousAssemblageFindUniqueArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageFindUniqueArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTemplateSousSousAssemblage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTemplateSousSousAssemblageFindUniqueOrThrowArgs} args - Arguments to find a TaskTemplateSousSousAssemblage
     * @example
     * // Get one TaskTemplateSousSousAssemblage
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTemplateSousSousAssemblageFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplateSousSousAssemblage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageFindFirstArgs} args - Arguments to find a TaskTemplateSousSousAssemblage
     * @example
     * // Get one TaskTemplateSousSousAssemblage
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTemplateSousSousAssemblageFindFirstArgs>(args?: SelectSubset<T, TaskTemplateSousSousAssemblageFindFirstArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplateSousSousAssemblage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageFindFirstOrThrowArgs} args - Arguments to find a TaskTemplateSousSousAssemblage
     * @example
     * // Get one TaskTemplateSousSousAssemblage
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTemplateSousSousAssemblageFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTemplateSousSousAssemblageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTemplateSousSousAssemblages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTemplateSousSousAssemblages
     * const taskTemplateSousSousAssemblages = await prisma.taskTemplateSousSousAssemblage.findMany()
     * 
     * // Get first 10 TaskTemplateSousSousAssemblages
     * const taskTemplateSousSousAssemblages = await prisma.taskTemplateSousSousAssemblage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTemplateSousSousAssemblageWithIdOnly = await prisma.taskTemplateSousSousAssemblage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTemplateSousSousAssemblageFindManyArgs>(args?: SelectSubset<T, TaskTemplateSousSousAssemblageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTemplateSousSousAssemblage.
     * @param {TaskTemplateSousSousAssemblageCreateArgs} args - Arguments to create a TaskTemplateSousSousAssemblage.
     * @example
     * // Create one TaskTemplateSousSousAssemblage
     * const TaskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.create({
     *   data: {
     *     // ... data to create a TaskTemplateSousSousAssemblage
     *   }
     * })
     * 
     */
    create<T extends TaskTemplateSousSousAssemblageCreateArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageCreateArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTemplateSousSousAssemblages.
     * @param {TaskTemplateSousSousAssemblageCreateManyArgs} args - Arguments to create many TaskTemplateSousSousAssemblages.
     * @example
     * // Create many TaskTemplateSousSousAssemblages
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTemplateSousSousAssemblageCreateManyArgs>(args?: SelectSubset<T, TaskTemplateSousSousAssemblageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTemplateSousSousAssemblages and returns the data saved in the database.
     * @param {TaskTemplateSousSousAssemblageCreateManyAndReturnArgs} args - Arguments to create many TaskTemplateSousSousAssemblages.
     * @example
     * // Create many TaskTemplateSousSousAssemblages
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTemplateSousSousAssemblages and only return the `id`
     * const taskTemplateSousSousAssemblageWithIdOnly = await prisma.taskTemplateSousSousAssemblage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTemplateSousSousAssemblageCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTemplateSousSousAssemblageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTemplateSousSousAssemblage.
     * @param {TaskTemplateSousSousAssemblageDeleteArgs} args - Arguments to delete one TaskTemplateSousSousAssemblage.
     * @example
     * // Delete one TaskTemplateSousSousAssemblage
     * const TaskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.delete({
     *   where: {
     *     // ... filter to delete one TaskTemplateSousSousAssemblage
     *   }
     * })
     * 
     */
    delete<T extends TaskTemplateSousSousAssemblageDeleteArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageDeleteArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTemplateSousSousAssemblage.
     * @param {TaskTemplateSousSousAssemblageUpdateArgs} args - Arguments to update one TaskTemplateSousSousAssemblage.
     * @example
     * // Update one TaskTemplateSousSousAssemblage
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTemplateSousSousAssemblageUpdateArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageUpdateArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTemplateSousSousAssemblages.
     * @param {TaskTemplateSousSousAssemblageDeleteManyArgs} args - Arguments to filter TaskTemplateSousSousAssemblages to delete.
     * @example
     * // Delete a few TaskTemplateSousSousAssemblages
     * const { count } = await prisma.taskTemplateSousSousAssemblage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTemplateSousSousAssemblageDeleteManyArgs>(args?: SelectSubset<T, TaskTemplateSousSousAssemblageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplateSousSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTemplateSousSousAssemblages
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTemplateSousSousAssemblageUpdateManyArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplateSousSousAssemblages and returns the data updated in the database.
     * @param {TaskTemplateSousSousAssemblageUpdateManyAndReturnArgs} args - Arguments to update many TaskTemplateSousSousAssemblages.
     * @example
     * // Update many TaskTemplateSousSousAssemblages
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTemplateSousSousAssemblages and only return the `id`
     * const taskTemplateSousSousAssemblageWithIdOnly = await prisma.taskTemplateSousSousAssemblage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTemplateSousSousAssemblageUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTemplateSousSousAssemblage.
     * @param {TaskTemplateSousSousAssemblageUpsertArgs} args - Arguments to update or create a TaskTemplateSousSousAssemblage.
     * @example
     * // Update or create a TaskTemplateSousSousAssemblage
     * const taskTemplateSousSousAssemblage = await prisma.taskTemplateSousSousAssemblage.upsert({
     *   create: {
     *     // ... data to create a TaskTemplateSousSousAssemblage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTemplateSousSousAssemblage we want to update
     *   }
     * })
     */
    upsert<T extends TaskTemplateSousSousAssemblageUpsertArgs>(args: SelectSubset<T, TaskTemplateSousSousAssemblageUpsertArgs<ExtArgs>>): Prisma__TaskTemplateSousSousAssemblageClient<$Result.GetResult<Prisma.$TaskTemplateSousSousAssemblagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTemplateSousSousAssemblages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageCountArgs} args - Arguments to filter TaskTemplateSousSousAssemblages to count.
     * @example
     * // Count the number of TaskTemplateSousSousAssemblages
     * const count = await prisma.taskTemplateSousSousAssemblage.count({
     *   where: {
     *     // ... the filter for the TaskTemplateSousSousAssemblages we want to count
     *   }
     * })
    **/
    count<T extends TaskTemplateSousSousAssemblageCountArgs>(
      args?: Subset<T, TaskTemplateSousSousAssemblageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTemplateSousSousAssemblageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTemplateSousSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTemplateSousSousAssemblageAggregateArgs>(args: Subset<T, TaskTemplateSousSousAssemblageAggregateArgs>): Prisma.PrismaPromise<GetTaskTemplateSousSousAssemblageAggregateType<T>>

    /**
     * Group by TaskTemplateSousSousAssemblage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateSousSousAssemblageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTemplateSousSousAssemblageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTemplateSousSousAssemblageGroupByArgs['orderBy'] }
        : { orderBy?: TaskTemplateSousSousAssemblageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTemplateSousSousAssemblageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTemplateSousSousAssemblageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTemplateSousSousAssemblage model
   */
  readonly fields: TaskTemplateSousSousAssemblageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTemplateSousSousAssemblage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTemplateSousSousAssemblageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sousSousAssemblage<T extends SousSousAssemblageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SousSousAssemblageDefaultArgs<ExtArgs>>): Prisma__SousSousAssemblageClient<$Result.GetResult<Prisma.$SousSousAssemblagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taskTemplate<T extends TaskTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplateDefaultArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTemplateSousSousAssemblage model
   */
  interface TaskTemplateSousSousAssemblageFieldRefs {
    readonly id: FieldRef<"TaskTemplateSousSousAssemblage", 'Int'>
    readonly taskTemplateId: FieldRef<"TaskTemplateSousSousAssemblage", 'Int'>
    readonly sousSousAssemblageId: FieldRef<"TaskTemplateSousSousAssemblage", 'Int'>
    readonly quantity: FieldRef<"TaskTemplateSousSousAssemblage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TaskTemplateSousSousAssemblage findUnique
   */
  export type TaskTemplateSousSousAssemblageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousSousAssemblage to fetch.
     */
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousSousAssemblage findUniqueOrThrow
   */
  export type TaskTemplateSousSousAssemblageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousSousAssemblage to fetch.
     */
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousSousAssemblage findFirst
   */
  export type TaskTemplateSousSousAssemblageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousSousAssemblage to fetch.
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithRelationInput | TaskTemplateSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplateSousSousAssemblages.
     */
    cursor?: TaskTemplateSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplateSousSousAssemblages.
     */
    distinct?: TaskTemplateSousSousAssemblageScalarFieldEnum | TaskTemplateSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplateSousSousAssemblage findFirstOrThrow
   */
  export type TaskTemplateSousSousAssemblageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousSousAssemblage to fetch.
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithRelationInput | TaskTemplateSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplateSousSousAssemblages.
     */
    cursor?: TaskTemplateSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousSousAssemblages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplateSousSousAssemblages.
     */
    distinct?: TaskTemplateSousSousAssemblageScalarFieldEnum | TaskTemplateSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplateSousSousAssemblage findMany
   */
  export type TaskTemplateSousSousAssemblageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateSousSousAssemblages to fetch.
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateSousSousAssemblages to fetch.
     */
    orderBy?: TaskTemplateSousSousAssemblageOrderByWithRelationInput | TaskTemplateSousSousAssemblageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTemplateSousSousAssemblages.
     */
    cursor?: TaskTemplateSousSousAssemblageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateSousSousAssemblages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateSousSousAssemblages.
     */
    skip?: number
    distinct?: TaskTemplateSousSousAssemblageScalarFieldEnum | TaskTemplateSousSousAssemblageScalarFieldEnum[]
  }

  /**
   * TaskTemplateSousSousAssemblage create
   */
  export type TaskTemplateSousSousAssemblageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTemplateSousSousAssemblage.
     */
    data: XOR<TaskTemplateSousSousAssemblageCreateInput, TaskTemplateSousSousAssemblageUncheckedCreateInput>
  }

  /**
   * TaskTemplateSousSousAssemblage createMany
   */
  export type TaskTemplateSousSousAssemblageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTemplateSousSousAssemblages.
     */
    data: TaskTemplateSousSousAssemblageCreateManyInput | TaskTemplateSousSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTemplateSousSousAssemblage createManyAndReturn
   */
  export type TaskTemplateSousSousAssemblageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTemplateSousSousAssemblages.
     */
    data: TaskTemplateSousSousAssemblageCreateManyInput | TaskTemplateSousSousAssemblageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplateSousSousAssemblage update
   */
  export type TaskTemplateSousSousAssemblageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTemplateSousSousAssemblage.
     */
    data: XOR<TaskTemplateSousSousAssemblageUpdateInput, TaskTemplateSousSousAssemblageUncheckedUpdateInput>
    /**
     * Choose, which TaskTemplateSousSousAssemblage to update.
     */
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousSousAssemblage updateMany
   */
  export type TaskTemplateSousSousAssemblageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTemplateSousSousAssemblages.
     */
    data: XOR<TaskTemplateSousSousAssemblageUpdateManyMutationInput, TaskTemplateSousSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplateSousSousAssemblages to update
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * Limit how many TaskTemplateSousSousAssemblages to update.
     */
    limit?: number
  }

  /**
   * TaskTemplateSousSousAssemblage updateManyAndReturn
   */
  export type TaskTemplateSousSousAssemblageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * The data used to update TaskTemplateSousSousAssemblages.
     */
    data: XOR<TaskTemplateSousSousAssemblageUpdateManyMutationInput, TaskTemplateSousSousAssemblageUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplateSousSousAssemblages to update
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * Limit how many TaskTemplateSousSousAssemblages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplateSousSousAssemblage upsert
   */
  export type TaskTemplateSousSousAssemblageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTemplateSousSousAssemblage to update in case it exists.
     */
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    /**
     * In case the TaskTemplateSousSousAssemblage found by the `where` argument doesn't exist, create a new TaskTemplateSousSousAssemblage with this data.
     */
    create: XOR<TaskTemplateSousSousAssemblageCreateInput, TaskTemplateSousSousAssemblageUncheckedCreateInput>
    /**
     * In case the TaskTemplateSousSousAssemblage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTemplateSousSousAssemblageUpdateInput, TaskTemplateSousSousAssemblageUncheckedUpdateInput>
  }

  /**
   * TaskTemplateSousSousAssemblage delete
   */
  export type TaskTemplateSousSousAssemblageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
    /**
     * Filter which TaskTemplateSousSousAssemblage to delete.
     */
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
  }

  /**
   * TaskTemplateSousSousAssemblage deleteMany
   */
  export type TaskTemplateSousSousAssemblageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplateSousSousAssemblages to delete
     */
    where?: TaskTemplateSousSousAssemblageWhereInput
    /**
     * Limit how many TaskTemplateSousSousAssemblages to delete.
     */
    limit?: number
  }

  /**
   * TaskTemplateSousSousAssemblage without action
   */
  export type TaskTemplateSousSousAssemblageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateSousSousAssemblage
     */
    select?: TaskTemplateSousSousAssemblageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateSousSousAssemblage
     */
    omit?: TaskTemplateSousSousAssemblageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateSousSousAssemblageInclude<ExtArgs> | null
  }


  /**
   * Model TaskTemplateLog
   */

  export type AggregateTaskTemplateLog = {
    _count: TaskTemplateLogCountAggregateOutputType | null
    _avg: TaskTemplateLogAvgAggregateOutputType | null
    _sum: TaskTemplateLogSumAggregateOutputType | null
    _min: TaskTemplateLogMinAggregateOutputType | null
    _max: TaskTemplateLogMaxAggregateOutputType | null
  }

  export type TaskTemplateLogAvgAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    userId: number | null
  }

  export type TaskTemplateLogSumAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    userId: number | null
  }

  export type TaskTemplateLogMinAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    userId: number | null
    createdAt: Date | null
    note: string | null
    eventType: $Enums.TaskEventType | null
  }

  export type TaskTemplateLogMaxAggregateOutputType = {
    id: number | null
    taskTemplateId: number | null
    userId: number | null
    createdAt: Date | null
    note: string | null
    eventType: $Enums.TaskEventType | null
  }

  export type TaskTemplateLogCountAggregateOutputType = {
    id: number
    taskTemplateId: number
    userId: number
    createdAt: number
    note: number
    eventType: number
    _all: number
  }


  export type TaskTemplateLogAvgAggregateInputType = {
    id?: true
    taskTemplateId?: true
    userId?: true
  }

  export type TaskTemplateLogSumAggregateInputType = {
    id?: true
    taskTemplateId?: true
    userId?: true
  }

  export type TaskTemplateLogMinAggregateInputType = {
    id?: true
    taskTemplateId?: true
    userId?: true
    createdAt?: true
    note?: true
    eventType?: true
  }

  export type TaskTemplateLogMaxAggregateInputType = {
    id?: true
    taskTemplateId?: true
    userId?: true
    createdAt?: true
    note?: true
    eventType?: true
  }

  export type TaskTemplateLogCountAggregateInputType = {
    id?: true
    taskTemplateId?: true
    userId?: true
    createdAt?: true
    note?: true
    eventType?: true
    _all?: true
  }

  export type TaskTemplateLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplateLog to aggregate.
     */
    where?: TaskTemplateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateLogs to fetch.
     */
    orderBy?: TaskTemplateLogOrderByWithRelationInput | TaskTemplateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTemplateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTemplateLogs
    **/
    _count?: true | TaskTemplateLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTemplateLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTemplateLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTemplateLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTemplateLogMaxAggregateInputType
  }

  export type GetTaskTemplateLogAggregateType<T extends TaskTemplateLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTemplateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTemplateLog[P]>
      : GetScalarType<T[P], AggregateTaskTemplateLog[P]>
  }




  export type TaskTemplateLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTemplateLogWhereInput
    orderBy?: TaskTemplateLogOrderByWithAggregationInput | TaskTemplateLogOrderByWithAggregationInput[]
    by: TaskTemplateLogScalarFieldEnum[] | TaskTemplateLogScalarFieldEnum
    having?: TaskTemplateLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTemplateLogCountAggregateInputType | true
    _avg?: TaskTemplateLogAvgAggregateInputType
    _sum?: TaskTemplateLogSumAggregateInputType
    _min?: TaskTemplateLogMinAggregateInputType
    _max?: TaskTemplateLogMaxAggregateInputType
  }

  export type TaskTemplateLogGroupByOutputType = {
    id: number
    taskTemplateId: number
    userId: number | null
    createdAt: Date
    note: string | null
    eventType: $Enums.TaskEventType
    _count: TaskTemplateLogCountAggregateOutputType | null
    _avg: TaskTemplateLogAvgAggregateOutputType | null
    _sum: TaskTemplateLogSumAggregateOutputType | null
    _min: TaskTemplateLogMinAggregateOutputType | null
    _max: TaskTemplateLogMaxAggregateOutputType | null
  }

  type GetTaskTemplateLogGroupByPayload<T extends TaskTemplateLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTemplateLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTemplateLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTemplateLogGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTemplateLogGroupByOutputType[P]>
        }
      >
    >


  export type TaskTemplateLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    userId?: boolean
    createdAt?: boolean
    note?: boolean
    eventType?: boolean
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
    user?: boolean | TaskTemplateLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateLog"]>

  export type TaskTemplateLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    userId?: boolean
    createdAt?: boolean
    note?: boolean
    eventType?: boolean
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
    user?: boolean | TaskTemplateLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateLog"]>

  export type TaskTemplateLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskTemplateId?: boolean
    userId?: boolean
    createdAt?: boolean
    note?: boolean
    eventType?: boolean
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
    user?: boolean | TaskTemplateLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["taskTemplateLog"]>

  export type TaskTemplateLogSelectScalar = {
    id?: boolean
    taskTemplateId?: boolean
    userId?: boolean
    createdAt?: boolean
    note?: boolean
    eventType?: boolean
  }

  export type TaskTemplateLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskTemplateId" | "userId" | "createdAt" | "note" | "eventType", ExtArgs["result"]["taskTemplateLog"]>
  export type TaskTemplateLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
    user?: boolean | TaskTemplateLog$userArgs<ExtArgs>
  }
  export type TaskTemplateLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
    user?: boolean | TaskTemplateLog$userArgs<ExtArgs>
  }
  export type TaskTemplateLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskTemplate?: boolean | TaskTemplateDefaultArgs<ExtArgs>
    user?: boolean | TaskTemplateLog$userArgs<ExtArgs>
  }

  export type $TaskTemplateLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTemplateLog"
    objects: {
      taskTemplate: Prisma.$TaskTemplatePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskTemplateId: number
      userId: number | null
      createdAt: Date
      note: string | null
      eventType: $Enums.TaskEventType
    }, ExtArgs["result"]["taskTemplateLog"]>
    composites: {}
  }

  type TaskTemplateLogGetPayload<S extends boolean | null | undefined | TaskTemplateLogDefaultArgs> = $Result.GetResult<Prisma.$TaskTemplateLogPayload, S>

  type TaskTemplateLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTemplateLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTemplateLogCountAggregateInputType | true
    }

  export interface TaskTemplateLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTemplateLog'], meta: { name: 'TaskTemplateLog' } }
    /**
     * Find zero or one TaskTemplateLog that matches the filter.
     * @param {TaskTemplateLogFindUniqueArgs} args - Arguments to find a TaskTemplateLog
     * @example
     * // Get one TaskTemplateLog
     * const taskTemplateLog = await prisma.taskTemplateLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTemplateLogFindUniqueArgs>(args: SelectSubset<T, TaskTemplateLogFindUniqueArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTemplateLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTemplateLogFindUniqueOrThrowArgs} args - Arguments to find a TaskTemplateLog
     * @example
     * // Get one TaskTemplateLog
     * const taskTemplateLog = await prisma.taskTemplateLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTemplateLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTemplateLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplateLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogFindFirstArgs} args - Arguments to find a TaskTemplateLog
     * @example
     * // Get one TaskTemplateLog
     * const taskTemplateLog = await prisma.taskTemplateLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTemplateLogFindFirstArgs>(args?: SelectSubset<T, TaskTemplateLogFindFirstArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTemplateLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogFindFirstOrThrowArgs} args - Arguments to find a TaskTemplateLog
     * @example
     * // Get one TaskTemplateLog
     * const taskTemplateLog = await prisma.taskTemplateLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTemplateLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTemplateLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTemplateLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTemplateLogs
     * const taskTemplateLogs = await prisma.taskTemplateLog.findMany()
     * 
     * // Get first 10 TaskTemplateLogs
     * const taskTemplateLogs = await prisma.taskTemplateLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTemplateLogWithIdOnly = await prisma.taskTemplateLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTemplateLogFindManyArgs>(args?: SelectSubset<T, TaskTemplateLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTemplateLog.
     * @param {TaskTemplateLogCreateArgs} args - Arguments to create a TaskTemplateLog.
     * @example
     * // Create one TaskTemplateLog
     * const TaskTemplateLog = await prisma.taskTemplateLog.create({
     *   data: {
     *     // ... data to create a TaskTemplateLog
     *   }
     * })
     * 
     */
    create<T extends TaskTemplateLogCreateArgs>(args: SelectSubset<T, TaskTemplateLogCreateArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTemplateLogs.
     * @param {TaskTemplateLogCreateManyArgs} args - Arguments to create many TaskTemplateLogs.
     * @example
     * // Create many TaskTemplateLogs
     * const taskTemplateLog = await prisma.taskTemplateLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTemplateLogCreateManyArgs>(args?: SelectSubset<T, TaskTemplateLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTemplateLogs and returns the data saved in the database.
     * @param {TaskTemplateLogCreateManyAndReturnArgs} args - Arguments to create many TaskTemplateLogs.
     * @example
     * // Create many TaskTemplateLogs
     * const taskTemplateLog = await prisma.taskTemplateLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTemplateLogs and only return the `id`
     * const taskTemplateLogWithIdOnly = await prisma.taskTemplateLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTemplateLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTemplateLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTemplateLog.
     * @param {TaskTemplateLogDeleteArgs} args - Arguments to delete one TaskTemplateLog.
     * @example
     * // Delete one TaskTemplateLog
     * const TaskTemplateLog = await prisma.taskTemplateLog.delete({
     *   where: {
     *     // ... filter to delete one TaskTemplateLog
     *   }
     * })
     * 
     */
    delete<T extends TaskTemplateLogDeleteArgs>(args: SelectSubset<T, TaskTemplateLogDeleteArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTemplateLog.
     * @param {TaskTemplateLogUpdateArgs} args - Arguments to update one TaskTemplateLog.
     * @example
     * // Update one TaskTemplateLog
     * const taskTemplateLog = await prisma.taskTemplateLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTemplateLogUpdateArgs>(args: SelectSubset<T, TaskTemplateLogUpdateArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTemplateLogs.
     * @param {TaskTemplateLogDeleteManyArgs} args - Arguments to filter TaskTemplateLogs to delete.
     * @example
     * // Delete a few TaskTemplateLogs
     * const { count } = await prisma.taskTemplateLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTemplateLogDeleteManyArgs>(args?: SelectSubset<T, TaskTemplateLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTemplateLogs
     * const taskTemplateLog = await prisma.taskTemplateLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTemplateLogUpdateManyArgs>(args: SelectSubset<T, TaskTemplateLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTemplateLogs and returns the data updated in the database.
     * @param {TaskTemplateLogUpdateManyAndReturnArgs} args - Arguments to update many TaskTemplateLogs.
     * @example
     * // Update many TaskTemplateLogs
     * const taskTemplateLog = await prisma.taskTemplateLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTemplateLogs and only return the `id`
     * const taskTemplateLogWithIdOnly = await prisma.taskTemplateLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTemplateLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTemplateLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTemplateLog.
     * @param {TaskTemplateLogUpsertArgs} args - Arguments to update or create a TaskTemplateLog.
     * @example
     * // Update or create a TaskTemplateLog
     * const taskTemplateLog = await prisma.taskTemplateLog.upsert({
     *   create: {
     *     // ... data to create a TaskTemplateLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTemplateLog we want to update
     *   }
     * })
     */
    upsert<T extends TaskTemplateLogUpsertArgs>(args: SelectSubset<T, TaskTemplateLogUpsertArgs<ExtArgs>>): Prisma__TaskTemplateLogClient<$Result.GetResult<Prisma.$TaskTemplateLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTemplateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogCountArgs} args - Arguments to filter TaskTemplateLogs to count.
     * @example
     * // Count the number of TaskTemplateLogs
     * const count = await prisma.taskTemplateLog.count({
     *   where: {
     *     // ... the filter for the TaskTemplateLogs we want to count
     *   }
     * })
    **/
    count<T extends TaskTemplateLogCountArgs>(
      args?: Subset<T, TaskTemplateLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTemplateLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTemplateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTemplateLogAggregateArgs>(args: Subset<T, TaskTemplateLogAggregateArgs>): Prisma.PrismaPromise<GetTaskTemplateLogAggregateType<T>>

    /**
     * Group by TaskTemplateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTemplateLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTemplateLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTemplateLogGroupByArgs['orderBy'] }
        : { orderBy?: TaskTemplateLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTemplateLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTemplateLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTemplateLog model
   */
  readonly fields: TaskTemplateLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTemplateLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTemplateLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taskTemplate<T extends TaskTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplateDefaultArgs<ExtArgs>>): Prisma__TaskTemplateClient<$Result.GetResult<Prisma.$TaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends TaskTemplateLog$userArgs<ExtArgs> = {}>(args?: Subset<T, TaskTemplateLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTemplateLog model
   */
  interface TaskTemplateLogFieldRefs {
    readonly id: FieldRef<"TaskTemplateLog", 'Int'>
    readonly taskTemplateId: FieldRef<"TaskTemplateLog", 'Int'>
    readonly userId: FieldRef<"TaskTemplateLog", 'Int'>
    readonly createdAt: FieldRef<"TaskTemplateLog", 'DateTime'>
    readonly note: FieldRef<"TaskTemplateLog", 'String'>
    readonly eventType: FieldRef<"TaskTemplateLog", 'TaskEventType'>
  }
    

  // Custom InputTypes
  /**
   * TaskTemplateLog findUnique
   */
  export type TaskTemplateLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateLog to fetch.
     */
    where: TaskTemplateLogWhereUniqueInput
  }

  /**
   * TaskTemplateLog findUniqueOrThrow
   */
  export type TaskTemplateLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateLog to fetch.
     */
    where: TaskTemplateLogWhereUniqueInput
  }

  /**
   * TaskTemplateLog findFirst
   */
  export type TaskTemplateLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateLog to fetch.
     */
    where?: TaskTemplateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateLogs to fetch.
     */
    orderBy?: TaskTemplateLogOrderByWithRelationInput | TaskTemplateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplateLogs.
     */
    cursor?: TaskTemplateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplateLogs.
     */
    distinct?: TaskTemplateLogScalarFieldEnum | TaskTemplateLogScalarFieldEnum[]
  }

  /**
   * TaskTemplateLog findFirstOrThrow
   */
  export type TaskTemplateLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateLog to fetch.
     */
    where?: TaskTemplateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateLogs to fetch.
     */
    orderBy?: TaskTemplateLogOrderByWithRelationInput | TaskTemplateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTemplateLogs.
     */
    cursor?: TaskTemplateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTemplateLogs.
     */
    distinct?: TaskTemplateLogScalarFieldEnum | TaskTemplateLogScalarFieldEnum[]
  }

  /**
   * TaskTemplateLog findMany
   */
  export type TaskTemplateLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskTemplateLogs to fetch.
     */
    where?: TaskTemplateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTemplateLogs to fetch.
     */
    orderBy?: TaskTemplateLogOrderByWithRelationInput | TaskTemplateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTemplateLogs.
     */
    cursor?: TaskTemplateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTemplateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTemplateLogs.
     */
    skip?: number
    distinct?: TaskTemplateLogScalarFieldEnum | TaskTemplateLogScalarFieldEnum[]
  }

  /**
   * TaskTemplateLog create
   */
  export type TaskTemplateLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTemplateLog.
     */
    data: XOR<TaskTemplateLogCreateInput, TaskTemplateLogUncheckedCreateInput>
  }

  /**
   * TaskTemplateLog createMany
   */
  export type TaskTemplateLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTemplateLogs.
     */
    data: TaskTemplateLogCreateManyInput | TaskTemplateLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTemplateLog createManyAndReturn
   */
  export type TaskTemplateLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTemplateLogs.
     */
    data: TaskTemplateLogCreateManyInput | TaskTemplateLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplateLog update
   */
  export type TaskTemplateLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTemplateLog.
     */
    data: XOR<TaskTemplateLogUpdateInput, TaskTemplateLogUncheckedUpdateInput>
    /**
     * Choose, which TaskTemplateLog to update.
     */
    where: TaskTemplateLogWhereUniqueInput
  }

  /**
   * TaskTemplateLog updateMany
   */
  export type TaskTemplateLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTemplateLogs.
     */
    data: XOR<TaskTemplateLogUpdateManyMutationInput, TaskTemplateLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplateLogs to update
     */
    where?: TaskTemplateLogWhereInput
    /**
     * Limit how many TaskTemplateLogs to update.
     */
    limit?: number
  }

  /**
   * TaskTemplateLog updateManyAndReturn
   */
  export type TaskTemplateLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * The data used to update TaskTemplateLogs.
     */
    data: XOR<TaskTemplateLogUpdateManyMutationInput, TaskTemplateLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskTemplateLogs to update
     */
    where?: TaskTemplateLogWhereInput
    /**
     * Limit how many TaskTemplateLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTemplateLog upsert
   */
  export type TaskTemplateLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTemplateLog to update in case it exists.
     */
    where: TaskTemplateLogWhereUniqueInput
    /**
     * In case the TaskTemplateLog found by the `where` argument doesn't exist, create a new TaskTemplateLog with this data.
     */
    create: XOR<TaskTemplateLogCreateInput, TaskTemplateLogUncheckedCreateInput>
    /**
     * In case the TaskTemplateLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTemplateLogUpdateInput, TaskTemplateLogUncheckedUpdateInput>
  }

  /**
   * TaskTemplateLog delete
   */
  export type TaskTemplateLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
    /**
     * Filter which TaskTemplateLog to delete.
     */
    where: TaskTemplateLogWhereUniqueInput
  }

  /**
   * TaskTemplateLog deleteMany
   */
  export type TaskTemplateLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTemplateLogs to delete
     */
    where?: TaskTemplateLogWhereInput
    /**
     * Limit how many TaskTemplateLogs to delete.
     */
    limit?: number
  }

  /**
   * TaskTemplateLog.user
   */
  export type TaskTemplateLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TaskTemplateLog without action
   */
  export type TaskTemplateLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTemplateLog
     */
    select?: TaskTemplateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTemplateLog
     */
    omit?: TaskTemplateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTemplateLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BorneScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type BorneScalarFieldEnum = (typeof BorneScalarFieldEnum)[keyof typeof BorneScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    nom: 'nom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PieceScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    reference: 'reference',
    nombre: 'nombre',
    photo: 'photo',
    emplacement: 'emplacement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archived: 'archived',
    seuilAlerte: 'seuilAlerte',
    etat: 'etat',
    numero: 'numero',
    type: 'type',
    version: 'version'
  };

  export type PieceScalarFieldEnum = (typeof PieceScalarFieldEnum)[keyof typeof PieceScalarFieldEnum]


  export const SousAssemblageScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    reference: 'reference',
    photo: 'photo',
    emplacement: 'emplacement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archived: 'archived',
    nombre: 'nombre',
    seuilAlerte: 'seuilAlerte',
    etat: 'etat',
    numero: 'numero',
    type: 'type',
    version: 'version'
  };

  export type SousAssemblageScalarFieldEnum = (typeof SousAssemblageScalarFieldEnum)[keyof typeof SousAssemblageScalarFieldEnum]


  export const SousSousAssemblageScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    reference: 'reference',
    photo: 'photo',
    emplacement: 'emplacement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archived: 'archived',
    nombre: 'nombre',
    seuilAlerte: 'seuilAlerte',
    etat: 'etat',
    numero: 'numero',
    type: 'type',
    version: 'version'
  };

  export type SousSousAssemblageScalarFieldEnum = (typeof SousSousAssemblageScalarFieldEnum)[keyof typeof SousSousAssemblageScalarFieldEnum]


  export const KitScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    reference: 'reference',
    photo: 'photo',
    emplacement: 'emplacement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archived: 'archived',
    nombre: 'nombre',
    seuilAlerte: 'seuilAlerte',
    etat: 'etat',
    numero: 'numero',
    type: 'type',
    version: 'version'
  };

  export type KitScalarFieldEnum = (typeof KitScalarFieldEnum)[keyof typeof KitScalarFieldEnum]


  export const SousAssemblagePieceScalarFieldEnum: {
    id: 'id',
    sousAssemblageId: 'sousAssemblageId',
    pieceId: 'pieceId',
    nombre: 'nombre'
  };

  export type SousAssemblagePieceScalarFieldEnum = (typeof SousAssemblagePieceScalarFieldEnum)[keyof typeof SousAssemblagePieceScalarFieldEnum]


  export const SousSousAssemblagePieceScalarFieldEnum: {
    id: 'id',
    sousSousAssemblageId: 'sousSousAssemblageId',
    pieceId: 'pieceId',
    nombre: 'nombre'
  };

  export type SousSousAssemblagePieceScalarFieldEnum = (typeof SousSousAssemblagePieceScalarFieldEnum)[keyof typeof SousSousAssemblagePieceScalarFieldEnum]


  export const SousAssemblageSousSousAssemblageScalarFieldEnum: {
    id: 'id',
    sousAssemblageId: 'sousAssemblageId',
    sousSousAssemblageId: 'sousSousAssemblageId',
    nombre: 'nombre'
  };

  export type SousAssemblageSousSousAssemblageScalarFieldEnum = (typeof SousAssemblageSousSousAssemblageScalarFieldEnum)[keyof typeof SousAssemblageSousSousAssemblageScalarFieldEnum]


  export const KitPieceScalarFieldEnum: {
    id: 'id',
    kitId: 'kitId',
    pieceId: 'pieceId',
    nombre: 'nombre'
  };

  export type KitPieceScalarFieldEnum = (typeof KitPieceScalarFieldEnum)[keyof typeof KitPieceScalarFieldEnum]


  export const StockLogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    itemId: 'itemId',
    quantity: 'quantity',
    operation: 'operation',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type StockLogScalarFieldEnum = (typeof StockLogScalarFieldEnum)[keyof typeof StockLogScalarFieldEnum]


  export const TaskTemplateScalarFieldEnum: {
    id: 'id',
    borneId: 'borneId',
    label: 'label',
    description: 'description',
    order: 'order',
    estimatedMinutesPerUnit: 'estimatedMinutesPerUnit',
    active: 'active'
  };

  export type TaskTemplateScalarFieldEnum = (typeof TaskTemplateScalarFieldEnum)[keyof typeof TaskTemplateScalarFieldEnum]


  export const ProductionScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    reference: 'reference',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dueDate: 'dueDate'
  };

  export type ProductionScalarFieldEnum = (typeof ProductionScalarFieldEnum)[keyof typeof ProductionScalarFieldEnum]


  export const ProductionLineScalarFieldEnum: {
    id: 'id',
    productionId: 'productionId',
    borneId: 'borneId',
    quantity: 'quantity'
  };

  export type ProductionLineScalarFieldEnum = (typeof ProductionLineScalarFieldEnum)[keyof typeof ProductionLineScalarFieldEnum]


  export const ProductionTaskScalarFieldEnum: {
    id: 'id',
    productionId: 'productionId',
    taskTemplateId: 'taskTemplateId',
    label: 'label',
    description: 'description',
    isDone: 'isDone',
    totalSeconds: 'totalSeconds',
    running: 'running',
    lastStartedAt: 'lastStartedAt',
    assignedToId: 'assignedToId'
  };

  export type ProductionTaskScalarFieldEnum = (typeof ProductionTaskScalarFieldEnum)[keyof typeof ProductionTaskScalarFieldEnum]


  export const ProductionTaskLogScalarFieldEnum: {
    id: 'id',
    productionTaskId: 'productionTaskId',
    userId: 'userId',
    eventType: 'eventType',
    createdAt: 'createdAt',
    note: 'note'
  };

  export type ProductionTaskLogScalarFieldEnum = (typeof ProductionTaskLogScalarFieldEnum)[keyof typeof ProductionTaskLogScalarFieldEnum]


  export const TaskTemplatePieceScalarFieldEnum: {
    id: 'id',
    taskTemplateId: 'taskTemplateId',
    pieceId: 'pieceId',
    quantity: 'quantity'
  };

  export type TaskTemplatePieceScalarFieldEnum = (typeof TaskTemplatePieceScalarFieldEnum)[keyof typeof TaskTemplatePieceScalarFieldEnum]


  export const TaskTemplateSousAssemblageScalarFieldEnum: {
    id: 'id',
    taskTemplateId: 'taskTemplateId',
    sousAssemblageId: 'sousAssemblageId',
    quantity: 'quantity'
  };

  export type TaskTemplateSousAssemblageScalarFieldEnum = (typeof TaskTemplateSousAssemblageScalarFieldEnum)[keyof typeof TaskTemplateSousAssemblageScalarFieldEnum]


  export const TaskTemplateSousSousAssemblageScalarFieldEnum: {
    id: 'id',
    taskTemplateId: 'taskTemplateId',
    sousSousAssemblageId: 'sousSousAssemblageId',
    quantity: 'quantity'
  };

  export type TaskTemplateSousSousAssemblageScalarFieldEnum = (typeof TaskTemplateSousSousAssemblageScalarFieldEnum)[keyof typeof TaskTemplateSousSousAssemblageScalarFieldEnum]


  export const TaskTemplateLogScalarFieldEnum: {
    id: 'id',
    taskTemplateId: 'taskTemplateId',
    userId: 'userId',
    createdAt: 'createdAt',
    note: 'note',
    eventType: 'eventType'
  };

  export type TaskTemplateLogScalarFieldEnum = (typeof TaskTemplateLogScalarFieldEnum)[keyof typeof TaskTemplateLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PieceEtat'
   */
  export type EnumPieceEtatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PieceEtat'>
    


  /**
   * Reference to a field of type 'PieceEtat[]'
   */
  export type ListEnumPieceEtatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PieceEtat[]'>
    


  /**
   * Reference to a field of type 'PieceType'
   */
  export type EnumPieceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PieceType'>
    


  /**
   * Reference to a field of type 'PieceType[]'
   */
  export type ListEnumPieceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PieceType[]'>
    


  /**
   * Reference to a field of type 'StockOperation'
   */
  export type EnumStockOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockOperation'>
    


  /**
   * Reference to a field of type 'StockOperation[]'
   */
  export type ListEnumStockOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockOperation[]'>
    


  /**
   * Reference to a field of type 'ProductionStatus'
   */
  export type EnumProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionStatus'>
    


  /**
   * Reference to a field of type 'ProductionStatus[]'
   */
  export type ListEnumProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionStatus[]'>
    


  /**
   * Reference to a field of type 'TaskEventType'
   */
  export type EnumTaskEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskEventType'>
    


  /**
   * Reference to a field of type 'TaskEventType[]'
   */
  export type ListEnumTaskEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BorneWhereInput = {
    AND?: BorneWhereInput | BorneWhereInput[]
    OR?: BorneWhereInput[]
    NOT?: BorneWhereInput | BorneWhereInput[]
    id?: IntFilter<"Borne"> | number
    nom?: StringFilter<"Borne"> | string
    productionLines?: ProductionLineListRelationFilter
    taskTemplates?: TaskTemplateListRelationFilter
    kits?: KitListRelationFilter
    pieces?: PieceListRelationFilter
    sousAssemblages?: SousAssemblageListRelationFilter
    sousSousAssemblages?: SousSousAssemblageListRelationFilter
  }

  export type BorneOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    productionLines?: ProductionLineOrderByRelationAggregateInput
    taskTemplates?: TaskTemplateOrderByRelationAggregateInput
    kits?: KitOrderByRelationAggregateInput
    pieces?: PieceOrderByRelationAggregateInput
    sousAssemblages?: SousAssemblageOrderByRelationAggregateInput
    sousSousAssemblages?: SousSousAssemblageOrderByRelationAggregateInput
  }

  export type BorneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: BorneWhereInput | BorneWhereInput[]
    OR?: BorneWhereInput[]
    NOT?: BorneWhereInput | BorneWhereInput[]
    productionLines?: ProductionLineListRelationFilter
    taskTemplates?: TaskTemplateListRelationFilter
    kits?: KitListRelationFilter
    pieces?: PieceListRelationFilter
    sousAssemblages?: SousAssemblageListRelationFilter
    sousSousAssemblages?: SousSousAssemblageListRelationFilter
  }, "id" | "nom">

  export type BorneOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: BorneCountOrderByAggregateInput
    _avg?: BorneAvgOrderByAggregateInput
    _max?: BorneMaxOrderByAggregateInput
    _min?: BorneMinOrderByAggregateInput
    _sum?: BorneSumOrderByAggregateInput
  }

  export type BorneScalarWhereWithAggregatesInput = {
    AND?: BorneScalarWhereWithAggregatesInput | BorneScalarWhereWithAggregatesInput[]
    OR?: BorneScalarWhereWithAggregatesInput[]
    NOT?: BorneScalarWhereWithAggregatesInput | BorneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Borne"> | number
    nom?: StringWithAggregatesFilter<"Borne"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    nom?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    assignedTasks?: ProductionTaskListRelationFilter
    taskLogs?: ProductionTaskLogListRelationFilter
    stockLogs?: StockLogListRelationFilter
    templateLogs?: TaskTemplateLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTasks?: ProductionTaskOrderByRelationAggregateInput
    taskLogs?: ProductionTaskLogOrderByRelationAggregateInput
    stockLogs?: StockLogOrderByRelationAggregateInput
    templateLogs?: TaskTemplateLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    nom?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    assignedTasks?: ProductionTaskListRelationFilter
    taskLogs?: ProductionTaskLogListRelationFilter
    stockLogs?: StockLogListRelationFilter
    templateLogs?: TaskTemplateLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    nom?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PieceWhereInput = {
    AND?: PieceWhereInput | PieceWhereInput[]
    OR?: PieceWhereInput[]
    NOT?: PieceWhereInput | PieceWhereInput[]
    id?: IntFilter<"Piece"> | number
    nom?: StringFilter<"Piece"> | string
    reference?: StringFilter<"Piece"> | string
    nombre?: IntFilter<"Piece"> | number
    photo?: StringNullableFilter<"Piece"> | string | null
    emplacement?: StringFilter<"Piece"> | string
    createdAt?: DateTimeFilter<"Piece"> | Date | string
    updatedAt?: DateTimeFilter<"Piece"> | Date | string
    archived?: BoolFilter<"Piece"> | boolean
    seuilAlerte?: IntFilter<"Piece"> | number
    etat?: EnumPieceEtatFilter<"Piece"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"Piece"> | string | null
    type?: EnumPieceTypeFilter<"Piece"> | $Enums.PieceType
    version?: StringFilter<"Piece"> | string
    kits?: KitPieceListRelationFilter
    sousAssemblages?: SousAssemblagePieceListRelationFilter
    sousSousAssemblages?: SousSousAssemblagePieceListRelationFilter
    taskTemplatePieces?: TaskTemplatePieceListRelationFilter
    bornes?: BorneListRelationFilter
  }

  export type PieceOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    nombre?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    kits?: KitPieceOrderByRelationAggregateInput
    sousAssemblages?: SousAssemblagePieceOrderByRelationAggregateInput
    sousSousAssemblages?: SousSousAssemblagePieceOrderByRelationAggregateInput
    taskTemplatePieces?: TaskTemplatePieceOrderByRelationAggregateInput
    bornes?: BorneOrderByRelationAggregateInput
  }

  export type PieceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: PieceWhereInput | PieceWhereInput[]
    OR?: PieceWhereInput[]
    NOT?: PieceWhereInput | PieceWhereInput[]
    nom?: StringFilter<"Piece"> | string
    nombre?: IntFilter<"Piece"> | number
    photo?: StringNullableFilter<"Piece"> | string | null
    emplacement?: StringFilter<"Piece"> | string
    createdAt?: DateTimeFilter<"Piece"> | Date | string
    updatedAt?: DateTimeFilter<"Piece"> | Date | string
    archived?: BoolFilter<"Piece"> | boolean
    seuilAlerte?: IntFilter<"Piece"> | number
    etat?: EnumPieceEtatFilter<"Piece"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"Piece"> | string | null
    type?: EnumPieceTypeFilter<"Piece"> | $Enums.PieceType
    version?: StringFilter<"Piece"> | string
    kits?: KitPieceListRelationFilter
    sousAssemblages?: SousAssemblagePieceListRelationFilter
    sousSousAssemblages?: SousSousAssemblagePieceListRelationFilter
    taskTemplatePieces?: TaskTemplatePieceListRelationFilter
    bornes?: BorneListRelationFilter
  }, "id" | "reference">

  export type PieceOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    nombre?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    _count?: PieceCountOrderByAggregateInput
    _avg?: PieceAvgOrderByAggregateInput
    _max?: PieceMaxOrderByAggregateInput
    _min?: PieceMinOrderByAggregateInput
    _sum?: PieceSumOrderByAggregateInput
  }

  export type PieceScalarWhereWithAggregatesInput = {
    AND?: PieceScalarWhereWithAggregatesInput | PieceScalarWhereWithAggregatesInput[]
    OR?: PieceScalarWhereWithAggregatesInput[]
    NOT?: PieceScalarWhereWithAggregatesInput | PieceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Piece"> | number
    nom?: StringWithAggregatesFilter<"Piece"> | string
    reference?: StringWithAggregatesFilter<"Piece"> | string
    nombre?: IntWithAggregatesFilter<"Piece"> | number
    photo?: StringNullableWithAggregatesFilter<"Piece"> | string | null
    emplacement?: StringWithAggregatesFilter<"Piece"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Piece"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Piece"> | Date | string
    archived?: BoolWithAggregatesFilter<"Piece"> | boolean
    seuilAlerte?: IntWithAggregatesFilter<"Piece"> | number
    etat?: EnumPieceEtatWithAggregatesFilter<"Piece"> | $Enums.PieceEtat
    numero?: StringNullableWithAggregatesFilter<"Piece"> | string | null
    type?: EnumPieceTypeWithAggregatesFilter<"Piece"> | $Enums.PieceType
    version?: StringWithAggregatesFilter<"Piece"> | string
  }

  export type SousAssemblageWhereInput = {
    AND?: SousAssemblageWhereInput | SousAssemblageWhereInput[]
    OR?: SousAssemblageWhereInput[]
    NOT?: SousAssemblageWhereInput | SousAssemblageWhereInput[]
    id?: IntFilter<"SousAssemblage"> | number
    nom?: StringFilter<"SousAssemblage"> | string
    reference?: StringFilter<"SousAssemblage"> | string
    photo?: StringNullableFilter<"SousAssemblage"> | string | null
    emplacement?: StringFilter<"SousAssemblage"> | string
    createdAt?: DateTimeFilter<"SousAssemblage"> | Date | string
    updatedAt?: DateTimeFilter<"SousAssemblage"> | Date | string
    archived?: BoolFilter<"SousAssemblage"> | boolean
    nombre?: IntFilter<"SousAssemblage"> | number
    seuilAlerte?: IntFilter<"SousAssemblage"> | number
    etat?: EnumPieceEtatFilter<"SousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"SousAssemblage"> | string | null
    type?: EnumPieceTypeFilter<"SousAssemblage"> | $Enums.PieceType
    version?: StringFilter<"SousAssemblage"> | string
    pieces?: SousAssemblagePieceListRelationFilter
    sousSousAssemblages?: SousAssemblageSousSousAssemblageListRelationFilter
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageListRelationFilter
    bornes?: BorneListRelationFilter
  }

  export type SousAssemblageOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    pieces?: SousAssemblagePieceOrderByRelationAggregateInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageOrderByRelationAggregateInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageOrderByRelationAggregateInput
    bornes?: BorneOrderByRelationAggregateInput
  }

  export type SousAssemblageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: SousAssemblageWhereInput | SousAssemblageWhereInput[]
    OR?: SousAssemblageWhereInput[]
    NOT?: SousAssemblageWhereInput | SousAssemblageWhereInput[]
    nom?: StringFilter<"SousAssemblage"> | string
    photo?: StringNullableFilter<"SousAssemblage"> | string | null
    emplacement?: StringFilter<"SousAssemblage"> | string
    createdAt?: DateTimeFilter<"SousAssemblage"> | Date | string
    updatedAt?: DateTimeFilter<"SousAssemblage"> | Date | string
    archived?: BoolFilter<"SousAssemblage"> | boolean
    nombre?: IntFilter<"SousAssemblage"> | number
    seuilAlerte?: IntFilter<"SousAssemblage"> | number
    etat?: EnumPieceEtatFilter<"SousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"SousAssemblage"> | string | null
    type?: EnumPieceTypeFilter<"SousAssemblage"> | $Enums.PieceType
    version?: StringFilter<"SousAssemblage"> | string
    pieces?: SousAssemblagePieceListRelationFilter
    sousSousAssemblages?: SousAssemblageSousSousAssemblageListRelationFilter
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageListRelationFilter
    bornes?: BorneListRelationFilter
  }, "id" | "reference">

  export type SousAssemblageOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    _count?: SousAssemblageCountOrderByAggregateInput
    _avg?: SousAssemblageAvgOrderByAggregateInput
    _max?: SousAssemblageMaxOrderByAggregateInput
    _min?: SousAssemblageMinOrderByAggregateInput
    _sum?: SousAssemblageSumOrderByAggregateInput
  }

  export type SousAssemblageScalarWhereWithAggregatesInput = {
    AND?: SousAssemblageScalarWhereWithAggregatesInput | SousAssemblageScalarWhereWithAggregatesInput[]
    OR?: SousAssemblageScalarWhereWithAggregatesInput[]
    NOT?: SousAssemblageScalarWhereWithAggregatesInput | SousAssemblageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SousAssemblage"> | number
    nom?: StringWithAggregatesFilter<"SousAssemblage"> | string
    reference?: StringWithAggregatesFilter<"SousAssemblage"> | string
    photo?: StringNullableWithAggregatesFilter<"SousAssemblage"> | string | null
    emplacement?: StringWithAggregatesFilter<"SousAssemblage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SousAssemblage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SousAssemblage"> | Date | string
    archived?: BoolWithAggregatesFilter<"SousAssemblage"> | boolean
    nombre?: IntWithAggregatesFilter<"SousAssemblage"> | number
    seuilAlerte?: IntWithAggregatesFilter<"SousAssemblage"> | number
    etat?: EnumPieceEtatWithAggregatesFilter<"SousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableWithAggregatesFilter<"SousAssemblage"> | string | null
    type?: EnumPieceTypeWithAggregatesFilter<"SousAssemblage"> | $Enums.PieceType
    version?: StringWithAggregatesFilter<"SousAssemblage"> | string
  }

  export type SousSousAssemblageWhereInput = {
    AND?: SousSousAssemblageWhereInput | SousSousAssemblageWhereInput[]
    OR?: SousSousAssemblageWhereInput[]
    NOT?: SousSousAssemblageWhereInput | SousSousAssemblageWhereInput[]
    id?: IntFilter<"SousSousAssemblage"> | number
    nom?: StringFilter<"SousSousAssemblage"> | string
    reference?: StringFilter<"SousSousAssemblage"> | string
    photo?: StringNullableFilter<"SousSousAssemblage"> | string | null
    emplacement?: StringFilter<"SousSousAssemblage"> | string
    createdAt?: DateTimeFilter<"SousSousAssemblage"> | Date | string
    updatedAt?: DateTimeFilter<"SousSousAssemblage"> | Date | string
    archived?: BoolFilter<"SousSousAssemblage"> | boolean
    nombre?: IntFilter<"SousSousAssemblage"> | number
    seuilAlerte?: IntFilter<"SousSousAssemblage"> | number
    etat?: EnumPieceEtatFilter<"SousSousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"SousSousAssemblage"> | string | null
    type?: EnumPieceTypeFilter<"SousSousAssemblage"> | $Enums.PieceType
    version?: StringFilter<"SousSousAssemblage"> | string
    sousAssemblages?: SousAssemblageSousSousAssemblageListRelationFilter
    pieces?: SousSousAssemblagePieceListRelationFilter
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageListRelationFilter
    bornes?: BorneListRelationFilter
  }

  export type SousSousAssemblageOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    sousAssemblages?: SousAssemblageSousSousAssemblageOrderByRelationAggregateInput
    pieces?: SousSousAssemblagePieceOrderByRelationAggregateInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageOrderByRelationAggregateInput
    bornes?: BorneOrderByRelationAggregateInput
  }

  export type SousSousAssemblageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: SousSousAssemblageWhereInput | SousSousAssemblageWhereInput[]
    OR?: SousSousAssemblageWhereInput[]
    NOT?: SousSousAssemblageWhereInput | SousSousAssemblageWhereInput[]
    nom?: StringFilter<"SousSousAssemblage"> | string
    photo?: StringNullableFilter<"SousSousAssemblage"> | string | null
    emplacement?: StringFilter<"SousSousAssemblage"> | string
    createdAt?: DateTimeFilter<"SousSousAssemblage"> | Date | string
    updatedAt?: DateTimeFilter<"SousSousAssemblage"> | Date | string
    archived?: BoolFilter<"SousSousAssemblage"> | boolean
    nombre?: IntFilter<"SousSousAssemblage"> | number
    seuilAlerte?: IntFilter<"SousSousAssemblage"> | number
    etat?: EnumPieceEtatFilter<"SousSousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"SousSousAssemblage"> | string | null
    type?: EnumPieceTypeFilter<"SousSousAssemblage"> | $Enums.PieceType
    version?: StringFilter<"SousSousAssemblage"> | string
    sousAssemblages?: SousAssemblageSousSousAssemblageListRelationFilter
    pieces?: SousSousAssemblagePieceListRelationFilter
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageListRelationFilter
    bornes?: BorneListRelationFilter
  }, "id" | "reference">

  export type SousSousAssemblageOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    _count?: SousSousAssemblageCountOrderByAggregateInput
    _avg?: SousSousAssemblageAvgOrderByAggregateInput
    _max?: SousSousAssemblageMaxOrderByAggregateInput
    _min?: SousSousAssemblageMinOrderByAggregateInput
    _sum?: SousSousAssemblageSumOrderByAggregateInput
  }

  export type SousSousAssemblageScalarWhereWithAggregatesInput = {
    AND?: SousSousAssemblageScalarWhereWithAggregatesInput | SousSousAssemblageScalarWhereWithAggregatesInput[]
    OR?: SousSousAssemblageScalarWhereWithAggregatesInput[]
    NOT?: SousSousAssemblageScalarWhereWithAggregatesInput | SousSousAssemblageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SousSousAssemblage"> | number
    nom?: StringWithAggregatesFilter<"SousSousAssemblage"> | string
    reference?: StringWithAggregatesFilter<"SousSousAssemblage"> | string
    photo?: StringNullableWithAggregatesFilter<"SousSousAssemblage"> | string | null
    emplacement?: StringWithAggregatesFilter<"SousSousAssemblage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SousSousAssemblage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SousSousAssemblage"> | Date | string
    archived?: BoolWithAggregatesFilter<"SousSousAssemblage"> | boolean
    nombre?: IntWithAggregatesFilter<"SousSousAssemblage"> | number
    seuilAlerte?: IntWithAggregatesFilter<"SousSousAssemblage"> | number
    etat?: EnumPieceEtatWithAggregatesFilter<"SousSousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableWithAggregatesFilter<"SousSousAssemblage"> | string | null
    type?: EnumPieceTypeWithAggregatesFilter<"SousSousAssemblage"> | $Enums.PieceType
    version?: StringWithAggregatesFilter<"SousSousAssemblage"> | string
  }

  export type KitWhereInput = {
    AND?: KitWhereInput | KitWhereInput[]
    OR?: KitWhereInput[]
    NOT?: KitWhereInput | KitWhereInput[]
    id?: IntFilter<"Kit"> | number
    nom?: StringFilter<"Kit"> | string
    reference?: StringFilter<"Kit"> | string
    photo?: StringNullableFilter<"Kit"> | string | null
    emplacement?: StringFilter<"Kit"> | string
    createdAt?: DateTimeFilter<"Kit"> | Date | string
    updatedAt?: DateTimeFilter<"Kit"> | Date | string
    archived?: BoolFilter<"Kit"> | boolean
    nombre?: IntFilter<"Kit"> | number
    seuilAlerte?: IntFilter<"Kit"> | number
    etat?: EnumPieceEtatFilter<"Kit"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"Kit"> | string | null
    type?: EnumPieceTypeFilter<"Kit"> | $Enums.PieceType
    version?: StringFilter<"Kit"> | string
    pieces?: KitPieceListRelationFilter
    bornes?: BorneListRelationFilter
  }

  export type KitOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    pieces?: KitPieceOrderByRelationAggregateInput
    bornes?: BorneOrderByRelationAggregateInput
  }

  export type KitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: KitWhereInput | KitWhereInput[]
    OR?: KitWhereInput[]
    NOT?: KitWhereInput | KitWhereInput[]
    nom?: StringFilter<"Kit"> | string
    photo?: StringNullableFilter<"Kit"> | string | null
    emplacement?: StringFilter<"Kit"> | string
    createdAt?: DateTimeFilter<"Kit"> | Date | string
    updatedAt?: DateTimeFilter<"Kit"> | Date | string
    archived?: BoolFilter<"Kit"> | boolean
    nombre?: IntFilter<"Kit"> | number
    seuilAlerte?: IntFilter<"Kit"> | number
    etat?: EnumPieceEtatFilter<"Kit"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"Kit"> | string | null
    type?: EnumPieceTypeFilter<"Kit"> | $Enums.PieceType
    version?: StringFilter<"Kit"> | string
    pieces?: KitPieceListRelationFilter
    bornes?: BorneListRelationFilter
  }, "id" | "reference">

  export type KitOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrderInput | SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrderInput | SortOrder
    type?: SortOrder
    version?: SortOrder
    _count?: KitCountOrderByAggregateInput
    _avg?: KitAvgOrderByAggregateInput
    _max?: KitMaxOrderByAggregateInput
    _min?: KitMinOrderByAggregateInput
    _sum?: KitSumOrderByAggregateInput
  }

  export type KitScalarWhereWithAggregatesInput = {
    AND?: KitScalarWhereWithAggregatesInput | KitScalarWhereWithAggregatesInput[]
    OR?: KitScalarWhereWithAggregatesInput[]
    NOT?: KitScalarWhereWithAggregatesInput | KitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Kit"> | number
    nom?: StringWithAggregatesFilter<"Kit"> | string
    reference?: StringWithAggregatesFilter<"Kit"> | string
    photo?: StringNullableWithAggregatesFilter<"Kit"> | string | null
    emplacement?: StringWithAggregatesFilter<"Kit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Kit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kit"> | Date | string
    archived?: BoolWithAggregatesFilter<"Kit"> | boolean
    nombre?: IntWithAggregatesFilter<"Kit"> | number
    seuilAlerte?: IntWithAggregatesFilter<"Kit"> | number
    etat?: EnumPieceEtatWithAggregatesFilter<"Kit"> | $Enums.PieceEtat
    numero?: StringNullableWithAggregatesFilter<"Kit"> | string | null
    type?: EnumPieceTypeWithAggregatesFilter<"Kit"> | $Enums.PieceType
    version?: StringWithAggregatesFilter<"Kit"> | string
  }

  export type SousAssemblagePieceWhereInput = {
    AND?: SousAssemblagePieceWhereInput | SousAssemblagePieceWhereInput[]
    OR?: SousAssemblagePieceWhereInput[]
    NOT?: SousAssemblagePieceWhereInput | SousAssemblagePieceWhereInput[]
    id?: IntFilter<"SousAssemblagePiece"> | number
    sousAssemblageId?: IntFilter<"SousAssemblagePiece"> | number
    pieceId?: IntFilter<"SousAssemblagePiece"> | number
    nombre?: IntFilter<"SousAssemblagePiece"> | number
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
    sousAssemblage?: XOR<SousAssemblageScalarRelationFilter, SousAssemblageWhereInput>
  }

  export type SousAssemblagePieceOrderByWithRelationInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
    piece?: PieceOrderByWithRelationInput
    sousAssemblage?: SousAssemblageOrderByWithRelationInput
  }

  export type SousAssemblagePieceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sousAssemblageId_pieceId?: SousAssemblagePieceSousAssemblageIdPieceIdCompoundUniqueInput
    AND?: SousAssemblagePieceWhereInput | SousAssemblagePieceWhereInput[]
    OR?: SousAssemblagePieceWhereInput[]
    NOT?: SousAssemblagePieceWhereInput | SousAssemblagePieceWhereInput[]
    sousAssemblageId?: IntFilter<"SousAssemblagePiece"> | number
    pieceId?: IntFilter<"SousAssemblagePiece"> | number
    nombre?: IntFilter<"SousAssemblagePiece"> | number
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
    sousAssemblage?: XOR<SousAssemblageScalarRelationFilter, SousAssemblageWhereInput>
  }, "id" | "sousAssemblageId_pieceId">

  export type SousAssemblagePieceOrderByWithAggregationInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
    _count?: SousAssemblagePieceCountOrderByAggregateInput
    _avg?: SousAssemblagePieceAvgOrderByAggregateInput
    _max?: SousAssemblagePieceMaxOrderByAggregateInput
    _min?: SousAssemblagePieceMinOrderByAggregateInput
    _sum?: SousAssemblagePieceSumOrderByAggregateInput
  }

  export type SousAssemblagePieceScalarWhereWithAggregatesInput = {
    AND?: SousAssemblagePieceScalarWhereWithAggregatesInput | SousAssemblagePieceScalarWhereWithAggregatesInput[]
    OR?: SousAssemblagePieceScalarWhereWithAggregatesInput[]
    NOT?: SousAssemblagePieceScalarWhereWithAggregatesInput | SousAssemblagePieceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SousAssemblagePiece"> | number
    sousAssemblageId?: IntWithAggregatesFilter<"SousAssemblagePiece"> | number
    pieceId?: IntWithAggregatesFilter<"SousAssemblagePiece"> | number
    nombre?: IntWithAggregatesFilter<"SousAssemblagePiece"> | number
  }

  export type SousSousAssemblagePieceWhereInput = {
    AND?: SousSousAssemblagePieceWhereInput | SousSousAssemblagePieceWhereInput[]
    OR?: SousSousAssemblagePieceWhereInput[]
    NOT?: SousSousAssemblagePieceWhereInput | SousSousAssemblagePieceWhereInput[]
    id?: IntFilter<"SousSousAssemblagePiece"> | number
    sousSousAssemblageId?: IntFilter<"SousSousAssemblagePiece"> | number
    pieceId?: IntFilter<"SousSousAssemblagePiece"> | number
    nombre?: IntFilter<"SousSousAssemblagePiece"> | number
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
    sousSousAssemblage?: XOR<SousSousAssemblageScalarRelationFilter, SousSousAssemblageWhereInput>
  }

  export type SousSousAssemblagePieceOrderByWithRelationInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
    piece?: PieceOrderByWithRelationInput
    sousSousAssemblage?: SousSousAssemblageOrderByWithRelationInput
  }

  export type SousSousAssemblagePieceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sousSousAssemblageId_pieceId?: SousSousAssemblagePieceSousSousAssemblageIdPieceIdCompoundUniqueInput
    AND?: SousSousAssemblagePieceWhereInput | SousSousAssemblagePieceWhereInput[]
    OR?: SousSousAssemblagePieceWhereInput[]
    NOT?: SousSousAssemblagePieceWhereInput | SousSousAssemblagePieceWhereInput[]
    sousSousAssemblageId?: IntFilter<"SousSousAssemblagePiece"> | number
    pieceId?: IntFilter<"SousSousAssemblagePiece"> | number
    nombre?: IntFilter<"SousSousAssemblagePiece"> | number
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
    sousSousAssemblage?: XOR<SousSousAssemblageScalarRelationFilter, SousSousAssemblageWhereInput>
  }, "id" | "sousSousAssemblageId_pieceId">

  export type SousSousAssemblagePieceOrderByWithAggregationInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
    _count?: SousSousAssemblagePieceCountOrderByAggregateInput
    _avg?: SousSousAssemblagePieceAvgOrderByAggregateInput
    _max?: SousSousAssemblagePieceMaxOrderByAggregateInput
    _min?: SousSousAssemblagePieceMinOrderByAggregateInput
    _sum?: SousSousAssemblagePieceSumOrderByAggregateInput
  }

  export type SousSousAssemblagePieceScalarWhereWithAggregatesInput = {
    AND?: SousSousAssemblagePieceScalarWhereWithAggregatesInput | SousSousAssemblagePieceScalarWhereWithAggregatesInput[]
    OR?: SousSousAssemblagePieceScalarWhereWithAggregatesInput[]
    NOT?: SousSousAssemblagePieceScalarWhereWithAggregatesInput | SousSousAssemblagePieceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SousSousAssemblagePiece"> | number
    sousSousAssemblageId?: IntWithAggregatesFilter<"SousSousAssemblagePiece"> | number
    pieceId?: IntWithAggregatesFilter<"SousSousAssemblagePiece"> | number
    nombre?: IntWithAggregatesFilter<"SousSousAssemblagePiece"> | number
  }

  export type SousAssemblageSousSousAssemblageWhereInput = {
    AND?: SousAssemblageSousSousAssemblageWhereInput | SousAssemblageSousSousAssemblageWhereInput[]
    OR?: SousAssemblageSousSousAssemblageWhereInput[]
    NOT?: SousAssemblageSousSousAssemblageWhereInput | SousAssemblageSousSousAssemblageWhereInput[]
    id?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousAssemblageId?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousSousAssemblageId?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    nombre?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousAssemblage?: XOR<SousAssemblageScalarRelationFilter, SousAssemblageWhereInput>
    sousSousAssemblage?: XOR<SousSousAssemblageScalarRelationFilter, SousSousAssemblageWhereInput>
  }

  export type SousAssemblageSousSousAssemblageOrderByWithRelationInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
    sousAssemblage?: SousAssemblageOrderByWithRelationInput
    sousSousAssemblage?: SousSousAssemblageOrderByWithRelationInput
  }

  export type SousAssemblageSousSousAssemblageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sousAssemblageId_sousSousAssemblageId?: SousAssemblageSousSousAssemblageSousAssemblageIdSousSousAssemblageIdCompoundUniqueInput
    AND?: SousAssemblageSousSousAssemblageWhereInput | SousAssemblageSousSousAssemblageWhereInput[]
    OR?: SousAssemblageSousSousAssemblageWhereInput[]
    NOT?: SousAssemblageSousSousAssemblageWhereInput | SousAssemblageSousSousAssemblageWhereInput[]
    sousAssemblageId?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousSousAssemblageId?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    nombre?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousAssemblage?: XOR<SousAssemblageScalarRelationFilter, SousAssemblageWhereInput>
    sousSousAssemblage?: XOR<SousSousAssemblageScalarRelationFilter, SousSousAssemblageWhereInput>
  }, "id" | "sousAssemblageId_sousSousAssemblageId">

  export type SousAssemblageSousSousAssemblageOrderByWithAggregationInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
    _count?: SousAssemblageSousSousAssemblageCountOrderByAggregateInput
    _avg?: SousAssemblageSousSousAssemblageAvgOrderByAggregateInput
    _max?: SousAssemblageSousSousAssemblageMaxOrderByAggregateInput
    _min?: SousAssemblageSousSousAssemblageMinOrderByAggregateInput
    _sum?: SousAssemblageSousSousAssemblageSumOrderByAggregateInput
  }

  export type SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput = {
    AND?: SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput | SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput[]
    OR?: SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput[]
    NOT?: SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput | SousAssemblageSousSousAssemblageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SousAssemblageSousSousAssemblage"> | number
    sousAssemblageId?: IntWithAggregatesFilter<"SousAssemblageSousSousAssemblage"> | number
    sousSousAssemblageId?: IntWithAggregatesFilter<"SousAssemblageSousSousAssemblage"> | number
    nombre?: IntWithAggregatesFilter<"SousAssemblageSousSousAssemblage"> | number
  }

  export type KitPieceWhereInput = {
    AND?: KitPieceWhereInput | KitPieceWhereInput[]
    OR?: KitPieceWhereInput[]
    NOT?: KitPieceWhereInput | KitPieceWhereInput[]
    id?: IntFilter<"KitPiece"> | number
    kitId?: IntFilter<"KitPiece"> | number
    pieceId?: IntFilter<"KitPiece"> | number
    nombre?: IntFilter<"KitPiece"> | number
    kit?: XOR<KitScalarRelationFilter, KitWhereInput>
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
  }

  export type KitPieceOrderByWithRelationInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
    kit?: KitOrderByWithRelationInput
    piece?: PieceOrderByWithRelationInput
  }

  export type KitPieceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kitId_pieceId?: KitPieceKitIdPieceIdCompoundUniqueInput
    AND?: KitPieceWhereInput | KitPieceWhereInput[]
    OR?: KitPieceWhereInput[]
    NOT?: KitPieceWhereInput | KitPieceWhereInput[]
    kitId?: IntFilter<"KitPiece"> | number
    pieceId?: IntFilter<"KitPiece"> | number
    nombre?: IntFilter<"KitPiece"> | number
    kit?: XOR<KitScalarRelationFilter, KitWhereInput>
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
  }, "id" | "kitId_pieceId">

  export type KitPieceOrderByWithAggregationInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
    _count?: KitPieceCountOrderByAggregateInput
    _avg?: KitPieceAvgOrderByAggregateInput
    _max?: KitPieceMaxOrderByAggregateInput
    _min?: KitPieceMinOrderByAggregateInput
    _sum?: KitPieceSumOrderByAggregateInput
  }

  export type KitPieceScalarWhereWithAggregatesInput = {
    AND?: KitPieceScalarWhereWithAggregatesInput | KitPieceScalarWhereWithAggregatesInput[]
    OR?: KitPieceScalarWhereWithAggregatesInput[]
    NOT?: KitPieceScalarWhereWithAggregatesInput | KitPieceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KitPiece"> | number
    kitId?: IntWithAggregatesFilter<"KitPiece"> | number
    pieceId?: IntWithAggregatesFilter<"KitPiece"> | number
    nombre?: IntWithAggregatesFilter<"KitPiece"> | number
  }

  export type StockLogWhereInput = {
    AND?: StockLogWhereInput | StockLogWhereInput[]
    OR?: StockLogWhereInput[]
    NOT?: StockLogWhereInput | StockLogWhereInput[]
    id?: IntFilter<"StockLog"> | number
    type?: StringFilter<"StockLog"> | string
    itemId?: IntFilter<"StockLog"> | number
    quantity?: IntFilter<"StockLog"> | number
    operation?: EnumStockOperationFilter<"StockLog"> | $Enums.StockOperation
    createdAt?: DateTimeFilter<"StockLog"> | Date | string
    userId?: IntNullableFilter<"StockLog"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StockLogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StockLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockLogWhereInput | StockLogWhereInput[]
    OR?: StockLogWhereInput[]
    NOT?: StockLogWhereInput | StockLogWhereInput[]
    type?: StringFilter<"StockLog"> | string
    itemId?: IntFilter<"StockLog"> | number
    quantity?: IntFilter<"StockLog"> | number
    operation?: EnumStockOperationFilter<"StockLog"> | $Enums.StockOperation
    createdAt?: DateTimeFilter<"StockLog"> | Date | string
    userId?: IntNullableFilter<"StockLog"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type StockLogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: StockLogCountOrderByAggregateInput
    _avg?: StockLogAvgOrderByAggregateInput
    _max?: StockLogMaxOrderByAggregateInput
    _min?: StockLogMinOrderByAggregateInput
    _sum?: StockLogSumOrderByAggregateInput
  }

  export type StockLogScalarWhereWithAggregatesInput = {
    AND?: StockLogScalarWhereWithAggregatesInput | StockLogScalarWhereWithAggregatesInput[]
    OR?: StockLogScalarWhereWithAggregatesInput[]
    NOT?: StockLogScalarWhereWithAggregatesInput | StockLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockLog"> | number
    type?: StringWithAggregatesFilter<"StockLog"> | string
    itemId?: IntWithAggregatesFilter<"StockLog"> | number
    quantity?: IntWithAggregatesFilter<"StockLog"> | number
    operation?: EnumStockOperationWithAggregatesFilter<"StockLog"> | $Enums.StockOperation
    createdAt?: DateTimeWithAggregatesFilter<"StockLog"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"StockLog"> | number | null
  }

  export type TaskTemplateWhereInput = {
    AND?: TaskTemplateWhereInput | TaskTemplateWhereInput[]
    OR?: TaskTemplateWhereInput[]
    NOT?: TaskTemplateWhereInput | TaskTemplateWhereInput[]
    id?: IntFilter<"TaskTemplate"> | number
    borneId?: IntNullableFilter<"TaskTemplate"> | number | null
    label?: StringFilter<"TaskTemplate"> | string
    description?: StringNullableFilter<"TaskTemplate"> | string | null
    order?: IntNullableFilter<"TaskTemplate"> | number | null
    estimatedMinutesPerUnit?: IntNullableFilter<"TaskTemplate"> | number | null
    active?: BoolFilter<"TaskTemplate"> | boolean
    productionTasks?: ProductionTaskListRelationFilter
    borne?: XOR<BorneNullableScalarRelationFilter, BorneWhereInput> | null
    logs?: TaskTemplateLogListRelationFilter
    pieces?: TaskTemplatePieceListRelationFilter
    sousAssemblages?: TaskTemplateSousAssemblageListRelationFilter
    sousSousAssemblages?: TaskTemplateSousSousAssemblageListRelationFilter
  }

  export type TaskTemplateOrderByWithRelationInput = {
    id?: SortOrder
    borneId?: SortOrderInput | SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    estimatedMinutesPerUnit?: SortOrderInput | SortOrder
    active?: SortOrder
    productionTasks?: ProductionTaskOrderByRelationAggregateInput
    borne?: BorneOrderByWithRelationInput
    logs?: TaskTemplateLogOrderByRelationAggregateInput
    pieces?: TaskTemplatePieceOrderByRelationAggregateInput
    sousAssemblages?: TaskTemplateSousAssemblageOrderByRelationAggregateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageOrderByRelationAggregateInput
  }

  export type TaskTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskTemplateWhereInput | TaskTemplateWhereInput[]
    OR?: TaskTemplateWhereInput[]
    NOT?: TaskTemplateWhereInput | TaskTemplateWhereInput[]
    borneId?: IntNullableFilter<"TaskTemplate"> | number | null
    label?: StringFilter<"TaskTemplate"> | string
    description?: StringNullableFilter<"TaskTemplate"> | string | null
    order?: IntNullableFilter<"TaskTemplate"> | number | null
    estimatedMinutesPerUnit?: IntNullableFilter<"TaskTemplate"> | number | null
    active?: BoolFilter<"TaskTemplate"> | boolean
    productionTasks?: ProductionTaskListRelationFilter
    borne?: XOR<BorneNullableScalarRelationFilter, BorneWhereInput> | null
    logs?: TaskTemplateLogListRelationFilter
    pieces?: TaskTemplatePieceListRelationFilter
    sousAssemblages?: TaskTemplateSousAssemblageListRelationFilter
    sousSousAssemblages?: TaskTemplateSousSousAssemblageListRelationFilter
  }, "id">

  export type TaskTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    borneId?: SortOrderInput | SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    estimatedMinutesPerUnit?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: TaskTemplateCountOrderByAggregateInput
    _avg?: TaskTemplateAvgOrderByAggregateInput
    _max?: TaskTemplateMaxOrderByAggregateInput
    _min?: TaskTemplateMinOrderByAggregateInput
    _sum?: TaskTemplateSumOrderByAggregateInput
  }

  export type TaskTemplateScalarWhereWithAggregatesInput = {
    AND?: TaskTemplateScalarWhereWithAggregatesInput | TaskTemplateScalarWhereWithAggregatesInput[]
    OR?: TaskTemplateScalarWhereWithAggregatesInput[]
    NOT?: TaskTemplateScalarWhereWithAggregatesInput | TaskTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskTemplate"> | number
    borneId?: IntNullableWithAggregatesFilter<"TaskTemplate"> | number | null
    label?: StringWithAggregatesFilter<"TaskTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"TaskTemplate"> | string | null
    order?: IntNullableWithAggregatesFilter<"TaskTemplate"> | number | null
    estimatedMinutesPerUnit?: IntNullableWithAggregatesFilter<"TaskTemplate"> | number | null
    active?: BoolWithAggregatesFilter<"TaskTemplate"> | boolean
  }

  export type ProductionWhereInput = {
    AND?: ProductionWhereInput | ProductionWhereInput[]
    OR?: ProductionWhereInput[]
    NOT?: ProductionWhereInput | ProductionWhereInput[]
    id?: IntFilter<"Production"> | number
    nom?: StringFilter<"Production"> | string
    reference?: StringNullableFilter<"Production"> | string | null
    description?: StringNullableFilter<"Production"> | string | null
    status?: EnumProductionStatusFilter<"Production"> | $Enums.ProductionStatus
    createdAt?: DateTimeFilter<"Production"> | Date | string
    updatedAt?: DateTimeFilter<"Production"> | Date | string
    dueDate?: DateTimeNullableFilter<"Production"> | Date | string | null
    lines?: ProductionLineListRelationFilter
    tasks?: ProductionTaskListRelationFilter
  }

  export type ProductionOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    lines?: ProductionLineOrderByRelationAggregateInput
    tasks?: ProductionTaskOrderByRelationAggregateInput
  }

  export type ProductionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: ProductionWhereInput | ProductionWhereInput[]
    OR?: ProductionWhereInput[]
    NOT?: ProductionWhereInput | ProductionWhereInput[]
    nom?: StringFilter<"Production"> | string
    description?: StringNullableFilter<"Production"> | string | null
    status?: EnumProductionStatusFilter<"Production"> | $Enums.ProductionStatus
    createdAt?: DateTimeFilter<"Production"> | Date | string
    updatedAt?: DateTimeFilter<"Production"> | Date | string
    dueDate?: DateTimeNullableFilter<"Production"> | Date | string | null
    lines?: ProductionLineListRelationFilter
    tasks?: ProductionTaskListRelationFilter
  }, "id" | "reference">

  export type ProductionOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    _count?: ProductionCountOrderByAggregateInput
    _avg?: ProductionAvgOrderByAggregateInput
    _max?: ProductionMaxOrderByAggregateInput
    _min?: ProductionMinOrderByAggregateInput
    _sum?: ProductionSumOrderByAggregateInput
  }

  export type ProductionScalarWhereWithAggregatesInput = {
    AND?: ProductionScalarWhereWithAggregatesInput | ProductionScalarWhereWithAggregatesInput[]
    OR?: ProductionScalarWhereWithAggregatesInput[]
    NOT?: ProductionScalarWhereWithAggregatesInput | ProductionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Production"> | number
    nom?: StringWithAggregatesFilter<"Production"> | string
    reference?: StringNullableWithAggregatesFilter<"Production"> | string | null
    description?: StringNullableWithAggregatesFilter<"Production"> | string | null
    status?: EnumProductionStatusWithAggregatesFilter<"Production"> | $Enums.ProductionStatus
    createdAt?: DateTimeWithAggregatesFilter<"Production"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Production"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Production"> | Date | string | null
  }

  export type ProductionLineWhereInput = {
    AND?: ProductionLineWhereInput | ProductionLineWhereInput[]
    OR?: ProductionLineWhereInput[]
    NOT?: ProductionLineWhereInput | ProductionLineWhereInput[]
    id?: IntFilter<"ProductionLine"> | number
    productionId?: IntFilter<"ProductionLine"> | number
    borneId?: IntFilter<"ProductionLine"> | number
    quantity?: IntFilter<"ProductionLine"> | number
    borne?: XOR<BorneScalarRelationFilter, BorneWhereInput>
    production?: XOR<ProductionScalarRelationFilter, ProductionWhereInput>
  }

  export type ProductionLineOrderByWithRelationInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
    borne?: BorneOrderByWithRelationInput
    production?: ProductionOrderByWithRelationInput
  }

  export type ProductionLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionLineWhereInput | ProductionLineWhereInput[]
    OR?: ProductionLineWhereInput[]
    NOT?: ProductionLineWhereInput | ProductionLineWhereInput[]
    productionId?: IntFilter<"ProductionLine"> | number
    borneId?: IntFilter<"ProductionLine"> | number
    quantity?: IntFilter<"ProductionLine"> | number
    borne?: XOR<BorneScalarRelationFilter, BorneWhereInput>
    production?: XOR<ProductionScalarRelationFilter, ProductionWhereInput>
  }, "id">

  export type ProductionLineOrderByWithAggregationInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
    _count?: ProductionLineCountOrderByAggregateInput
    _avg?: ProductionLineAvgOrderByAggregateInput
    _max?: ProductionLineMaxOrderByAggregateInput
    _min?: ProductionLineMinOrderByAggregateInput
    _sum?: ProductionLineSumOrderByAggregateInput
  }

  export type ProductionLineScalarWhereWithAggregatesInput = {
    AND?: ProductionLineScalarWhereWithAggregatesInput | ProductionLineScalarWhereWithAggregatesInput[]
    OR?: ProductionLineScalarWhereWithAggregatesInput[]
    NOT?: ProductionLineScalarWhereWithAggregatesInput | ProductionLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionLine"> | number
    productionId?: IntWithAggregatesFilter<"ProductionLine"> | number
    borneId?: IntWithAggregatesFilter<"ProductionLine"> | number
    quantity?: IntWithAggregatesFilter<"ProductionLine"> | number
  }

  export type ProductionTaskWhereInput = {
    AND?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    OR?: ProductionTaskWhereInput[]
    NOT?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    id?: IntFilter<"ProductionTask"> | number
    productionId?: IntFilter<"ProductionTask"> | number
    taskTemplateId?: IntNullableFilter<"ProductionTask"> | number | null
    label?: StringFilter<"ProductionTask"> | string
    description?: StringNullableFilter<"ProductionTask"> | string | null
    isDone?: BoolFilter<"ProductionTask"> | boolean
    totalSeconds?: IntFilter<"ProductionTask"> | number
    running?: BoolFilter<"ProductionTask"> | boolean
    lastStartedAt?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    assignedToId?: IntNullableFilter<"ProductionTask"> | number | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    production?: XOR<ProductionScalarRelationFilter, ProductionWhereInput>
    template?: XOR<TaskTemplateNullableScalarRelationFilter, TaskTemplateWhereInput> | null
    logs?: ProductionTaskLogListRelationFilter
  }

  export type ProductionTaskOrderByWithRelationInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrderInput | SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    isDone?: SortOrder
    totalSeconds?: SortOrder
    running?: SortOrder
    lastStartedAt?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedTo?: UserOrderByWithRelationInput
    production?: ProductionOrderByWithRelationInput
    template?: TaskTemplateOrderByWithRelationInput
    logs?: ProductionTaskLogOrderByRelationAggregateInput
  }

  export type ProductionTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    OR?: ProductionTaskWhereInput[]
    NOT?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    productionId?: IntFilter<"ProductionTask"> | number
    taskTemplateId?: IntNullableFilter<"ProductionTask"> | number | null
    label?: StringFilter<"ProductionTask"> | string
    description?: StringNullableFilter<"ProductionTask"> | string | null
    isDone?: BoolFilter<"ProductionTask"> | boolean
    totalSeconds?: IntFilter<"ProductionTask"> | number
    running?: BoolFilter<"ProductionTask"> | boolean
    lastStartedAt?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    assignedToId?: IntNullableFilter<"ProductionTask"> | number | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    production?: XOR<ProductionScalarRelationFilter, ProductionWhereInput>
    template?: XOR<TaskTemplateNullableScalarRelationFilter, TaskTemplateWhereInput> | null
    logs?: ProductionTaskLogListRelationFilter
  }, "id">

  export type ProductionTaskOrderByWithAggregationInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrderInput | SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    isDone?: SortOrder
    totalSeconds?: SortOrder
    running?: SortOrder
    lastStartedAt?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    _count?: ProductionTaskCountOrderByAggregateInput
    _avg?: ProductionTaskAvgOrderByAggregateInput
    _max?: ProductionTaskMaxOrderByAggregateInput
    _min?: ProductionTaskMinOrderByAggregateInput
    _sum?: ProductionTaskSumOrderByAggregateInput
  }

  export type ProductionTaskScalarWhereWithAggregatesInput = {
    AND?: ProductionTaskScalarWhereWithAggregatesInput | ProductionTaskScalarWhereWithAggregatesInput[]
    OR?: ProductionTaskScalarWhereWithAggregatesInput[]
    NOT?: ProductionTaskScalarWhereWithAggregatesInput | ProductionTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionTask"> | number
    productionId?: IntWithAggregatesFilter<"ProductionTask"> | number
    taskTemplateId?: IntNullableWithAggregatesFilter<"ProductionTask"> | number | null
    label?: StringWithAggregatesFilter<"ProductionTask"> | string
    description?: StringNullableWithAggregatesFilter<"ProductionTask"> | string | null
    isDone?: BoolWithAggregatesFilter<"ProductionTask"> | boolean
    totalSeconds?: IntWithAggregatesFilter<"ProductionTask"> | number
    running?: BoolWithAggregatesFilter<"ProductionTask"> | boolean
    lastStartedAt?: DateTimeNullableWithAggregatesFilter<"ProductionTask"> | Date | string | null
    assignedToId?: IntNullableWithAggregatesFilter<"ProductionTask"> | number | null
  }

  export type ProductionTaskLogWhereInput = {
    AND?: ProductionTaskLogWhereInput | ProductionTaskLogWhereInput[]
    OR?: ProductionTaskLogWhereInput[]
    NOT?: ProductionTaskLogWhereInput | ProductionTaskLogWhereInput[]
    id?: IntFilter<"ProductionTaskLog"> | number
    productionTaskId?: IntFilter<"ProductionTaskLog"> | number
    userId?: IntNullableFilter<"ProductionTaskLog"> | number | null
    eventType?: EnumTaskEventTypeFilter<"ProductionTaskLog"> | $Enums.TaskEventType
    createdAt?: DateTimeFilter<"ProductionTaskLog"> | Date | string
    note?: StringNullableFilter<"ProductionTaskLog"> | string | null
    productionTask?: XOR<ProductionTaskScalarRelationFilter, ProductionTaskWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProductionTaskLogOrderByWithRelationInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    note?: SortOrderInput | SortOrder
    productionTask?: ProductionTaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProductionTaskLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductionTaskLogWhereInput | ProductionTaskLogWhereInput[]
    OR?: ProductionTaskLogWhereInput[]
    NOT?: ProductionTaskLogWhereInput | ProductionTaskLogWhereInput[]
    productionTaskId?: IntFilter<"ProductionTaskLog"> | number
    userId?: IntNullableFilter<"ProductionTaskLog"> | number | null
    eventType?: EnumTaskEventTypeFilter<"ProductionTaskLog"> | $Enums.TaskEventType
    createdAt?: DateTimeFilter<"ProductionTaskLog"> | Date | string
    note?: StringNullableFilter<"ProductionTaskLog"> | string | null
    productionTask?: XOR<ProductionTaskScalarRelationFilter, ProductionTaskWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProductionTaskLogOrderByWithAggregationInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: ProductionTaskLogCountOrderByAggregateInput
    _avg?: ProductionTaskLogAvgOrderByAggregateInput
    _max?: ProductionTaskLogMaxOrderByAggregateInput
    _min?: ProductionTaskLogMinOrderByAggregateInput
    _sum?: ProductionTaskLogSumOrderByAggregateInput
  }

  export type ProductionTaskLogScalarWhereWithAggregatesInput = {
    AND?: ProductionTaskLogScalarWhereWithAggregatesInput | ProductionTaskLogScalarWhereWithAggregatesInput[]
    OR?: ProductionTaskLogScalarWhereWithAggregatesInput[]
    NOT?: ProductionTaskLogScalarWhereWithAggregatesInput | ProductionTaskLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionTaskLog"> | number
    productionTaskId?: IntWithAggregatesFilter<"ProductionTaskLog"> | number
    userId?: IntNullableWithAggregatesFilter<"ProductionTaskLog"> | number | null
    eventType?: EnumTaskEventTypeWithAggregatesFilter<"ProductionTaskLog"> | $Enums.TaskEventType
    createdAt?: DateTimeWithAggregatesFilter<"ProductionTaskLog"> | Date | string
    note?: StringNullableWithAggregatesFilter<"ProductionTaskLog"> | string | null
  }

  export type TaskTemplatePieceWhereInput = {
    AND?: TaskTemplatePieceWhereInput | TaskTemplatePieceWhereInput[]
    OR?: TaskTemplatePieceWhereInput[]
    NOT?: TaskTemplatePieceWhereInput | TaskTemplatePieceWhereInput[]
    id?: IntFilter<"TaskTemplatePiece"> | number
    taskTemplateId?: IntFilter<"TaskTemplatePiece"> | number
    pieceId?: IntFilter<"TaskTemplatePiece"> | number
    quantity?: IntFilter<"TaskTemplatePiece"> | number
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
  }

  export type TaskTemplatePieceOrderByWithRelationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
    piece?: PieceOrderByWithRelationInput
    taskTemplate?: TaskTemplateOrderByWithRelationInput
  }

  export type TaskTemplatePieceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskTemplateId_pieceId?: TaskTemplatePieceTaskTemplateIdPieceIdCompoundUniqueInput
    AND?: TaskTemplatePieceWhereInput | TaskTemplatePieceWhereInput[]
    OR?: TaskTemplatePieceWhereInput[]
    NOT?: TaskTemplatePieceWhereInput | TaskTemplatePieceWhereInput[]
    taskTemplateId?: IntFilter<"TaskTemplatePiece"> | number
    pieceId?: IntFilter<"TaskTemplatePiece"> | number
    quantity?: IntFilter<"TaskTemplatePiece"> | number
    piece?: XOR<PieceScalarRelationFilter, PieceWhereInput>
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
  }, "id" | "taskTemplateId_pieceId">

  export type TaskTemplatePieceOrderByWithAggregationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
    _count?: TaskTemplatePieceCountOrderByAggregateInput
    _avg?: TaskTemplatePieceAvgOrderByAggregateInput
    _max?: TaskTemplatePieceMaxOrderByAggregateInput
    _min?: TaskTemplatePieceMinOrderByAggregateInput
    _sum?: TaskTemplatePieceSumOrderByAggregateInput
  }

  export type TaskTemplatePieceScalarWhereWithAggregatesInput = {
    AND?: TaskTemplatePieceScalarWhereWithAggregatesInput | TaskTemplatePieceScalarWhereWithAggregatesInput[]
    OR?: TaskTemplatePieceScalarWhereWithAggregatesInput[]
    NOT?: TaskTemplatePieceScalarWhereWithAggregatesInput | TaskTemplatePieceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskTemplatePiece"> | number
    taskTemplateId?: IntWithAggregatesFilter<"TaskTemplatePiece"> | number
    pieceId?: IntWithAggregatesFilter<"TaskTemplatePiece"> | number
    quantity?: IntWithAggregatesFilter<"TaskTemplatePiece"> | number
  }

  export type TaskTemplateSousAssemblageWhereInput = {
    AND?: TaskTemplateSousAssemblageWhereInput | TaskTemplateSousAssemblageWhereInput[]
    OR?: TaskTemplateSousAssemblageWhereInput[]
    NOT?: TaskTemplateSousAssemblageWhereInput | TaskTemplateSousAssemblageWhereInput[]
    id?: IntFilter<"TaskTemplateSousAssemblage"> | number
    taskTemplateId?: IntFilter<"TaskTemplateSousAssemblage"> | number
    sousAssemblageId?: IntFilter<"TaskTemplateSousAssemblage"> | number
    quantity?: IntFilter<"TaskTemplateSousAssemblage"> | number
    sousAssemblage?: XOR<SousAssemblageScalarRelationFilter, SousAssemblageWhereInput>
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
  }

  export type TaskTemplateSousAssemblageOrderByWithRelationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
    sousAssemblage?: SousAssemblageOrderByWithRelationInput
    taskTemplate?: TaskTemplateOrderByWithRelationInput
  }

  export type TaskTemplateSousAssemblageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskTemplateId_sousAssemblageId?: TaskTemplateSousAssemblageTaskTemplateIdSousAssemblageIdCompoundUniqueInput
    AND?: TaskTemplateSousAssemblageWhereInput | TaskTemplateSousAssemblageWhereInput[]
    OR?: TaskTemplateSousAssemblageWhereInput[]
    NOT?: TaskTemplateSousAssemblageWhereInput | TaskTemplateSousAssemblageWhereInput[]
    taskTemplateId?: IntFilter<"TaskTemplateSousAssemblage"> | number
    sousAssemblageId?: IntFilter<"TaskTemplateSousAssemblage"> | number
    quantity?: IntFilter<"TaskTemplateSousAssemblage"> | number
    sousAssemblage?: XOR<SousAssemblageScalarRelationFilter, SousAssemblageWhereInput>
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
  }, "id" | "taskTemplateId_sousAssemblageId">

  export type TaskTemplateSousAssemblageOrderByWithAggregationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
    _count?: TaskTemplateSousAssemblageCountOrderByAggregateInput
    _avg?: TaskTemplateSousAssemblageAvgOrderByAggregateInput
    _max?: TaskTemplateSousAssemblageMaxOrderByAggregateInput
    _min?: TaskTemplateSousAssemblageMinOrderByAggregateInput
    _sum?: TaskTemplateSousAssemblageSumOrderByAggregateInput
  }

  export type TaskTemplateSousAssemblageScalarWhereWithAggregatesInput = {
    AND?: TaskTemplateSousAssemblageScalarWhereWithAggregatesInput | TaskTemplateSousAssemblageScalarWhereWithAggregatesInput[]
    OR?: TaskTemplateSousAssemblageScalarWhereWithAggregatesInput[]
    NOT?: TaskTemplateSousAssemblageScalarWhereWithAggregatesInput | TaskTemplateSousAssemblageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskTemplateSousAssemblage"> | number
    taskTemplateId?: IntWithAggregatesFilter<"TaskTemplateSousAssemblage"> | number
    sousAssemblageId?: IntWithAggregatesFilter<"TaskTemplateSousAssemblage"> | number
    quantity?: IntWithAggregatesFilter<"TaskTemplateSousAssemblage"> | number
  }

  export type TaskTemplateSousSousAssemblageWhereInput = {
    AND?: TaskTemplateSousSousAssemblageWhereInput | TaskTemplateSousSousAssemblageWhereInput[]
    OR?: TaskTemplateSousSousAssemblageWhereInput[]
    NOT?: TaskTemplateSousSousAssemblageWhereInput | TaskTemplateSousSousAssemblageWhereInput[]
    id?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    taskTemplateId?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    sousSousAssemblageId?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    quantity?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    sousSousAssemblage?: XOR<SousSousAssemblageScalarRelationFilter, SousSousAssemblageWhereInput>
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
  }

  export type TaskTemplateSousSousAssemblageOrderByWithRelationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
    sousSousAssemblage?: SousSousAssemblageOrderByWithRelationInput
    taskTemplate?: TaskTemplateOrderByWithRelationInput
  }

  export type TaskTemplateSousSousAssemblageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskTemplateId_sousSousAssemblageId?: TaskTemplateSousSousAssemblageTaskTemplateIdSousSousAssemblageIdCompoundUniqueInput
    AND?: TaskTemplateSousSousAssemblageWhereInput | TaskTemplateSousSousAssemblageWhereInput[]
    OR?: TaskTemplateSousSousAssemblageWhereInput[]
    NOT?: TaskTemplateSousSousAssemblageWhereInput | TaskTemplateSousSousAssemblageWhereInput[]
    taskTemplateId?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    sousSousAssemblageId?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    quantity?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    sousSousAssemblage?: XOR<SousSousAssemblageScalarRelationFilter, SousSousAssemblageWhereInput>
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
  }, "id" | "taskTemplateId_sousSousAssemblageId">

  export type TaskTemplateSousSousAssemblageOrderByWithAggregationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
    _count?: TaskTemplateSousSousAssemblageCountOrderByAggregateInput
    _avg?: TaskTemplateSousSousAssemblageAvgOrderByAggregateInput
    _max?: TaskTemplateSousSousAssemblageMaxOrderByAggregateInput
    _min?: TaskTemplateSousSousAssemblageMinOrderByAggregateInput
    _sum?: TaskTemplateSousSousAssemblageSumOrderByAggregateInput
  }

  export type TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput = {
    AND?: TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput | TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput[]
    OR?: TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput[]
    NOT?: TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput | TaskTemplateSousSousAssemblageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskTemplateSousSousAssemblage"> | number
    taskTemplateId?: IntWithAggregatesFilter<"TaskTemplateSousSousAssemblage"> | number
    sousSousAssemblageId?: IntWithAggregatesFilter<"TaskTemplateSousSousAssemblage"> | number
    quantity?: IntWithAggregatesFilter<"TaskTemplateSousSousAssemblage"> | number
  }

  export type TaskTemplateLogWhereInput = {
    AND?: TaskTemplateLogWhereInput | TaskTemplateLogWhereInput[]
    OR?: TaskTemplateLogWhereInput[]
    NOT?: TaskTemplateLogWhereInput | TaskTemplateLogWhereInput[]
    id?: IntFilter<"TaskTemplateLog"> | number
    taskTemplateId?: IntFilter<"TaskTemplateLog"> | number
    userId?: IntNullableFilter<"TaskTemplateLog"> | number | null
    createdAt?: DateTimeFilter<"TaskTemplateLog"> | Date | string
    note?: StringNullableFilter<"TaskTemplateLog"> | string | null
    eventType?: EnumTaskEventTypeFilter<"TaskTemplateLog"> | $Enums.TaskEventType
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TaskTemplateLogOrderByWithRelationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    note?: SortOrderInput | SortOrder
    eventType?: SortOrder
    taskTemplate?: TaskTemplateOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskTemplateLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskTemplateLogWhereInput | TaskTemplateLogWhereInput[]
    OR?: TaskTemplateLogWhereInput[]
    NOT?: TaskTemplateLogWhereInput | TaskTemplateLogWhereInput[]
    taskTemplateId?: IntFilter<"TaskTemplateLog"> | number
    userId?: IntNullableFilter<"TaskTemplateLog"> | number | null
    createdAt?: DateTimeFilter<"TaskTemplateLog"> | Date | string
    note?: StringNullableFilter<"TaskTemplateLog"> | string | null
    eventType?: EnumTaskEventTypeFilter<"TaskTemplateLog"> | $Enums.TaskEventType
    taskTemplate?: XOR<TaskTemplateScalarRelationFilter, TaskTemplateWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TaskTemplateLogOrderByWithAggregationInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    note?: SortOrderInput | SortOrder
    eventType?: SortOrder
    _count?: TaskTemplateLogCountOrderByAggregateInput
    _avg?: TaskTemplateLogAvgOrderByAggregateInput
    _max?: TaskTemplateLogMaxOrderByAggregateInput
    _min?: TaskTemplateLogMinOrderByAggregateInput
    _sum?: TaskTemplateLogSumOrderByAggregateInput
  }

  export type TaskTemplateLogScalarWhereWithAggregatesInput = {
    AND?: TaskTemplateLogScalarWhereWithAggregatesInput | TaskTemplateLogScalarWhereWithAggregatesInput[]
    OR?: TaskTemplateLogScalarWhereWithAggregatesInput[]
    NOT?: TaskTemplateLogScalarWhereWithAggregatesInput | TaskTemplateLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskTemplateLog"> | number
    taskTemplateId?: IntWithAggregatesFilter<"TaskTemplateLog"> | number
    userId?: IntNullableWithAggregatesFilter<"TaskTemplateLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskTemplateLog"> | Date | string
    note?: StringNullableWithAggregatesFilter<"TaskTemplateLog"> | string | null
    eventType?: EnumTaskEventTypeWithAggregatesFilter<"TaskTemplateLog"> | $Enums.TaskEventType
  }

  export type BorneCreateInput = {
    nom: string
    productionLines?: ProductionLineCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateCreateNestedManyWithoutBorneInput
    kits?: KitCreateNestedManyWithoutBornesInput
    pieces?: PieceCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateInput = {
    id?: number
    nom: string
    productionLines?: ProductionLineUncheckedCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateUncheckedCreateNestedManyWithoutBorneInput
    kits?: KitUncheckedCreateNestedManyWithoutBornesInput
    pieces?: PieceUncheckedCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageUncheckedCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUpdateManyWithoutBorneNestedInput
    kits?: KitUpdateManyWithoutBornesNestedInput
    pieces?: PieceUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUncheckedUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput
    kits?: KitUncheckedUpdateManyWithoutBornesNestedInput
    pieces?: PieceUncheckedUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type BorneCreateManyInput = {
    id?: number
    nom: string
  }

  export type BorneUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BorneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskCreateNestedManyWithoutAssignedToInput
    taskLogs?: ProductionTaskLogCreateNestedManyWithoutUserInput
    stockLogs?: StockLogCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskUncheckedCreateNestedManyWithoutAssignedToInput
    taskLogs?: ProductionTaskLogUncheckedCreateNestedManyWithoutUserInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUpdateManyWithoutAssignedToNestedInput
    taskLogs?: ProductionTaskLogUpdateManyWithoutUserNestedInput
    stockLogs?: StockLogUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    taskLogs?: ProductionTaskLogUncheckedUpdateManyWithoutUserNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PieceCreateInput = {
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceCreateNestedManyWithoutPieceInput
    bornes?: BorneCreateNestedManyWithoutPiecesInput
  }

  export type PieceUncheckedCreateInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceUncheckedCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutPieceInput
    bornes?: BorneUncheckedCreateNestedManyWithoutPiecesInput
  }

  export type PieceUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUpdateManyWithoutPieceNestedInput
    bornes?: BorneUpdateManyWithoutPiecesNestedInput
  }

  export type PieceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUncheckedUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedUpdateManyWithoutPieceNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutPiecesNestedInput
  }

  export type PieceCreateManyInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
  }

  export type PieceUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type PieceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousAssemblageCreateInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceCreateNestedManyWithoutSousAssemblageInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageUncheckedCreateInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceUncheckedCreateNestedManyWithoutSousAssemblageInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUpdateManyWithoutSousAssemblageNestedInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageNestedInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageCreateManyInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
  }

  export type SousAssemblageUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousAssemblageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousSousAssemblageCreateInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    pieces?: SousSousAssemblagePieceCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageUncheckedCreateInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    pieces?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    pieces?: SousSousAssemblagePieceUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type SousSousAssemblageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    pieces?: SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type SousSousAssemblageCreateManyInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
  }

  export type SousSousAssemblageUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousSousAssemblageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type KitCreateInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: KitPieceCreateNestedManyWithoutKitInput
    bornes?: BorneCreateNestedManyWithoutKitsInput
  }

  export type KitUncheckedCreateInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: KitPieceUncheckedCreateNestedManyWithoutKitInput
    bornes?: BorneUncheckedCreateNestedManyWithoutKitsInput
  }

  export type KitUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: KitPieceUpdateManyWithoutKitNestedInput
    bornes?: BorneUpdateManyWithoutKitsNestedInput
  }

  export type KitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: KitPieceUncheckedUpdateManyWithoutKitNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutKitsNestedInput
  }

  export type KitCreateManyInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
  }

  export type KitUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type KitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousAssemblagePieceCreateInput = {
    nombre?: number
    piece: PieceCreateNestedOneWithoutSousAssemblagesInput
    sousAssemblage: SousAssemblageCreateNestedOneWithoutPiecesInput
  }

  export type SousAssemblagePieceUncheckedCreateInput = {
    id?: number
    sousAssemblageId: number
    pieceId: number
    nombre?: number
  }

  export type SousAssemblagePieceUpdateInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutSousAssemblagesNestedInput
    sousAssemblage?: SousAssemblageUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type SousAssemblagePieceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblagePieceCreateManyInput = {
    id?: number
    sousAssemblageId: number
    pieceId: number
    nombre?: number
  }

  export type SousAssemblagePieceUpdateManyMutationInput = {
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblagePieceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceCreateInput = {
    nombre?: number
    piece: PieceCreateNestedOneWithoutSousSousAssemblagesInput
    sousSousAssemblage: SousSousAssemblageCreateNestedOneWithoutPiecesInput
  }

  export type SousSousAssemblagePieceUncheckedCreateInput = {
    id?: number
    sousSousAssemblageId: number
    pieceId: number
    nombre?: number
  }

  export type SousSousAssemblagePieceUpdateInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutSousSousAssemblagesNestedInput
    sousSousAssemblage?: SousSousAssemblageUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type SousSousAssemblagePieceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceCreateManyInput = {
    id?: number
    sousSousAssemblageId: number
    pieceId: number
    nombre?: number
  }

  export type SousSousAssemblagePieceUpdateManyMutationInput = {
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblageSousSousAssemblageCreateInput = {
    nombre?: number
    sousAssemblage: SousAssemblageCreateNestedOneWithoutSousSousAssemblagesInput
    sousSousAssemblage: SousSousAssemblageCreateNestedOneWithoutSousAssemblagesInput
  }

  export type SousAssemblageSousSousAssemblageUncheckedCreateInput = {
    id?: number
    sousAssemblageId: number
    sousSousAssemblageId: number
    nombre?: number
  }

  export type SousAssemblageSousSousAssemblageUpdateInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    sousAssemblage?: SousAssemblageUpdateOneRequiredWithoutSousSousAssemblagesNestedInput
    sousSousAssemblage?: SousSousAssemblageUpdateOneRequiredWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblageSousSousAssemblageCreateManyInput = {
    id?: number
    sousAssemblageId: number
    sousSousAssemblageId: number
    nombre?: number
  }

  export type SousAssemblageSousSousAssemblageUpdateManyMutationInput = {
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type KitPieceCreateInput = {
    nombre?: number
    kit: KitCreateNestedOneWithoutPiecesInput
    piece: PieceCreateNestedOneWithoutKitsInput
  }

  export type KitPieceUncheckedCreateInput = {
    id?: number
    kitId: number
    pieceId: number
    nombre?: number
  }

  export type KitPieceUpdateInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    kit?: KitUpdateOneRequiredWithoutPiecesNestedInput
    piece?: PieceUpdateOneRequiredWithoutKitsNestedInput
  }

  export type KitPieceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kitId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type KitPieceCreateManyInput = {
    id?: number
    kitId: number
    pieceId: number
    nombre?: number
  }

  export type KitPieceUpdateManyMutationInput = {
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type KitPieceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kitId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type StockLogCreateInput = {
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutStockLogsInput
  }

  export type StockLogUncheckedCreateInput = {
    id?: number
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt?: Date | string
    userId?: number | null
  }

  export type StockLogUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStockLogsNestedInput
  }

  export type StockLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockLogCreateManyInput = {
    id?: number
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt?: Date | string
    userId?: number | null
  }

  export type StockLogUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskTemplateCreateInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskCreateNestedManyWithoutTemplateInput
    borne?: BorneCreateNestedOneWithoutTaskTemplatesInput
    logs?: TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput
    logs?: TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUpdateManyWithoutTemplateNestedInput
    borne?: BorneUpdateOneWithoutTaskTemplatesNestedInput
    logs?: TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput
    logs?: TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateCreateManyInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
  }

  export type TaskTemplateUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductionCreateInput = {
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    lines?: ProductionLineCreateNestedManyWithoutProductionInput
    tasks?: ProductionTaskCreateNestedManyWithoutProductionInput
  }

  export type ProductionUncheckedCreateInput = {
    id?: number
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    lines?: ProductionLineUncheckedCreateNestedManyWithoutProductionInput
    tasks?: ProductionTaskUncheckedCreateNestedManyWithoutProductionInput
  }

  export type ProductionUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: ProductionLineUpdateManyWithoutProductionNestedInput
    tasks?: ProductionTaskUpdateManyWithoutProductionNestedInput
  }

  export type ProductionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: ProductionLineUncheckedUpdateManyWithoutProductionNestedInput
    tasks?: ProductionTaskUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type ProductionCreateManyInput = {
    id?: number
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
  }

  export type ProductionUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductionLineCreateInput = {
    quantity: number
    borne: BorneCreateNestedOneWithoutProductionLinesInput
    production: ProductionCreateNestedOneWithoutLinesInput
  }

  export type ProductionLineUncheckedCreateInput = {
    id?: number
    productionId: number
    borneId: number
    quantity: number
  }

  export type ProductionLineUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    borne?: BorneUpdateOneRequiredWithoutProductionLinesNestedInput
    production?: ProductionUpdateOneRequiredWithoutLinesNestedInput
  }

  export type ProductionLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    borneId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionLineCreateManyInput = {
    id?: number
    productionId: number
    borneId: number
    quantity: number
  }

  export type ProductionLineUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    borneId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionTaskCreateInput = {
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTasksInput
    production: ProductionCreateNestedOneWithoutTasksInput
    template?: TaskTemplateCreateNestedOneWithoutProductionTasksInput
    logs?: ProductionTaskLogCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskUncheckedCreateInput = {
    id?: number
    productionId: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
    logs?: ProductionTaskLogUncheckedCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTasksNestedInput
    production?: ProductionUpdateOneRequiredWithoutTasksNestedInput
    template?: TaskTemplateUpdateOneWithoutProductionTasksNestedInput
    logs?: ProductionTaskLogUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskCreateManyInput = {
    id?: number
    productionId: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
  }

  export type ProductionTaskUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductionTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductionTaskLogCreateInput = {
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
    productionTask: ProductionTaskCreateNestedOneWithoutLogsInput
    user?: UserCreateNestedOneWithoutTaskLogsInput
  }

  export type ProductionTaskLogUncheckedCreateInput = {
    id?: number
    productionTaskId: number
    userId?: number | null
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
  }

  export type ProductionTaskLogUpdateInput = {
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    productionTask?: ProductionTaskUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneWithoutTaskLogsNestedInput
  }

  export type ProductionTaskLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionTaskId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionTaskLogCreateManyInput = {
    id?: number
    productionTaskId: number
    userId?: number | null
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
  }

  export type ProductionTaskLogUpdateManyMutationInput = {
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionTaskLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionTaskId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskTemplatePieceCreateInput = {
    quantity?: number
    piece: PieceCreateNestedOneWithoutTaskTemplatePiecesInput
    taskTemplate: TaskTemplateCreateNestedOneWithoutPiecesInput
  }

  export type TaskTemplatePieceUncheckedCreateInput = {
    id?: number
    taskTemplateId: number
    pieceId: number
    quantity?: number
  }

  export type TaskTemplatePieceUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutTaskTemplatePiecesNestedInput
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type TaskTemplatePieceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplatePieceCreateManyInput = {
    id?: number
    taskTemplateId: number
    pieceId: number
    quantity?: number
  }

  export type TaskTemplatePieceUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplatePieceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageCreateInput = {
    quantity?: number
    sousAssemblage: SousAssemblageCreateNestedOneWithoutTaskTemplateSousAssemblagesInput
    taskTemplate: TaskTemplateCreateNestedOneWithoutSousAssemblagesInput
  }

  export type TaskTemplateSousAssemblageUncheckedCreateInput = {
    id?: number
    taskTemplateId: number
    sousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousAssemblageUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sousAssemblage?: SousAssemblageUpdateOneRequiredWithoutTaskTemplateSousAssemblagesNestedInput
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutSousAssemblagesNestedInput
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageCreateManyInput = {
    id?: number
    taskTemplateId: number
    sousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousAssemblageUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageCreateInput = {
    quantity?: number
    sousSousAssemblage: SousSousAssemblageCreateNestedOneWithoutTaskTemplateSousSousAssemblagesInput
    taskTemplate: TaskTemplateCreateNestedOneWithoutSousSousAssemblagesInput
  }

  export type TaskTemplateSousSousAssemblageUncheckedCreateInput = {
    id?: number
    taskTemplateId: number
    sousSousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousSousAssemblageUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sousSousAssemblage?: SousSousAssemblageUpdateOneRequiredWithoutTaskTemplateSousSousAssemblagesNestedInput
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutSousSousAssemblagesNestedInput
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageCreateManyInput = {
    id?: number
    taskTemplateId: number
    sousSousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousSousAssemblageUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateLogCreateInput = {
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
    taskTemplate: TaskTemplateCreateNestedOneWithoutLogsInput
    user?: UserCreateNestedOneWithoutTemplateLogsInput
  }

  export type TaskTemplateLogUncheckedCreateInput = {
    id?: number
    taskTemplateId: number
    userId?: number | null
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
  }

  export type TaskTemplateLogUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneWithoutTemplateLogsNestedInput
  }

  export type TaskTemplateLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type TaskTemplateLogCreateManyInput = {
    id?: number
    taskTemplateId: number
    userId?: number | null
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
  }

  export type TaskTemplateLogUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type TaskTemplateLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ProductionLineListRelationFilter = {
    every?: ProductionLineWhereInput
    some?: ProductionLineWhereInput
    none?: ProductionLineWhereInput
  }

  export type TaskTemplateListRelationFilter = {
    every?: TaskTemplateWhereInput
    some?: TaskTemplateWhereInput
    none?: TaskTemplateWhereInput
  }

  export type KitListRelationFilter = {
    every?: KitWhereInput
    some?: KitWhereInput
    none?: KitWhereInput
  }

  export type PieceListRelationFilter = {
    every?: PieceWhereInput
    some?: PieceWhereInput
    none?: PieceWhereInput
  }

  export type SousAssemblageListRelationFilter = {
    every?: SousAssemblageWhereInput
    some?: SousAssemblageWhereInput
    none?: SousAssemblageWhereInput
  }

  export type SousSousAssemblageListRelationFilter = {
    every?: SousSousAssemblageWhereInput
    some?: SousSousAssemblageWhereInput
    none?: SousSousAssemblageWhereInput
  }

  export type ProductionLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PieceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SousAssemblageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SousSousAssemblageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BorneCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BorneAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BorneMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BorneMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BorneSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductionTaskListRelationFilter = {
    every?: ProductionTaskWhereInput
    some?: ProductionTaskWhereInput
    none?: ProductionTaskWhereInput
  }

  export type ProductionTaskLogListRelationFilter = {
    every?: ProductionTaskLogWhereInput
    some?: ProductionTaskLogWhereInput
    none?: ProductionTaskLogWhereInput
  }

  export type StockLogListRelationFilter = {
    every?: StockLogWhereInput
    some?: StockLogWhereInput
    none?: StockLogWhereInput
  }

  export type TaskTemplateLogListRelationFilter = {
    every?: TaskTemplateLogWhereInput
    some?: TaskTemplateLogWhereInput
    none?: TaskTemplateLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductionTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionTaskLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskTemplateLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumPieceEtatFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceEtat | EnumPieceEtatFieldRefInput<$PrismaModel>
    in?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceEtatFilter<$PrismaModel> | $Enums.PieceEtat
  }

  export type EnumPieceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceType | EnumPieceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceTypeFilter<$PrismaModel> | $Enums.PieceType
  }

  export type KitPieceListRelationFilter = {
    every?: KitPieceWhereInput
    some?: KitPieceWhereInput
    none?: KitPieceWhereInput
  }

  export type SousAssemblagePieceListRelationFilter = {
    every?: SousAssemblagePieceWhereInput
    some?: SousAssemblagePieceWhereInput
    none?: SousAssemblagePieceWhereInput
  }

  export type SousSousAssemblagePieceListRelationFilter = {
    every?: SousSousAssemblagePieceWhereInput
    some?: SousSousAssemblagePieceWhereInput
    none?: SousSousAssemblagePieceWhereInput
  }

  export type TaskTemplatePieceListRelationFilter = {
    every?: TaskTemplatePieceWhereInput
    some?: TaskTemplatePieceWhereInput
    none?: TaskTemplatePieceWhereInput
  }

  export type BorneListRelationFilter = {
    every?: BorneWhereInput
    some?: BorneWhereInput
    none?: BorneWhereInput
  }

  export type KitPieceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SousAssemblagePieceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SousSousAssemblagePieceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskTemplatePieceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BorneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PieceCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    nombre?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type PieceAvgOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type PieceMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    nombre?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type PieceMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    nombre?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type PieceSumOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumPieceEtatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceEtat | EnumPieceEtatFieldRefInput<$PrismaModel>
    in?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceEtatWithAggregatesFilter<$PrismaModel> | $Enums.PieceEtat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPieceEtatFilter<$PrismaModel>
    _max?: NestedEnumPieceEtatFilter<$PrismaModel>
  }

  export type EnumPieceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceType | EnumPieceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PieceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPieceTypeFilter<$PrismaModel>
    _max?: NestedEnumPieceTypeFilter<$PrismaModel>
  }

  export type SousAssemblageSousSousAssemblageListRelationFilter = {
    every?: SousAssemblageSousSousAssemblageWhereInput
    some?: SousAssemblageSousSousAssemblageWhereInput
    none?: SousAssemblageSousSousAssemblageWhereInput
  }

  export type TaskTemplateSousAssemblageListRelationFilter = {
    every?: TaskTemplateSousAssemblageWhereInput
    some?: TaskTemplateSousAssemblageWhereInput
    none?: TaskTemplateSousAssemblageWhereInput
  }

  export type SousAssemblageSousSousAssemblageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskTemplateSousAssemblageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SousAssemblageCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type SousAssemblageAvgOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type SousAssemblageMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type SousAssemblageMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type SousAssemblageSumOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type TaskTemplateSousSousAssemblageListRelationFilter = {
    every?: TaskTemplateSousSousAssemblageWhereInput
    some?: TaskTemplateSousSousAssemblageWhereInput
    none?: TaskTemplateSousSousAssemblageWhereInput
  }

  export type TaskTemplateSousSousAssemblageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SousSousAssemblageCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type SousSousAssemblageAvgOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type SousSousAssemblageMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type SousSousAssemblageMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type SousSousAssemblageSumOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type KitCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type KitAvgOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type KitMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type KitMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    photo?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
    etat?: SortOrder
    numero?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type KitSumOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    seuilAlerte?: SortOrder
  }

  export type PieceScalarRelationFilter = {
    is?: PieceWhereInput
    isNot?: PieceWhereInput
  }

  export type SousAssemblageScalarRelationFilter = {
    is?: SousAssemblageWhereInput
    isNot?: SousAssemblageWhereInput
  }

  export type SousAssemblagePieceSousAssemblageIdPieceIdCompoundUniqueInput = {
    sousAssemblageId: number
    pieceId: number
  }

  export type SousAssemblagePieceCountOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblagePieceAvgOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblagePieceMaxOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblagePieceMinOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblagePieceSumOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousSousAssemblageScalarRelationFilter = {
    is?: SousSousAssemblageWhereInput
    isNot?: SousSousAssemblageWhereInput
  }

  export type SousSousAssemblagePieceSousSousAssemblageIdPieceIdCompoundUniqueInput = {
    sousSousAssemblageId: number
    pieceId: number
  }

  export type SousSousAssemblagePieceCountOrderByAggregateInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousSousAssemblagePieceAvgOrderByAggregateInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousSousAssemblagePieceMaxOrderByAggregateInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousSousAssemblagePieceMinOrderByAggregateInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousSousAssemblagePieceSumOrderByAggregateInput = {
    id?: SortOrder
    sousSousAssemblageId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblageSousSousAssemblageSousAssemblageIdSousSousAssemblageIdCompoundUniqueInput = {
    sousAssemblageId: number
    sousSousAssemblageId: number
  }

  export type SousAssemblageSousSousAssemblageCountOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblageSousSousAssemblageAvgOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblageSousSousAssemblageMaxOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblageSousSousAssemblageMinOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
  }

  export type SousAssemblageSousSousAssemblageSumOrderByAggregateInput = {
    id?: SortOrder
    sousAssemblageId?: SortOrder
    sousSousAssemblageId?: SortOrder
    nombre?: SortOrder
  }

  export type KitScalarRelationFilter = {
    is?: KitWhereInput
    isNot?: KitWhereInput
  }

  export type KitPieceKitIdPieceIdCompoundUniqueInput = {
    kitId: number
    pieceId: number
  }

  export type KitPieceCountOrderByAggregateInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type KitPieceAvgOrderByAggregateInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type KitPieceMaxOrderByAggregateInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type KitPieceMinOrderByAggregateInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type KitPieceSumOrderByAggregateInput = {
    id?: SortOrder
    kitId?: SortOrder
    pieceId?: SortOrder
    nombre?: SortOrder
  }

  export type EnumStockOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.StockOperation | EnumStockOperationFieldRefInput<$PrismaModel>
    in?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumStockOperationFilter<$PrismaModel> | $Enums.StockOperation
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StockLogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type StockLogAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    userId?: SortOrder
  }

  export type StockLogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type StockLogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type StockLogSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    userId?: SortOrder
  }

  export type EnumStockOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockOperation | EnumStockOperationFieldRefInput<$PrismaModel>
    in?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumStockOperationWithAggregatesFilter<$PrismaModel> | $Enums.StockOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockOperationFilter<$PrismaModel>
    _max?: NestedEnumStockOperationFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BorneNullableScalarRelationFilter = {
    is?: BorneWhereInput | null
    isNot?: BorneWhereInput | null
  }

  export type TaskTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    borneId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    order?: SortOrder
    estimatedMinutesPerUnit?: SortOrder
    active?: SortOrder
  }

  export type TaskTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    borneId?: SortOrder
    order?: SortOrder
    estimatedMinutesPerUnit?: SortOrder
  }

  export type TaskTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    borneId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    order?: SortOrder
    estimatedMinutesPerUnit?: SortOrder
    active?: SortOrder
  }

  export type TaskTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    borneId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    order?: SortOrder
    estimatedMinutesPerUnit?: SortOrder
    active?: SortOrder
  }

  export type TaskTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    borneId?: SortOrder
    order?: SortOrder
    estimatedMinutesPerUnit?: SortOrder
  }

  export type EnumProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusFilter<$PrismaModel> | $Enums.ProductionStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProductionCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
  }

  export type ProductionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductionMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
  }

  export type ProductionMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    reference?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
  }

  export type ProductionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BorneScalarRelationFilter = {
    is?: BorneWhereInput
    isNot?: BorneWhereInput
  }

  export type ProductionScalarRelationFilter = {
    is?: ProductionWhereInput
    isNot?: ProductionWhereInput
  }

  export type ProductionLineCountOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductionLineAvgOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductionLineMaxOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductionLineMinOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductionLineSumOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    borneId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateNullableScalarRelationFilter = {
    is?: TaskTemplateWhereInput | null
    isNot?: TaskTemplateWhereInput | null
  }

  export type ProductionTaskCountOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    isDone?: SortOrder
    totalSeconds?: SortOrder
    running?: SortOrder
    lastStartedAt?: SortOrder
    assignedToId?: SortOrder
  }

  export type ProductionTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrder
    totalSeconds?: SortOrder
    assignedToId?: SortOrder
  }

  export type ProductionTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    isDone?: SortOrder
    totalSeconds?: SortOrder
    running?: SortOrder
    lastStartedAt?: SortOrder
    assignedToId?: SortOrder
  }

  export type ProductionTaskMinOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrder
    label?: SortOrder
    description?: SortOrder
    isDone?: SortOrder
    totalSeconds?: SortOrder
    running?: SortOrder
    lastStartedAt?: SortOrder
    assignedToId?: SortOrder
  }

  export type ProductionTaskSumOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    taskTemplateId?: SortOrder
    totalSeconds?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumTaskEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskEventType | EnumTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskEventTypeFilter<$PrismaModel> | $Enums.TaskEventType
  }

  export type ProductionTaskScalarRelationFilter = {
    is?: ProductionTaskWhereInput
    isNot?: ProductionTaskWhereInput
  }

  export type ProductionTaskLogCountOrderByAggregateInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
  }

  export type ProductionTaskLogAvgOrderByAggregateInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrder
  }

  export type ProductionTaskLogMaxOrderByAggregateInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
  }

  export type ProductionTaskLogMinOrderByAggregateInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
  }

  export type ProductionTaskLogSumOrderByAggregateInput = {
    id?: SortOrder
    productionTaskId?: SortOrder
    userId?: SortOrder
  }

  export type EnumTaskEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskEventType | EnumTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskEventTypeFilter<$PrismaModel>
  }

  export type TaskTemplateScalarRelationFilter = {
    is?: TaskTemplateWhereInput
    isNot?: TaskTemplateWhereInput
  }

  export type TaskTemplatePieceTaskTemplateIdPieceIdCompoundUniqueInput = {
    taskTemplateId: number
    pieceId: number
  }

  export type TaskTemplatePieceCountOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplatePieceAvgOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplatePieceMaxOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplatePieceMinOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplatePieceSumOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    pieceId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousAssemblageTaskTemplateIdSousAssemblageIdCompoundUniqueInput = {
    taskTemplateId: number
    sousAssemblageId: number
  }

  export type TaskTemplateSousAssemblageCountOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousAssemblageAvgOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousAssemblageMaxOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousAssemblageMinOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousAssemblageSumOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousSousAssemblageTaskTemplateIdSousSousAssemblageIdCompoundUniqueInput = {
    taskTemplateId: number
    sousSousAssemblageId: number
  }

  export type TaskTemplateSousSousAssemblageCountOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousSousAssemblageAvgOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousSousAssemblageMaxOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousSousAssemblageMinOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateSousSousAssemblageSumOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    sousSousAssemblageId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskTemplateLogCountOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
    eventType?: SortOrder
  }

  export type TaskTemplateLogAvgOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrder
  }

  export type TaskTemplateLogMaxOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
    eventType?: SortOrder
  }

  export type TaskTemplateLogMinOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    note?: SortOrder
    eventType?: SortOrder
  }

  export type TaskTemplateLogSumOrderByAggregateInput = {
    id?: SortOrder
    taskTemplateId?: SortOrder
    userId?: SortOrder
  }

  export type ProductionLineCreateNestedManyWithoutBorneInput = {
    create?: XOR<ProductionLineCreateWithoutBorneInput, ProductionLineUncheckedCreateWithoutBorneInput> | ProductionLineCreateWithoutBorneInput[] | ProductionLineUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutBorneInput | ProductionLineCreateOrConnectWithoutBorneInput[]
    createMany?: ProductionLineCreateManyBorneInputEnvelope
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
  }

  export type TaskTemplateCreateNestedManyWithoutBorneInput = {
    create?: XOR<TaskTemplateCreateWithoutBorneInput, TaskTemplateUncheckedCreateWithoutBorneInput> | TaskTemplateCreateWithoutBorneInput[] | TaskTemplateUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutBorneInput | TaskTemplateCreateOrConnectWithoutBorneInput[]
    createMany?: TaskTemplateCreateManyBorneInputEnvelope
    connect?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
  }

  export type KitCreateNestedManyWithoutBornesInput = {
    create?: XOR<KitCreateWithoutBornesInput, KitUncheckedCreateWithoutBornesInput> | KitCreateWithoutBornesInput[] | KitUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: KitCreateOrConnectWithoutBornesInput | KitCreateOrConnectWithoutBornesInput[]
    connect?: KitWhereUniqueInput | KitWhereUniqueInput[]
  }

  export type PieceCreateNestedManyWithoutBornesInput = {
    create?: XOR<PieceCreateWithoutBornesInput, PieceUncheckedCreateWithoutBornesInput> | PieceCreateWithoutBornesInput[] | PieceUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: PieceCreateOrConnectWithoutBornesInput | PieceCreateOrConnectWithoutBornesInput[]
    connect?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
  }

  export type SousAssemblageCreateNestedManyWithoutBornesInput = {
    create?: XOR<SousAssemblageCreateWithoutBornesInput, SousAssemblageUncheckedCreateWithoutBornesInput> | SousAssemblageCreateWithoutBornesInput[] | SousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutBornesInput | SousAssemblageCreateOrConnectWithoutBornesInput[]
    connect?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
  }

  export type SousSousAssemblageCreateNestedManyWithoutBornesInput = {
    create?: XOR<SousSousAssemblageCreateWithoutBornesInput, SousSousAssemblageUncheckedCreateWithoutBornesInput> | SousSousAssemblageCreateWithoutBornesInput[] | SousSousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutBornesInput | SousSousAssemblageCreateOrConnectWithoutBornesInput[]
    connect?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
  }

  export type ProductionLineUncheckedCreateNestedManyWithoutBorneInput = {
    create?: XOR<ProductionLineCreateWithoutBorneInput, ProductionLineUncheckedCreateWithoutBorneInput> | ProductionLineCreateWithoutBorneInput[] | ProductionLineUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutBorneInput | ProductionLineCreateOrConnectWithoutBorneInput[]
    createMany?: ProductionLineCreateManyBorneInputEnvelope
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
  }

  export type TaskTemplateUncheckedCreateNestedManyWithoutBorneInput = {
    create?: XOR<TaskTemplateCreateWithoutBorneInput, TaskTemplateUncheckedCreateWithoutBorneInput> | TaskTemplateCreateWithoutBorneInput[] | TaskTemplateUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutBorneInput | TaskTemplateCreateOrConnectWithoutBorneInput[]
    createMany?: TaskTemplateCreateManyBorneInputEnvelope
    connect?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
  }

  export type KitUncheckedCreateNestedManyWithoutBornesInput = {
    create?: XOR<KitCreateWithoutBornesInput, KitUncheckedCreateWithoutBornesInput> | KitCreateWithoutBornesInput[] | KitUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: KitCreateOrConnectWithoutBornesInput | KitCreateOrConnectWithoutBornesInput[]
    connect?: KitWhereUniqueInput | KitWhereUniqueInput[]
  }

  export type PieceUncheckedCreateNestedManyWithoutBornesInput = {
    create?: XOR<PieceCreateWithoutBornesInput, PieceUncheckedCreateWithoutBornesInput> | PieceCreateWithoutBornesInput[] | PieceUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: PieceCreateOrConnectWithoutBornesInput | PieceCreateOrConnectWithoutBornesInput[]
    connect?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
  }

  export type SousAssemblageUncheckedCreateNestedManyWithoutBornesInput = {
    create?: XOR<SousAssemblageCreateWithoutBornesInput, SousAssemblageUncheckedCreateWithoutBornesInput> | SousAssemblageCreateWithoutBornesInput[] | SousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutBornesInput | SousAssemblageCreateOrConnectWithoutBornesInput[]
    connect?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
  }

  export type SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput = {
    create?: XOR<SousSousAssemblageCreateWithoutBornesInput, SousSousAssemblageUncheckedCreateWithoutBornesInput> | SousSousAssemblageCreateWithoutBornesInput[] | SousSousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutBornesInput | SousSousAssemblageCreateOrConnectWithoutBornesInput[]
    connect?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProductionLineUpdateManyWithoutBorneNestedInput = {
    create?: XOR<ProductionLineCreateWithoutBorneInput, ProductionLineUncheckedCreateWithoutBorneInput> | ProductionLineCreateWithoutBorneInput[] | ProductionLineUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutBorneInput | ProductionLineCreateOrConnectWithoutBorneInput[]
    upsert?: ProductionLineUpsertWithWhereUniqueWithoutBorneInput | ProductionLineUpsertWithWhereUniqueWithoutBorneInput[]
    createMany?: ProductionLineCreateManyBorneInputEnvelope
    set?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    disconnect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    delete?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    update?: ProductionLineUpdateWithWhereUniqueWithoutBorneInput | ProductionLineUpdateWithWhereUniqueWithoutBorneInput[]
    updateMany?: ProductionLineUpdateManyWithWhereWithoutBorneInput | ProductionLineUpdateManyWithWhereWithoutBorneInput[]
    deleteMany?: ProductionLineScalarWhereInput | ProductionLineScalarWhereInput[]
  }

  export type TaskTemplateUpdateManyWithoutBorneNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutBorneInput, TaskTemplateUncheckedCreateWithoutBorneInput> | TaskTemplateCreateWithoutBorneInput[] | TaskTemplateUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutBorneInput | TaskTemplateCreateOrConnectWithoutBorneInput[]
    upsert?: TaskTemplateUpsertWithWhereUniqueWithoutBorneInput | TaskTemplateUpsertWithWhereUniqueWithoutBorneInput[]
    createMany?: TaskTemplateCreateManyBorneInputEnvelope
    set?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    disconnect?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    delete?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    connect?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    update?: TaskTemplateUpdateWithWhereUniqueWithoutBorneInput | TaskTemplateUpdateWithWhereUniqueWithoutBorneInput[]
    updateMany?: TaskTemplateUpdateManyWithWhereWithoutBorneInput | TaskTemplateUpdateManyWithWhereWithoutBorneInput[]
    deleteMany?: TaskTemplateScalarWhereInput | TaskTemplateScalarWhereInput[]
  }

  export type KitUpdateManyWithoutBornesNestedInput = {
    create?: XOR<KitCreateWithoutBornesInput, KitUncheckedCreateWithoutBornesInput> | KitCreateWithoutBornesInput[] | KitUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: KitCreateOrConnectWithoutBornesInput | KitCreateOrConnectWithoutBornesInput[]
    upsert?: KitUpsertWithWhereUniqueWithoutBornesInput | KitUpsertWithWhereUniqueWithoutBornesInput[]
    set?: KitWhereUniqueInput | KitWhereUniqueInput[]
    disconnect?: KitWhereUniqueInput | KitWhereUniqueInput[]
    delete?: KitWhereUniqueInput | KitWhereUniqueInput[]
    connect?: KitWhereUniqueInput | KitWhereUniqueInput[]
    update?: KitUpdateWithWhereUniqueWithoutBornesInput | KitUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: KitUpdateManyWithWhereWithoutBornesInput | KitUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: KitScalarWhereInput | KitScalarWhereInput[]
  }

  export type PieceUpdateManyWithoutBornesNestedInput = {
    create?: XOR<PieceCreateWithoutBornesInput, PieceUncheckedCreateWithoutBornesInput> | PieceCreateWithoutBornesInput[] | PieceUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: PieceCreateOrConnectWithoutBornesInput | PieceCreateOrConnectWithoutBornesInput[]
    upsert?: PieceUpsertWithWhereUniqueWithoutBornesInput | PieceUpsertWithWhereUniqueWithoutBornesInput[]
    set?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    disconnect?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    delete?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    connect?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    update?: PieceUpdateWithWhereUniqueWithoutBornesInput | PieceUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: PieceUpdateManyWithWhereWithoutBornesInput | PieceUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: PieceScalarWhereInput | PieceScalarWhereInput[]
  }

  export type SousAssemblageUpdateManyWithoutBornesNestedInput = {
    create?: XOR<SousAssemblageCreateWithoutBornesInput, SousAssemblageUncheckedCreateWithoutBornesInput> | SousAssemblageCreateWithoutBornesInput[] | SousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutBornesInput | SousAssemblageCreateOrConnectWithoutBornesInput[]
    upsert?: SousAssemblageUpsertWithWhereUniqueWithoutBornesInput | SousAssemblageUpsertWithWhereUniqueWithoutBornesInput[]
    set?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    disconnect?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    delete?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    connect?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    update?: SousAssemblageUpdateWithWhereUniqueWithoutBornesInput | SousAssemblageUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: SousAssemblageUpdateManyWithWhereWithoutBornesInput | SousAssemblageUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: SousAssemblageScalarWhereInput | SousAssemblageScalarWhereInput[]
  }

  export type SousSousAssemblageUpdateManyWithoutBornesNestedInput = {
    create?: XOR<SousSousAssemblageCreateWithoutBornesInput, SousSousAssemblageUncheckedCreateWithoutBornesInput> | SousSousAssemblageCreateWithoutBornesInput[] | SousSousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutBornesInput | SousSousAssemblageCreateOrConnectWithoutBornesInput[]
    upsert?: SousSousAssemblageUpsertWithWhereUniqueWithoutBornesInput | SousSousAssemblageUpsertWithWhereUniqueWithoutBornesInput[]
    set?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    disconnect?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    delete?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    connect?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    update?: SousSousAssemblageUpdateWithWhereUniqueWithoutBornesInput | SousSousAssemblageUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: SousSousAssemblageUpdateManyWithWhereWithoutBornesInput | SousSousAssemblageUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: SousSousAssemblageScalarWhereInput | SousSousAssemblageScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductionLineUncheckedUpdateManyWithoutBorneNestedInput = {
    create?: XOR<ProductionLineCreateWithoutBorneInput, ProductionLineUncheckedCreateWithoutBorneInput> | ProductionLineCreateWithoutBorneInput[] | ProductionLineUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutBorneInput | ProductionLineCreateOrConnectWithoutBorneInput[]
    upsert?: ProductionLineUpsertWithWhereUniqueWithoutBorneInput | ProductionLineUpsertWithWhereUniqueWithoutBorneInput[]
    createMany?: ProductionLineCreateManyBorneInputEnvelope
    set?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    disconnect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    delete?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    update?: ProductionLineUpdateWithWhereUniqueWithoutBorneInput | ProductionLineUpdateWithWhereUniqueWithoutBorneInput[]
    updateMany?: ProductionLineUpdateManyWithWhereWithoutBorneInput | ProductionLineUpdateManyWithWhereWithoutBorneInput[]
    deleteMany?: ProductionLineScalarWhereInput | ProductionLineScalarWhereInput[]
  }

  export type TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutBorneInput, TaskTemplateUncheckedCreateWithoutBorneInput> | TaskTemplateCreateWithoutBorneInput[] | TaskTemplateUncheckedCreateWithoutBorneInput[]
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutBorneInput | TaskTemplateCreateOrConnectWithoutBorneInput[]
    upsert?: TaskTemplateUpsertWithWhereUniqueWithoutBorneInput | TaskTemplateUpsertWithWhereUniqueWithoutBorneInput[]
    createMany?: TaskTemplateCreateManyBorneInputEnvelope
    set?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    disconnect?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    delete?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    connect?: TaskTemplateWhereUniqueInput | TaskTemplateWhereUniqueInput[]
    update?: TaskTemplateUpdateWithWhereUniqueWithoutBorneInput | TaskTemplateUpdateWithWhereUniqueWithoutBorneInput[]
    updateMany?: TaskTemplateUpdateManyWithWhereWithoutBorneInput | TaskTemplateUpdateManyWithWhereWithoutBorneInput[]
    deleteMany?: TaskTemplateScalarWhereInput | TaskTemplateScalarWhereInput[]
  }

  export type KitUncheckedUpdateManyWithoutBornesNestedInput = {
    create?: XOR<KitCreateWithoutBornesInput, KitUncheckedCreateWithoutBornesInput> | KitCreateWithoutBornesInput[] | KitUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: KitCreateOrConnectWithoutBornesInput | KitCreateOrConnectWithoutBornesInput[]
    upsert?: KitUpsertWithWhereUniqueWithoutBornesInput | KitUpsertWithWhereUniqueWithoutBornesInput[]
    set?: KitWhereUniqueInput | KitWhereUniqueInput[]
    disconnect?: KitWhereUniqueInput | KitWhereUniqueInput[]
    delete?: KitWhereUniqueInput | KitWhereUniqueInput[]
    connect?: KitWhereUniqueInput | KitWhereUniqueInput[]
    update?: KitUpdateWithWhereUniqueWithoutBornesInput | KitUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: KitUpdateManyWithWhereWithoutBornesInput | KitUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: KitScalarWhereInput | KitScalarWhereInput[]
  }

  export type PieceUncheckedUpdateManyWithoutBornesNestedInput = {
    create?: XOR<PieceCreateWithoutBornesInput, PieceUncheckedCreateWithoutBornesInput> | PieceCreateWithoutBornesInput[] | PieceUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: PieceCreateOrConnectWithoutBornesInput | PieceCreateOrConnectWithoutBornesInput[]
    upsert?: PieceUpsertWithWhereUniqueWithoutBornesInput | PieceUpsertWithWhereUniqueWithoutBornesInput[]
    set?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    disconnect?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    delete?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    connect?: PieceWhereUniqueInput | PieceWhereUniqueInput[]
    update?: PieceUpdateWithWhereUniqueWithoutBornesInput | PieceUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: PieceUpdateManyWithWhereWithoutBornesInput | PieceUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: PieceScalarWhereInput | PieceScalarWhereInput[]
  }

  export type SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput = {
    create?: XOR<SousAssemblageCreateWithoutBornesInput, SousAssemblageUncheckedCreateWithoutBornesInput> | SousAssemblageCreateWithoutBornesInput[] | SousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutBornesInput | SousAssemblageCreateOrConnectWithoutBornesInput[]
    upsert?: SousAssemblageUpsertWithWhereUniqueWithoutBornesInput | SousAssemblageUpsertWithWhereUniqueWithoutBornesInput[]
    set?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    disconnect?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    delete?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    connect?: SousAssemblageWhereUniqueInput | SousAssemblageWhereUniqueInput[]
    update?: SousAssemblageUpdateWithWhereUniqueWithoutBornesInput | SousAssemblageUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: SousAssemblageUpdateManyWithWhereWithoutBornesInput | SousAssemblageUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: SousAssemblageScalarWhereInput | SousAssemblageScalarWhereInput[]
  }

  export type SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput = {
    create?: XOR<SousSousAssemblageCreateWithoutBornesInput, SousSousAssemblageUncheckedCreateWithoutBornesInput> | SousSousAssemblageCreateWithoutBornesInput[] | SousSousAssemblageUncheckedCreateWithoutBornesInput[]
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutBornesInput | SousSousAssemblageCreateOrConnectWithoutBornesInput[]
    upsert?: SousSousAssemblageUpsertWithWhereUniqueWithoutBornesInput | SousSousAssemblageUpsertWithWhereUniqueWithoutBornesInput[]
    set?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    disconnect?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    delete?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    connect?: SousSousAssemblageWhereUniqueInput | SousSousAssemblageWhereUniqueInput[]
    update?: SousSousAssemblageUpdateWithWhereUniqueWithoutBornesInput | SousSousAssemblageUpdateWithWhereUniqueWithoutBornesInput[]
    updateMany?: SousSousAssemblageUpdateManyWithWhereWithoutBornesInput | SousSousAssemblageUpdateManyWithWhereWithoutBornesInput[]
    deleteMany?: SousSousAssemblageScalarWhereInput | SousSousAssemblageScalarWhereInput[]
  }

  export type ProductionTaskCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ProductionTaskCreateWithoutAssignedToInput, ProductionTaskUncheckedCreateWithoutAssignedToInput> | ProductionTaskCreateWithoutAssignedToInput[] | ProductionTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutAssignedToInput | ProductionTaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: ProductionTaskCreateManyAssignedToInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type ProductionTaskLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductionTaskLogCreateWithoutUserInput, ProductionTaskLogUncheckedCreateWithoutUserInput> | ProductionTaskLogCreateWithoutUserInput[] | ProductionTaskLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutUserInput | ProductionTaskLogCreateOrConnectWithoutUserInput[]
    createMany?: ProductionTaskLogCreateManyUserInputEnvelope
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
  }

  export type StockLogCreateNestedManyWithoutUserInput = {
    create?: XOR<StockLogCreateWithoutUserInput, StockLogUncheckedCreateWithoutUserInput> | StockLogCreateWithoutUserInput[] | StockLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutUserInput | StockLogCreateOrConnectWithoutUserInput[]
    createMany?: StockLogCreateManyUserInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type TaskTemplateLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskTemplateLogCreateWithoutUserInput, TaskTemplateLogUncheckedCreateWithoutUserInput> | TaskTemplateLogCreateWithoutUserInput[] | TaskTemplateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutUserInput | TaskTemplateLogCreateOrConnectWithoutUserInput[]
    createMany?: TaskTemplateLogCreateManyUserInputEnvelope
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
  }

  export type ProductionTaskUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ProductionTaskCreateWithoutAssignedToInput, ProductionTaskUncheckedCreateWithoutAssignedToInput> | ProductionTaskCreateWithoutAssignedToInput[] | ProductionTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutAssignedToInput | ProductionTaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: ProductionTaskCreateManyAssignedToInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type ProductionTaskLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductionTaskLogCreateWithoutUserInput, ProductionTaskLogUncheckedCreateWithoutUserInput> | ProductionTaskLogCreateWithoutUserInput[] | ProductionTaskLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutUserInput | ProductionTaskLogCreateOrConnectWithoutUserInput[]
    createMany?: ProductionTaskLogCreateManyUserInputEnvelope
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
  }

  export type StockLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StockLogCreateWithoutUserInput, StockLogUncheckedCreateWithoutUserInput> | StockLogCreateWithoutUserInput[] | StockLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutUserInput | StockLogCreateOrConnectWithoutUserInput[]
    createMany?: StockLogCreateManyUserInputEnvelope
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
  }

  export type TaskTemplateLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskTemplateLogCreateWithoutUserInput, TaskTemplateLogUncheckedCreateWithoutUserInput> | TaskTemplateLogCreateWithoutUserInput[] | TaskTemplateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutUserInput | TaskTemplateLogCreateOrConnectWithoutUserInput[]
    createMany?: TaskTemplateLogCreateManyUserInputEnvelope
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductionTaskUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutAssignedToInput, ProductionTaskUncheckedCreateWithoutAssignedToInput> | ProductionTaskCreateWithoutAssignedToInput[] | ProductionTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutAssignedToInput | ProductionTaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutAssignedToInput | ProductionTaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ProductionTaskCreateManyAssignedToInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutAssignedToInput | ProductionTaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutAssignedToInput | ProductionTaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type ProductionTaskLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductionTaskLogCreateWithoutUserInput, ProductionTaskLogUncheckedCreateWithoutUserInput> | ProductionTaskLogCreateWithoutUserInput[] | ProductionTaskLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutUserInput | ProductionTaskLogCreateOrConnectWithoutUserInput[]
    upsert?: ProductionTaskLogUpsertWithWhereUniqueWithoutUserInput | ProductionTaskLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductionTaskLogCreateManyUserInputEnvelope
    set?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    disconnect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    delete?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    update?: ProductionTaskLogUpdateWithWhereUniqueWithoutUserInput | ProductionTaskLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductionTaskLogUpdateManyWithWhereWithoutUserInput | ProductionTaskLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductionTaskLogScalarWhereInput | ProductionTaskLogScalarWhereInput[]
  }

  export type StockLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockLogCreateWithoutUserInput, StockLogUncheckedCreateWithoutUserInput> | StockLogCreateWithoutUserInput[] | StockLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutUserInput | StockLogCreateOrConnectWithoutUserInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutUserInput | StockLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockLogCreateManyUserInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutUserInput | StockLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutUserInput | StockLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type TaskTemplateLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskTemplateLogCreateWithoutUserInput, TaskTemplateLogUncheckedCreateWithoutUserInput> | TaskTemplateLogCreateWithoutUserInput[] | TaskTemplateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutUserInput | TaskTemplateLogCreateOrConnectWithoutUserInput[]
    upsert?: TaskTemplateLogUpsertWithWhereUniqueWithoutUserInput | TaskTemplateLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskTemplateLogCreateManyUserInputEnvelope
    set?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    disconnect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    delete?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    update?: TaskTemplateLogUpdateWithWhereUniqueWithoutUserInput | TaskTemplateLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskTemplateLogUpdateManyWithWhereWithoutUserInput | TaskTemplateLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskTemplateLogScalarWhereInput | TaskTemplateLogScalarWhereInput[]
  }

  export type ProductionTaskUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutAssignedToInput, ProductionTaskUncheckedCreateWithoutAssignedToInput> | ProductionTaskCreateWithoutAssignedToInput[] | ProductionTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutAssignedToInput | ProductionTaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutAssignedToInput | ProductionTaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ProductionTaskCreateManyAssignedToInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutAssignedToInput | ProductionTaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutAssignedToInput | ProductionTaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type ProductionTaskLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductionTaskLogCreateWithoutUserInput, ProductionTaskLogUncheckedCreateWithoutUserInput> | ProductionTaskLogCreateWithoutUserInput[] | ProductionTaskLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutUserInput | ProductionTaskLogCreateOrConnectWithoutUserInput[]
    upsert?: ProductionTaskLogUpsertWithWhereUniqueWithoutUserInput | ProductionTaskLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductionTaskLogCreateManyUserInputEnvelope
    set?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    disconnect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    delete?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    update?: ProductionTaskLogUpdateWithWhereUniqueWithoutUserInput | ProductionTaskLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductionTaskLogUpdateManyWithWhereWithoutUserInput | ProductionTaskLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductionTaskLogScalarWhereInput | ProductionTaskLogScalarWhereInput[]
  }

  export type StockLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StockLogCreateWithoutUserInput, StockLogUncheckedCreateWithoutUserInput> | StockLogCreateWithoutUserInput[] | StockLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StockLogCreateOrConnectWithoutUserInput | StockLogCreateOrConnectWithoutUserInput[]
    upsert?: StockLogUpsertWithWhereUniqueWithoutUserInput | StockLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StockLogCreateManyUserInputEnvelope
    set?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    disconnect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    delete?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    connect?: StockLogWhereUniqueInput | StockLogWhereUniqueInput[]
    update?: StockLogUpdateWithWhereUniqueWithoutUserInput | StockLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StockLogUpdateManyWithWhereWithoutUserInput | StockLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
  }

  export type TaskTemplateLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskTemplateLogCreateWithoutUserInput, TaskTemplateLogUncheckedCreateWithoutUserInput> | TaskTemplateLogCreateWithoutUserInput[] | TaskTemplateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutUserInput | TaskTemplateLogCreateOrConnectWithoutUserInput[]
    upsert?: TaskTemplateLogUpsertWithWhereUniqueWithoutUserInput | TaskTemplateLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskTemplateLogCreateManyUserInputEnvelope
    set?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    disconnect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    delete?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    update?: TaskTemplateLogUpdateWithWhereUniqueWithoutUserInput | TaskTemplateLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskTemplateLogUpdateManyWithWhereWithoutUserInput | TaskTemplateLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskTemplateLogScalarWhereInput | TaskTemplateLogScalarWhereInput[]
  }

  export type KitPieceCreateNestedManyWithoutPieceInput = {
    create?: XOR<KitPieceCreateWithoutPieceInput, KitPieceUncheckedCreateWithoutPieceInput> | KitPieceCreateWithoutPieceInput[] | KitPieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutPieceInput | KitPieceCreateOrConnectWithoutPieceInput[]
    createMany?: KitPieceCreateManyPieceInputEnvelope
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
  }

  export type SousAssemblagePieceCreateNestedManyWithoutPieceInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutPieceInput, SousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousAssemblagePieceCreateWithoutPieceInput[] | SousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutPieceInput | SousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    createMany?: SousAssemblagePieceCreateManyPieceInputEnvelope
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
  }

  export type SousSousAssemblagePieceCreateNestedManyWithoutPieceInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutPieceInput, SousSousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousSousAssemblagePieceCreateWithoutPieceInput[] | SousSousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutPieceInput | SousSousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    createMany?: SousSousAssemblagePieceCreateManyPieceInputEnvelope
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
  }

  export type TaskTemplatePieceCreateNestedManyWithoutPieceInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutPieceInput, TaskTemplatePieceUncheckedCreateWithoutPieceInput> | TaskTemplatePieceCreateWithoutPieceInput[] | TaskTemplatePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutPieceInput | TaskTemplatePieceCreateOrConnectWithoutPieceInput[]
    createMany?: TaskTemplatePieceCreateManyPieceInputEnvelope
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
  }

  export type BorneCreateNestedManyWithoutPiecesInput = {
    create?: XOR<BorneCreateWithoutPiecesInput, BorneUncheckedCreateWithoutPiecesInput> | BorneCreateWithoutPiecesInput[] | BorneUncheckedCreateWithoutPiecesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutPiecesInput | BorneCreateOrConnectWithoutPiecesInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type KitPieceUncheckedCreateNestedManyWithoutPieceInput = {
    create?: XOR<KitPieceCreateWithoutPieceInput, KitPieceUncheckedCreateWithoutPieceInput> | KitPieceCreateWithoutPieceInput[] | KitPieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutPieceInput | KitPieceCreateOrConnectWithoutPieceInput[]
    createMany?: KitPieceCreateManyPieceInputEnvelope
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
  }

  export type SousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutPieceInput, SousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousAssemblagePieceCreateWithoutPieceInput[] | SousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutPieceInput | SousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    createMany?: SousAssemblagePieceCreateManyPieceInputEnvelope
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
  }

  export type SousSousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutPieceInput, SousSousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousSousAssemblagePieceCreateWithoutPieceInput[] | SousSousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutPieceInput | SousSousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    createMany?: SousSousAssemblagePieceCreateManyPieceInputEnvelope
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
  }

  export type TaskTemplatePieceUncheckedCreateNestedManyWithoutPieceInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutPieceInput, TaskTemplatePieceUncheckedCreateWithoutPieceInput> | TaskTemplatePieceCreateWithoutPieceInput[] | TaskTemplatePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutPieceInput | TaskTemplatePieceCreateOrConnectWithoutPieceInput[]
    createMany?: TaskTemplatePieceCreateManyPieceInputEnvelope
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
  }

  export type BorneUncheckedCreateNestedManyWithoutPiecesInput = {
    create?: XOR<BorneCreateWithoutPiecesInput, BorneUncheckedCreateWithoutPiecesInput> | BorneCreateWithoutPiecesInput[] | BorneUncheckedCreateWithoutPiecesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutPiecesInput | BorneCreateOrConnectWithoutPiecesInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumPieceEtatFieldUpdateOperationsInput = {
    set?: $Enums.PieceEtat
  }

  export type EnumPieceTypeFieldUpdateOperationsInput = {
    set?: $Enums.PieceType
  }

  export type KitPieceUpdateManyWithoutPieceNestedInput = {
    create?: XOR<KitPieceCreateWithoutPieceInput, KitPieceUncheckedCreateWithoutPieceInput> | KitPieceCreateWithoutPieceInput[] | KitPieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutPieceInput | KitPieceCreateOrConnectWithoutPieceInput[]
    upsert?: KitPieceUpsertWithWhereUniqueWithoutPieceInput | KitPieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: KitPieceCreateManyPieceInputEnvelope
    set?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    disconnect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    delete?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    update?: KitPieceUpdateWithWhereUniqueWithoutPieceInput | KitPieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: KitPieceUpdateManyWithWhereWithoutPieceInput | KitPieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: KitPieceScalarWhereInput | KitPieceScalarWhereInput[]
  }

  export type SousAssemblagePieceUpdateManyWithoutPieceNestedInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutPieceInput, SousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousAssemblagePieceCreateWithoutPieceInput[] | SousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutPieceInput | SousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    upsert?: SousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput | SousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: SousAssemblagePieceCreateManyPieceInputEnvelope
    set?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    delete?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    update?: SousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput | SousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: SousAssemblagePieceUpdateManyWithWhereWithoutPieceInput | SousAssemblagePieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: SousAssemblagePieceScalarWhereInput | SousAssemblagePieceScalarWhereInput[]
  }

  export type SousSousAssemblagePieceUpdateManyWithoutPieceNestedInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutPieceInput, SousSousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousSousAssemblagePieceCreateWithoutPieceInput[] | SousSousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutPieceInput | SousSousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    upsert?: SousSousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput | SousSousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: SousSousAssemblagePieceCreateManyPieceInputEnvelope
    set?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    delete?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    update?: SousSousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput | SousSousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: SousSousAssemblagePieceUpdateManyWithWhereWithoutPieceInput | SousSousAssemblagePieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: SousSousAssemblagePieceScalarWhereInput | SousSousAssemblagePieceScalarWhereInput[]
  }

  export type TaskTemplatePieceUpdateManyWithoutPieceNestedInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutPieceInput, TaskTemplatePieceUncheckedCreateWithoutPieceInput> | TaskTemplatePieceCreateWithoutPieceInput[] | TaskTemplatePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutPieceInput | TaskTemplatePieceCreateOrConnectWithoutPieceInput[]
    upsert?: TaskTemplatePieceUpsertWithWhereUniqueWithoutPieceInput | TaskTemplatePieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: TaskTemplatePieceCreateManyPieceInputEnvelope
    set?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    disconnect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    delete?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    update?: TaskTemplatePieceUpdateWithWhereUniqueWithoutPieceInput | TaskTemplatePieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: TaskTemplatePieceUpdateManyWithWhereWithoutPieceInput | TaskTemplatePieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: TaskTemplatePieceScalarWhereInput | TaskTemplatePieceScalarWhereInput[]
  }

  export type BorneUpdateManyWithoutPiecesNestedInput = {
    create?: XOR<BorneCreateWithoutPiecesInput, BorneUncheckedCreateWithoutPiecesInput> | BorneCreateWithoutPiecesInput[] | BorneUncheckedCreateWithoutPiecesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutPiecesInput | BorneCreateOrConnectWithoutPiecesInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutPiecesInput | BorneUpsertWithWhereUniqueWithoutPiecesInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutPiecesInput | BorneUpdateWithWhereUniqueWithoutPiecesInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutPiecesInput | BorneUpdateManyWithWhereWithoutPiecesInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type KitPieceUncheckedUpdateManyWithoutPieceNestedInput = {
    create?: XOR<KitPieceCreateWithoutPieceInput, KitPieceUncheckedCreateWithoutPieceInput> | KitPieceCreateWithoutPieceInput[] | KitPieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutPieceInput | KitPieceCreateOrConnectWithoutPieceInput[]
    upsert?: KitPieceUpsertWithWhereUniqueWithoutPieceInput | KitPieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: KitPieceCreateManyPieceInputEnvelope
    set?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    disconnect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    delete?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    update?: KitPieceUpdateWithWhereUniqueWithoutPieceInput | KitPieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: KitPieceUpdateManyWithWhereWithoutPieceInput | KitPieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: KitPieceScalarWhereInput | KitPieceScalarWhereInput[]
  }

  export type SousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutPieceInput, SousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousAssemblagePieceCreateWithoutPieceInput[] | SousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutPieceInput | SousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    upsert?: SousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput | SousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: SousAssemblagePieceCreateManyPieceInputEnvelope
    set?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    delete?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    update?: SousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput | SousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: SousAssemblagePieceUpdateManyWithWhereWithoutPieceInput | SousAssemblagePieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: SousAssemblagePieceScalarWhereInput | SousAssemblagePieceScalarWhereInput[]
  }

  export type SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutPieceInput, SousSousAssemblagePieceUncheckedCreateWithoutPieceInput> | SousSousAssemblagePieceCreateWithoutPieceInput[] | SousSousAssemblagePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutPieceInput | SousSousAssemblagePieceCreateOrConnectWithoutPieceInput[]
    upsert?: SousSousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput | SousSousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: SousSousAssemblagePieceCreateManyPieceInputEnvelope
    set?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    delete?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    update?: SousSousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput | SousSousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: SousSousAssemblagePieceUpdateManyWithWhereWithoutPieceInput | SousSousAssemblagePieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: SousSousAssemblagePieceScalarWhereInput | SousSousAssemblagePieceScalarWhereInput[]
  }

  export type TaskTemplatePieceUncheckedUpdateManyWithoutPieceNestedInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutPieceInput, TaskTemplatePieceUncheckedCreateWithoutPieceInput> | TaskTemplatePieceCreateWithoutPieceInput[] | TaskTemplatePieceUncheckedCreateWithoutPieceInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutPieceInput | TaskTemplatePieceCreateOrConnectWithoutPieceInput[]
    upsert?: TaskTemplatePieceUpsertWithWhereUniqueWithoutPieceInput | TaskTemplatePieceUpsertWithWhereUniqueWithoutPieceInput[]
    createMany?: TaskTemplatePieceCreateManyPieceInputEnvelope
    set?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    disconnect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    delete?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    update?: TaskTemplatePieceUpdateWithWhereUniqueWithoutPieceInput | TaskTemplatePieceUpdateWithWhereUniqueWithoutPieceInput[]
    updateMany?: TaskTemplatePieceUpdateManyWithWhereWithoutPieceInput | TaskTemplatePieceUpdateManyWithWhereWithoutPieceInput[]
    deleteMany?: TaskTemplatePieceScalarWhereInput | TaskTemplatePieceScalarWhereInput[]
  }

  export type BorneUncheckedUpdateManyWithoutPiecesNestedInput = {
    create?: XOR<BorneCreateWithoutPiecesInput, BorneUncheckedCreateWithoutPiecesInput> | BorneCreateWithoutPiecesInput[] | BorneUncheckedCreateWithoutPiecesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutPiecesInput | BorneCreateOrConnectWithoutPiecesInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutPiecesInput | BorneUpsertWithWhereUniqueWithoutPiecesInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutPiecesInput | BorneUpdateWithWhereUniqueWithoutPiecesInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutPiecesInput | BorneUpdateManyWithWhereWithoutPiecesInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type SousAssemblagePieceCreateNestedManyWithoutSousAssemblageInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput> | SousAssemblagePieceCreateWithoutSousAssemblageInput[] | SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput | SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput[]
    createMany?: SousAssemblagePieceCreateManySousAssemblageInputEnvelope
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
  }

  export type SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousAssemblageInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousAssemblageInputEnvelope
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
  }

  export type TaskTemplateSousAssemblageCreateNestedManyWithoutSousAssemblageInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput | TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    createMany?: TaskTemplateSousAssemblageCreateManySousAssemblageInputEnvelope
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
  }

  export type BorneCreateNestedManyWithoutSousAssemblagesInput = {
    create?: XOR<BorneCreateWithoutSousAssemblagesInput, BorneUncheckedCreateWithoutSousAssemblagesInput> | BorneCreateWithoutSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousAssemblagesInput | BorneCreateOrConnectWithoutSousAssemblagesInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type SousAssemblagePieceUncheckedCreateNestedManyWithoutSousAssemblageInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput> | SousAssemblagePieceCreateWithoutSousAssemblageInput[] | SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput | SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput[]
    createMany?: SousAssemblagePieceCreateManySousAssemblageInputEnvelope
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
  }

  export type SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousAssemblageInputEnvelope
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
  }

  export type TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput | TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    createMany?: TaskTemplateSousAssemblageCreateManySousAssemblageInputEnvelope
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
  }

  export type BorneUncheckedCreateNestedManyWithoutSousAssemblagesInput = {
    create?: XOR<BorneCreateWithoutSousAssemblagesInput, BorneUncheckedCreateWithoutSousAssemblagesInput> | BorneCreateWithoutSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousAssemblagesInput | BorneCreateOrConnectWithoutSousAssemblagesInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type SousAssemblagePieceUpdateManyWithoutSousAssemblageNestedInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput> | SousAssemblagePieceCreateWithoutSousAssemblageInput[] | SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput | SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput[]
    upsert?: SousAssemblagePieceUpsertWithWhereUniqueWithoutSousAssemblageInput | SousAssemblagePieceUpsertWithWhereUniqueWithoutSousAssemblageInput[]
    createMany?: SousAssemblagePieceCreateManySousAssemblageInputEnvelope
    set?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    delete?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    update?: SousAssemblagePieceUpdateWithWhereUniqueWithoutSousAssemblageInput | SousAssemblagePieceUpdateWithWhereUniqueWithoutSousAssemblageInput[]
    updateMany?: SousAssemblagePieceUpdateManyWithWhereWithoutSousAssemblageInput | SousAssemblagePieceUpdateManyWithWhereWithoutSousAssemblageInput[]
    deleteMany?: SousAssemblagePieceScalarWhereInput | SousAssemblagePieceScalarWhereInput[]
  }

  export type SousAssemblageSousSousAssemblageUpdateManyWithoutSousAssemblageNestedInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    upsert?: SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousAssemblageInputEnvelope
    set?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    disconnect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    delete?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    update?: SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput[]
    updateMany?: SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput[]
    deleteMany?: SousAssemblageSousSousAssemblageScalarWhereInput | SousAssemblageSousSousAssemblageScalarWhereInput[]
  }

  export type TaskTemplateSousAssemblageUpdateManyWithoutSousAssemblageNestedInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput | TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    upsert?: TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput | TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput[]
    createMany?: TaskTemplateSousAssemblageCreateManySousAssemblageInputEnvelope
    set?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput | TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput[]
    updateMany?: TaskTemplateSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput | TaskTemplateSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput[]
    deleteMany?: TaskTemplateSousAssemblageScalarWhereInput | TaskTemplateSousAssemblageScalarWhereInput[]
  }

  export type BorneUpdateManyWithoutSousAssemblagesNestedInput = {
    create?: XOR<BorneCreateWithoutSousAssemblagesInput, BorneUncheckedCreateWithoutSousAssemblagesInput> | BorneCreateWithoutSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousAssemblagesInput | BorneCreateOrConnectWithoutSousAssemblagesInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutSousAssemblagesInput | BorneUpsertWithWhereUniqueWithoutSousAssemblagesInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutSousAssemblagesInput | BorneUpdateWithWhereUniqueWithoutSousAssemblagesInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutSousAssemblagesInput | BorneUpdateManyWithWhereWithoutSousAssemblagesInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageNestedInput = {
    create?: XOR<SousAssemblagePieceCreateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput> | SousAssemblagePieceCreateWithoutSousAssemblageInput[] | SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput | SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput[]
    upsert?: SousAssemblagePieceUpsertWithWhereUniqueWithoutSousAssemblageInput | SousAssemblagePieceUpsertWithWhereUniqueWithoutSousAssemblageInput[]
    createMany?: SousAssemblagePieceCreateManySousAssemblageInputEnvelope
    set?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    delete?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    connect?: SousAssemblagePieceWhereUniqueInput | SousAssemblagePieceWhereUniqueInput[]
    update?: SousAssemblagePieceUpdateWithWhereUniqueWithoutSousAssemblageInput | SousAssemblagePieceUpdateWithWhereUniqueWithoutSousAssemblageInput[]
    updateMany?: SousAssemblagePieceUpdateManyWithWhereWithoutSousAssemblageInput | SousAssemblagePieceUpdateManyWithWhereWithoutSousAssemblageInput[]
    deleteMany?: SousAssemblagePieceScalarWhereInput | SousAssemblagePieceScalarWhereInput[]
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    upsert?: SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousAssemblageInputEnvelope
    set?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    disconnect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    delete?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    update?: SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput[]
    updateMany?: SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput[]
    deleteMany?: SousAssemblageSousSousAssemblageScalarWhereInput | SousAssemblageSousSousAssemblageScalarWhereInput[]
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput> | TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput | TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput[]
    upsert?: TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput | TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput[]
    createMany?: TaskTemplateSousAssemblageCreateManySousAssemblageInputEnvelope
    set?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput | TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput[]
    updateMany?: TaskTemplateSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput | TaskTemplateSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput[]
    deleteMany?: TaskTemplateSousAssemblageScalarWhereInput | TaskTemplateSousAssemblageScalarWhereInput[]
  }

  export type BorneUncheckedUpdateManyWithoutSousAssemblagesNestedInput = {
    create?: XOR<BorneCreateWithoutSousAssemblagesInput, BorneUncheckedCreateWithoutSousAssemblagesInput> | BorneCreateWithoutSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousAssemblagesInput | BorneCreateOrConnectWithoutSousAssemblagesInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutSousAssemblagesInput | BorneUpsertWithWhereUniqueWithoutSousAssemblagesInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutSousAssemblagesInput | BorneUpdateWithWhereUniqueWithoutSousAssemblagesInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutSousAssemblagesInput | BorneUpdateManyWithWhereWithoutSousAssemblagesInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
  }

  export type SousSousAssemblagePieceCreateNestedManyWithoutSousSousAssemblageInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput> | SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput[] | SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput | SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput[]
    createMany?: SousSousAssemblagePieceCreateManySousSousAssemblageInputEnvelope
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
  }

  export type TaskTemplateSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
  }

  export type BorneCreateNestedManyWithoutSousSousAssemblagesInput = {
    create?: XOR<BorneCreateWithoutSousSousAssemblagesInput, BorneUncheckedCreateWithoutSousSousAssemblagesInput> | BorneCreateWithoutSousSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousSousAssemblagesInput | BorneCreateOrConnectWithoutSousSousAssemblagesInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
  }

  export type SousSousAssemblagePieceUncheckedCreateNestedManyWithoutSousSousAssemblageInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput> | SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput[] | SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput | SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput[]
    createMany?: SousSousAssemblagePieceCreateManySousSousAssemblageInputEnvelope
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
  }

  export type TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
  }

  export type BorneUncheckedCreateNestedManyWithoutSousSousAssemblagesInput = {
    create?: XOR<BorneCreateWithoutSousSousAssemblagesInput, BorneUncheckedCreateWithoutSousSousAssemblagesInput> | BorneCreateWithoutSousSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousSousAssemblagesInput | BorneCreateOrConnectWithoutSousSousAssemblagesInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type SousAssemblageSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    upsert?: SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    set?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    disconnect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    delete?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    update?: SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput[]
    updateMany?: SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput[]
    deleteMany?: SousAssemblageSousSousAssemblageScalarWhereInput | SousAssemblageSousSousAssemblageScalarWhereInput[]
  }

  export type SousSousAssemblagePieceUpdateManyWithoutSousSousAssemblageNestedInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput> | SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput[] | SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput | SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput[]
    upsert?: SousSousAssemblagePieceUpsertWithWhereUniqueWithoutSousSousAssemblageInput | SousSousAssemblagePieceUpsertWithWhereUniqueWithoutSousSousAssemblageInput[]
    createMany?: SousSousAssemblagePieceCreateManySousSousAssemblageInputEnvelope
    set?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    delete?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    update?: SousSousAssemblagePieceUpdateWithWhereUniqueWithoutSousSousAssemblageInput | SousSousAssemblagePieceUpdateWithWhereUniqueWithoutSousSousAssemblageInput[]
    updateMany?: SousSousAssemblagePieceUpdateManyWithWhereWithoutSousSousAssemblageInput | SousSousAssemblagePieceUpdateManyWithWhereWithoutSousSousAssemblageInput[]
    deleteMany?: SousSousAssemblagePieceScalarWhereInput | SousSousAssemblagePieceScalarWhereInput[]
  }

  export type TaskTemplateSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    upsert?: TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    set?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput[]
    updateMany?: TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput[]
    deleteMany?: TaskTemplateSousSousAssemblageScalarWhereInput | TaskTemplateSousSousAssemblageScalarWhereInput[]
  }

  export type BorneUpdateManyWithoutSousSousAssemblagesNestedInput = {
    create?: XOR<BorneCreateWithoutSousSousAssemblagesInput, BorneUncheckedCreateWithoutSousSousAssemblagesInput> | BorneCreateWithoutSousSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousSousAssemblagesInput | BorneCreateOrConnectWithoutSousSousAssemblagesInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutSousSousAssemblagesInput | BorneUpsertWithWhereUniqueWithoutSousSousAssemblagesInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutSousSousAssemblagesInput | BorneUpdateWithWhereUniqueWithoutSousSousAssemblagesInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutSousSousAssemblagesInput | BorneUpdateManyWithWhereWithoutSousSousAssemblagesInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput = {
    create?: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    upsert?: SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput[]
    createMany?: SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    set?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    disconnect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    delete?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    connect?: SousAssemblageSousSousAssemblageWhereUniqueInput | SousAssemblageSousSousAssemblageWhereUniqueInput[]
    update?: SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput[]
    updateMany?: SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput | SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput[]
    deleteMany?: SousAssemblageSousSousAssemblageScalarWhereInput | SousAssemblageSousSousAssemblageScalarWhereInput[]
  }

  export type SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageNestedInput = {
    create?: XOR<SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput> | SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput[] | SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput | SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput[]
    upsert?: SousSousAssemblagePieceUpsertWithWhereUniqueWithoutSousSousAssemblageInput | SousSousAssemblagePieceUpsertWithWhereUniqueWithoutSousSousAssemblageInput[]
    createMany?: SousSousAssemblagePieceCreateManySousSousAssemblageInputEnvelope
    set?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    disconnect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    delete?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    connect?: SousSousAssemblagePieceWhereUniqueInput | SousSousAssemblagePieceWhereUniqueInput[]
    update?: SousSousAssemblagePieceUpdateWithWhereUniqueWithoutSousSousAssemblageInput | SousSousAssemblagePieceUpdateWithWhereUniqueWithoutSousSousAssemblageInput[]
    updateMany?: SousSousAssemblagePieceUpdateManyWithWhereWithoutSousSousAssemblageInput | SousSousAssemblagePieceUpdateManyWithWhereWithoutSousSousAssemblageInput[]
    deleteMany?: SousSousAssemblagePieceScalarWhereInput | SousSousAssemblagePieceScalarWhereInput[]
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput> | TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput[]
    upsert?: TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInputEnvelope
    set?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput[]
    updateMany?: TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput | TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput[]
    deleteMany?: TaskTemplateSousSousAssemblageScalarWhereInput | TaskTemplateSousSousAssemblageScalarWhereInput[]
  }

  export type BorneUncheckedUpdateManyWithoutSousSousAssemblagesNestedInput = {
    create?: XOR<BorneCreateWithoutSousSousAssemblagesInput, BorneUncheckedCreateWithoutSousSousAssemblagesInput> | BorneCreateWithoutSousSousAssemblagesInput[] | BorneUncheckedCreateWithoutSousSousAssemblagesInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutSousSousAssemblagesInput | BorneCreateOrConnectWithoutSousSousAssemblagesInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutSousSousAssemblagesInput | BorneUpsertWithWhereUniqueWithoutSousSousAssemblagesInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutSousSousAssemblagesInput | BorneUpdateWithWhereUniqueWithoutSousSousAssemblagesInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutSousSousAssemblagesInput | BorneUpdateManyWithWhereWithoutSousSousAssemblagesInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type KitPieceCreateNestedManyWithoutKitInput = {
    create?: XOR<KitPieceCreateWithoutKitInput, KitPieceUncheckedCreateWithoutKitInput> | KitPieceCreateWithoutKitInput[] | KitPieceUncheckedCreateWithoutKitInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutKitInput | KitPieceCreateOrConnectWithoutKitInput[]
    createMany?: KitPieceCreateManyKitInputEnvelope
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
  }

  export type BorneCreateNestedManyWithoutKitsInput = {
    create?: XOR<BorneCreateWithoutKitsInput, BorneUncheckedCreateWithoutKitsInput> | BorneCreateWithoutKitsInput[] | BorneUncheckedCreateWithoutKitsInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutKitsInput | BorneCreateOrConnectWithoutKitsInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type KitPieceUncheckedCreateNestedManyWithoutKitInput = {
    create?: XOR<KitPieceCreateWithoutKitInput, KitPieceUncheckedCreateWithoutKitInput> | KitPieceCreateWithoutKitInput[] | KitPieceUncheckedCreateWithoutKitInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutKitInput | KitPieceCreateOrConnectWithoutKitInput[]
    createMany?: KitPieceCreateManyKitInputEnvelope
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
  }

  export type BorneUncheckedCreateNestedManyWithoutKitsInput = {
    create?: XOR<BorneCreateWithoutKitsInput, BorneUncheckedCreateWithoutKitsInput> | BorneCreateWithoutKitsInput[] | BorneUncheckedCreateWithoutKitsInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutKitsInput | BorneCreateOrConnectWithoutKitsInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
  }

  export type KitPieceUpdateManyWithoutKitNestedInput = {
    create?: XOR<KitPieceCreateWithoutKitInput, KitPieceUncheckedCreateWithoutKitInput> | KitPieceCreateWithoutKitInput[] | KitPieceUncheckedCreateWithoutKitInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutKitInput | KitPieceCreateOrConnectWithoutKitInput[]
    upsert?: KitPieceUpsertWithWhereUniqueWithoutKitInput | KitPieceUpsertWithWhereUniqueWithoutKitInput[]
    createMany?: KitPieceCreateManyKitInputEnvelope
    set?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    disconnect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    delete?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    update?: KitPieceUpdateWithWhereUniqueWithoutKitInput | KitPieceUpdateWithWhereUniqueWithoutKitInput[]
    updateMany?: KitPieceUpdateManyWithWhereWithoutKitInput | KitPieceUpdateManyWithWhereWithoutKitInput[]
    deleteMany?: KitPieceScalarWhereInput | KitPieceScalarWhereInput[]
  }

  export type BorneUpdateManyWithoutKitsNestedInput = {
    create?: XOR<BorneCreateWithoutKitsInput, BorneUncheckedCreateWithoutKitsInput> | BorneCreateWithoutKitsInput[] | BorneUncheckedCreateWithoutKitsInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutKitsInput | BorneCreateOrConnectWithoutKitsInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutKitsInput | BorneUpsertWithWhereUniqueWithoutKitsInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutKitsInput | BorneUpdateWithWhereUniqueWithoutKitsInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutKitsInput | BorneUpdateManyWithWhereWithoutKitsInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type KitPieceUncheckedUpdateManyWithoutKitNestedInput = {
    create?: XOR<KitPieceCreateWithoutKitInput, KitPieceUncheckedCreateWithoutKitInput> | KitPieceCreateWithoutKitInput[] | KitPieceUncheckedCreateWithoutKitInput[]
    connectOrCreate?: KitPieceCreateOrConnectWithoutKitInput | KitPieceCreateOrConnectWithoutKitInput[]
    upsert?: KitPieceUpsertWithWhereUniqueWithoutKitInput | KitPieceUpsertWithWhereUniqueWithoutKitInput[]
    createMany?: KitPieceCreateManyKitInputEnvelope
    set?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    disconnect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    delete?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    connect?: KitPieceWhereUniqueInput | KitPieceWhereUniqueInput[]
    update?: KitPieceUpdateWithWhereUniqueWithoutKitInput | KitPieceUpdateWithWhereUniqueWithoutKitInput[]
    updateMany?: KitPieceUpdateManyWithWhereWithoutKitInput | KitPieceUpdateManyWithWhereWithoutKitInput[]
    deleteMany?: KitPieceScalarWhereInput | KitPieceScalarWhereInput[]
  }

  export type BorneUncheckedUpdateManyWithoutKitsNestedInput = {
    create?: XOR<BorneCreateWithoutKitsInput, BorneUncheckedCreateWithoutKitsInput> | BorneCreateWithoutKitsInput[] | BorneUncheckedCreateWithoutKitsInput[]
    connectOrCreate?: BorneCreateOrConnectWithoutKitsInput | BorneCreateOrConnectWithoutKitsInput[]
    upsert?: BorneUpsertWithWhereUniqueWithoutKitsInput | BorneUpsertWithWhereUniqueWithoutKitsInput[]
    set?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    disconnect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    delete?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    connect?: BorneWhereUniqueInput | BorneWhereUniqueInput[]
    update?: BorneUpdateWithWhereUniqueWithoutKitsInput | BorneUpdateWithWhereUniqueWithoutKitsInput[]
    updateMany?: BorneUpdateManyWithWhereWithoutKitsInput | BorneUpdateManyWithWhereWithoutKitsInput[]
    deleteMany?: BorneScalarWhereInput | BorneScalarWhereInput[]
  }

  export type PieceCreateNestedOneWithoutSousAssemblagesInput = {
    create?: XOR<PieceCreateWithoutSousAssemblagesInput, PieceUncheckedCreateWithoutSousAssemblagesInput>
    connectOrCreate?: PieceCreateOrConnectWithoutSousAssemblagesInput
    connect?: PieceWhereUniqueInput
  }

  export type SousAssemblageCreateNestedOneWithoutPiecesInput = {
    create?: XOR<SousAssemblageCreateWithoutPiecesInput, SousAssemblageUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutPiecesInput
    connect?: SousAssemblageWhereUniqueInput
  }

  export type PieceUpdateOneRequiredWithoutSousAssemblagesNestedInput = {
    create?: XOR<PieceCreateWithoutSousAssemblagesInput, PieceUncheckedCreateWithoutSousAssemblagesInput>
    connectOrCreate?: PieceCreateOrConnectWithoutSousAssemblagesInput
    upsert?: PieceUpsertWithoutSousAssemblagesInput
    connect?: PieceWhereUniqueInput
    update?: XOR<XOR<PieceUpdateToOneWithWhereWithoutSousAssemblagesInput, PieceUpdateWithoutSousAssemblagesInput>, PieceUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type SousAssemblageUpdateOneRequiredWithoutPiecesNestedInput = {
    create?: XOR<SousAssemblageCreateWithoutPiecesInput, SousAssemblageUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutPiecesInput
    upsert?: SousAssemblageUpsertWithoutPiecesInput
    connect?: SousAssemblageWhereUniqueInput
    update?: XOR<XOR<SousAssemblageUpdateToOneWithWhereWithoutPiecesInput, SousAssemblageUpdateWithoutPiecesInput>, SousAssemblageUncheckedUpdateWithoutPiecesInput>
  }

  export type PieceCreateNestedOneWithoutSousSousAssemblagesInput = {
    create?: XOR<PieceCreateWithoutSousSousAssemblagesInput, PieceUncheckedCreateWithoutSousSousAssemblagesInput>
    connectOrCreate?: PieceCreateOrConnectWithoutSousSousAssemblagesInput
    connect?: PieceWhereUniqueInput
  }

  export type SousSousAssemblageCreateNestedOneWithoutPiecesInput = {
    create?: XOR<SousSousAssemblageCreateWithoutPiecesInput, SousSousAssemblageUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutPiecesInput
    connect?: SousSousAssemblageWhereUniqueInput
  }

  export type PieceUpdateOneRequiredWithoutSousSousAssemblagesNestedInput = {
    create?: XOR<PieceCreateWithoutSousSousAssemblagesInput, PieceUncheckedCreateWithoutSousSousAssemblagesInput>
    connectOrCreate?: PieceCreateOrConnectWithoutSousSousAssemblagesInput
    upsert?: PieceUpsertWithoutSousSousAssemblagesInput
    connect?: PieceWhereUniqueInput
    update?: XOR<XOR<PieceUpdateToOneWithWhereWithoutSousSousAssemblagesInput, PieceUpdateWithoutSousSousAssemblagesInput>, PieceUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type SousSousAssemblageUpdateOneRequiredWithoutPiecesNestedInput = {
    create?: XOR<SousSousAssemblageCreateWithoutPiecesInput, SousSousAssemblageUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutPiecesInput
    upsert?: SousSousAssemblageUpsertWithoutPiecesInput
    connect?: SousSousAssemblageWhereUniqueInput
    update?: XOR<XOR<SousSousAssemblageUpdateToOneWithWhereWithoutPiecesInput, SousSousAssemblageUpdateWithoutPiecesInput>, SousSousAssemblageUncheckedUpdateWithoutPiecesInput>
  }

  export type SousAssemblageCreateNestedOneWithoutSousSousAssemblagesInput = {
    create?: XOR<SousAssemblageCreateWithoutSousSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutSousSousAssemblagesInput>
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutSousSousAssemblagesInput
    connect?: SousAssemblageWhereUniqueInput
  }

  export type SousSousAssemblageCreateNestedOneWithoutSousAssemblagesInput = {
    create?: XOR<SousSousAssemblageCreateWithoutSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutSousAssemblagesInput>
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutSousAssemblagesInput
    connect?: SousSousAssemblageWhereUniqueInput
  }

  export type SousAssemblageUpdateOneRequiredWithoutSousSousAssemblagesNestedInput = {
    create?: XOR<SousAssemblageCreateWithoutSousSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutSousSousAssemblagesInput>
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutSousSousAssemblagesInput
    upsert?: SousAssemblageUpsertWithoutSousSousAssemblagesInput
    connect?: SousAssemblageWhereUniqueInput
    update?: XOR<XOR<SousAssemblageUpdateToOneWithWhereWithoutSousSousAssemblagesInput, SousAssemblageUpdateWithoutSousSousAssemblagesInput>, SousAssemblageUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type SousSousAssemblageUpdateOneRequiredWithoutSousAssemblagesNestedInput = {
    create?: XOR<SousSousAssemblageCreateWithoutSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutSousAssemblagesInput>
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutSousAssemblagesInput
    upsert?: SousSousAssemblageUpsertWithoutSousAssemblagesInput
    connect?: SousSousAssemblageWhereUniqueInput
    update?: XOR<XOR<SousSousAssemblageUpdateToOneWithWhereWithoutSousAssemblagesInput, SousSousAssemblageUpdateWithoutSousAssemblagesInput>, SousSousAssemblageUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type KitCreateNestedOneWithoutPiecesInput = {
    create?: XOR<KitCreateWithoutPiecesInput, KitUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: KitCreateOrConnectWithoutPiecesInput
    connect?: KitWhereUniqueInput
  }

  export type PieceCreateNestedOneWithoutKitsInput = {
    create?: XOR<PieceCreateWithoutKitsInput, PieceUncheckedCreateWithoutKitsInput>
    connectOrCreate?: PieceCreateOrConnectWithoutKitsInput
    connect?: PieceWhereUniqueInput
  }

  export type KitUpdateOneRequiredWithoutPiecesNestedInput = {
    create?: XOR<KitCreateWithoutPiecesInput, KitUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: KitCreateOrConnectWithoutPiecesInput
    upsert?: KitUpsertWithoutPiecesInput
    connect?: KitWhereUniqueInput
    update?: XOR<XOR<KitUpdateToOneWithWhereWithoutPiecesInput, KitUpdateWithoutPiecesInput>, KitUncheckedUpdateWithoutPiecesInput>
  }

  export type PieceUpdateOneRequiredWithoutKitsNestedInput = {
    create?: XOR<PieceCreateWithoutKitsInput, PieceUncheckedCreateWithoutKitsInput>
    connectOrCreate?: PieceCreateOrConnectWithoutKitsInput
    upsert?: PieceUpsertWithoutKitsInput
    connect?: PieceWhereUniqueInput
    update?: XOR<XOR<PieceUpdateToOneWithWhereWithoutKitsInput, PieceUpdateWithoutKitsInput>, PieceUncheckedUpdateWithoutKitsInput>
  }

  export type UserCreateNestedOneWithoutStockLogsInput = {
    create?: XOR<UserCreateWithoutStockLogsInput, UserUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStockOperationFieldUpdateOperationsInput = {
    set?: $Enums.StockOperation
  }

  export type UserUpdateOneWithoutStockLogsNestedInput = {
    create?: XOR<UserCreateWithoutStockLogsInput, UserUncheckedCreateWithoutStockLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockLogsInput
    upsert?: UserUpsertWithoutStockLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockLogsInput, UserUpdateWithoutStockLogsInput>, UserUncheckedUpdateWithoutStockLogsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductionTaskCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ProductionTaskCreateWithoutTemplateInput, ProductionTaskUncheckedCreateWithoutTemplateInput> | ProductionTaskCreateWithoutTemplateInput[] | ProductionTaskUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutTemplateInput | ProductionTaskCreateOrConnectWithoutTemplateInput[]
    createMany?: ProductionTaskCreateManyTemplateInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type BorneCreateNestedOneWithoutTaskTemplatesInput = {
    create?: XOR<BorneCreateWithoutTaskTemplatesInput, BorneUncheckedCreateWithoutTaskTemplatesInput>
    connectOrCreate?: BorneCreateOrConnectWithoutTaskTemplatesInput
    connect?: BorneWhereUniqueInput
  }

  export type TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplateLogCreateWithoutTaskTemplateInput, TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateLogCreateWithoutTaskTemplateInput[] | TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput | TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplateLogCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
  }

  export type TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput> | TaskTemplatePieceCreateWithoutTaskTemplateInput[] | TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput | TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplatePieceCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
  }

  export type TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousAssemblageCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
  }

  export type TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
  }

  export type ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ProductionTaskCreateWithoutTemplateInput, ProductionTaskUncheckedCreateWithoutTemplateInput> | ProductionTaskCreateWithoutTemplateInput[] | ProductionTaskUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutTemplateInput | ProductionTaskCreateOrConnectWithoutTemplateInput[]
    createMany?: ProductionTaskCreateManyTemplateInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplateLogCreateWithoutTaskTemplateInput, TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateLogCreateWithoutTaskTemplateInput[] | TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput | TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplateLogCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
  }

  export type TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput> | TaskTemplatePieceCreateWithoutTaskTemplateInput[] | TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput | TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplatePieceCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
  }

  export type TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousAssemblageCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
  }

  export type TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManyTaskTemplateInputEnvelope
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
  }

  export type ProductionTaskUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutTemplateInput, ProductionTaskUncheckedCreateWithoutTemplateInput> | ProductionTaskCreateWithoutTemplateInput[] | ProductionTaskUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutTemplateInput | ProductionTaskCreateOrConnectWithoutTemplateInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutTemplateInput | ProductionTaskUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ProductionTaskCreateManyTemplateInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutTemplateInput | ProductionTaskUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutTemplateInput | ProductionTaskUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type BorneUpdateOneWithoutTaskTemplatesNestedInput = {
    create?: XOR<BorneCreateWithoutTaskTemplatesInput, BorneUncheckedCreateWithoutTaskTemplatesInput>
    connectOrCreate?: BorneCreateOrConnectWithoutTaskTemplatesInput
    upsert?: BorneUpsertWithoutTaskTemplatesInput
    disconnect?: BorneWhereInput | boolean
    delete?: BorneWhereInput | boolean
    connect?: BorneWhereUniqueInput
    update?: XOR<XOR<BorneUpdateToOneWithWhereWithoutTaskTemplatesInput, BorneUpdateWithoutTaskTemplatesInput>, BorneUncheckedUpdateWithoutTaskTemplatesInput>
  }

  export type TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplateLogCreateWithoutTaskTemplateInput, TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateLogCreateWithoutTaskTemplateInput[] | TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput | TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplateLogUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateLogUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplateLogCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    disconnect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    delete?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    update?: TaskTemplateLogUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateLogUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplateLogUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplateLogUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplateLogScalarWhereInput | TaskTemplateLogScalarWhereInput[]
  }

  export type TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput> | TaskTemplatePieceCreateWithoutTaskTemplateInput[] | TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput | TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplatePieceUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplatePieceUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplatePieceCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    disconnect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    delete?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    update?: TaskTemplatePieceUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplatePieceUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplatePieceUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplatePieceUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplatePieceScalarWhereInput | TaskTemplatePieceScalarWhereInput[]
  }

  export type TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousAssemblageCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplateSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplateSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplateSousAssemblageScalarWhereInput | TaskTemplateSousAssemblageScalarWhereInput[]
  }

  export type TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplateSousSousAssemblageScalarWhereInput | TaskTemplateSousSousAssemblageScalarWhereInput[]
  }

  export type ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutTemplateInput, ProductionTaskUncheckedCreateWithoutTemplateInput> | ProductionTaskCreateWithoutTemplateInput[] | ProductionTaskUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutTemplateInput | ProductionTaskCreateOrConnectWithoutTemplateInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutTemplateInput | ProductionTaskUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ProductionTaskCreateManyTemplateInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutTemplateInput | ProductionTaskUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutTemplateInput | ProductionTaskUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplateLogCreateWithoutTaskTemplateInput, TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateLogCreateWithoutTaskTemplateInput[] | TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput | TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplateLogUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateLogUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplateLogCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    disconnect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    delete?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    connect?: TaskTemplateLogWhereUniqueInput | TaskTemplateLogWhereUniqueInput[]
    update?: TaskTemplateLogUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateLogUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplateLogUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplateLogUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplateLogScalarWhereInput | TaskTemplateLogScalarWhereInput[]
  }

  export type TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplatePieceCreateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput> | TaskTemplatePieceCreateWithoutTaskTemplateInput[] | TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput | TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplatePieceUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplatePieceUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplatePieceCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    disconnect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    delete?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    connect?: TaskTemplatePieceWhereUniqueInput | TaskTemplatePieceWhereUniqueInput[]
    update?: TaskTemplatePieceUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplatePieceUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplatePieceUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplatePieceUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplatePieceScalarWhereInput | TaskTemplatePieceScalarWhereInput[]
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousAssemblageCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousAssemblageWhereUniqueInput | TaskTemplateSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplateSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplateSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplateSousAssemblageScalarWhereInput | TaskTemplateSousAssemblageScalarWhereInput[]
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput = {
    create?: XOR<TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput> | TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput[] | TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput[]
    connectOrCreate?: TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput[]
    upsert?: TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput[]
    createMany?: TaskTemplateSousSousAssemblageCreateManyTaskTemplateInputEnvelope
    set?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    disconnect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    delete?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    connect?: TaskTemplateSousSousAssemblageWhereUniqueInput | TaskTemplateSousSousAssemblageWhereUniqueInput[]
    update?: TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput[]
    updateMany?: TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput | TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput[]
    deleteMany?: TaskTemplateSousSousAssemblageScalarWhereInput | TaskTemplateSousSousAssemblageScalarWhereInput[]
  }

  export type ProductionLineCreateNestedManyWithoutProductionInput = {
    create?: XOR<ProductionLineCreateWithoutProductionInput, ProductionLineUncheckedCreateWithoutProductionInput> | ProductionLineCreateWithoutProductionInput[] | ProductionLineUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutProductionInput | ProductionLineCreateOrConnectWithoutProductionInput[]
    createMany?: ProductionLineCreateManyProductionInputEnvelope
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
  }

  export type ProductionTaskCreateNestedManyWithoutProductionInput = {
    create?: XOR<ProductionTaskCreateWithoutProductionInput, ProductionTaskUncheckedCreateWithoutProductionInput> | ProductionTaskCreateWithoutProductionInput[] | ProductionTaskUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutProductionInput | ProductionTaskCreateOrConnectWithoutProductionInput[]
    createMany?: ProductionTaskCreateManyProductionInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type ProductionLineUncheckedCreateNestedManyWithoutProductionInput = {
    create?: XOR<ProductionLineCreateWithoutProductionInput, ProductionLineUncheckedCreateWithoutProductionInput> | ProductionLineCreateWithoutProductionInput[] | ProductionLineUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutProductionInput | ProductionLineCreateOrConnectWithoutProductionInput[]
    createMany?: ProductionLineCreateManyProductionInputEnvelope
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
  }

  export type ProductionTaskUncheckedCreateNestedManyWithoutProductionInput = {
    create?: XOR<ProductionTaskCreateWithoutProductionInput, ProductionTaskUncheckedCreateWithoutProductionInput> | ProductionTaskCreateWithoutProductionInput[] | ProductionTaskUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutProductionInput | ProductionTaskCreateOrConnectWithoutProductionInput[]
    createMany?: ProductionTaskCreateManyProductionInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type EnumProductionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductionStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProductionLineUpdateManyWithoutProductionNestedInput = {
    create?: XOR<ProductionLineCreateWithoutProductionInput, ProductionLineUncheckedCreateWithoutProductionInput> | ProductionLineCreateWithoutProductionInput[] | ProductionLineUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutProductionInput | ProductionLineCreateOrConnectWithoutProductionInput[]
    upsert?: ProductionLineUpsertWithWhereUniqueWithoutProductionInput | ProductionLineUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: ProductionLineCreateManyProductionInputEnvelope
    set?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    disconnect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    delete?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    update?: ProductionLineUpdateWithWhereUniqueWithoutProductionInput | ProductionLineUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: ProductionLineUpdateManyWithWhereWithoutProductionInput | ProductionLineUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: ProductionLineScalarWhereInput | ProductionLineScalarWhereInput[]
  }

  export type ProductionTaskUpdateManyWithoutProductionNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutProductionInput, ProductionTaskUncheckedCreateWithoutProductionInput> | ProductionTaskCreateWithoutProductionInput[] | ProductionTaskUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutProductionInput | ProductionTaskCreateOrConnectWithoutProductionInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutProductionInput | ProductionTaskUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: ProductionTaskCreateManyProductionInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutProductionInput | ProductionTaskUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutProductionInput | ProductionTaskUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type ProductionLineUncheckedUpdateManyWithoutProductionNestedInput = {
    create?: XOR<ProductionLineCreateWithoutProductionInput, ProductionLineUncheckedCreateWithoutProductionInput> | ProductionLineCreateWithoutProductionInput[] | ProductionLineUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionLineCreateOrConnectWithoutProductionInput | ProductionLineCreateOrConnectWithoutProductionInput[]
    upsert?: ProductionLineUpsertWithWhereUniqueWithoutProductionInput | ProductionLineUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: ProductionLineCreateManyProductionInputEnvelope
    set?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    disconnect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    delete?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    connect?: ProductionLineWhereUniqueInput | ProductionLineWhereUniqueInput[]
    update?: ProductionLineUpdateWithWhereUniqueWithoutProductionInput | ProductionLineUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: ProductionLineUpdateManyWithWhereWithoutProductionInput | ProductionLineUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: ProductionLineScalarWhereInput | ProductionLineScalarWhereInput[]
  }

  export type ProductionTaskUncheckedUpdateManyWithoutProductionNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutProductionInput, ProductionTaskUncheckedCreateWithoutProductionInput> | ProductionTaskCreateWithoutProductionInput[] | ProductionTaskUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutProductionInput | ProductionTaskCreateOrConnectWithoutProductionInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutProductionInput | ProductionTaskUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: ProductionTaskCreateManyProductionInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutProductionInput | ProductionTaskUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutProductionInput | ProductionTaskUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type BorneCreateNestedOneWithoutProductionLinesInput = {
    create?: XOR<BorneCreateWithoutProductionLinesInput, BorneUncheckedCreateWithoutProductionLinesInput>
    connectOrCreate?: BorneCreateOrConnectWithoutProductionLinesInput
    connect?: BorneWhereUniqueInput
  }

  export type ProductionCreateNestedOneWithoutLinesInput = {
    create?: XOR<ProductionCreateWithoutLinesInput, ProductionUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ProductionCreateOrConnectWithoutLinesInput
    connect?: ProductionWhereUniqueInput
  }

  export type BorneUpdateOneRequiredWithoutProductionLinesNestedInput = {
    create?: XOR<BorneCreateWithoutProductionLinesInput, BorneUncheckedCreateWithoutProductionLinesInput>
    connectOrCreate?: BorneCreateOrConnectWithoutProductionLinesInput
    upsert?: BorneUpsertWithoutProductionLinesInput
    connect?: BorneWhereUniqueInput
    update?: XOR<XOR<BorneUpdateToOneWithWhereWithoutProductionLinesInput, BorneUpdateWithoutProductionLinesInput>, BorneUncheckedUpdateWithoutProductionLinesInput>
  }

  export type ProductionUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<ProductionCreateWithoutLinesInput, ProductionUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ProductionCreateOrConnectWithoutLinesInput
    upsert?: ProductionUpsertWithoutLinesInput
    connect?: ProductionWhereUniqueInput
    update?: XOR<XOR<ProductionUpdateToOneWithWhereWithoutLinesInput, ProductionUpdateWithoutLinesInput>, ProductionUncheckedUpdateWithoutLinesInput>
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProductionCreateWithoutTasksInput, ProductionUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProductionCreateOrConnectWithoutTasksInput
    connect?: ProductionWhereUniqueInput
  }

  export type TaskTemplateCreateNestedOneWithoutProductionTasksInput = {
    create?: XOR<TaskTemplateCreateWithoutProductionTasksInput, TaskTemplateUncheckedCreateWithoutProductionTasksInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutProductionTasksInput
    connect?: TaskTemplateWhereUniqueInput
  }

  export type ProductionTaskLogCreateNestedManyWithoutProductionTaskInput = {
    create?: XOR<ProductionTaskLogCreateWithoutProductionTaskInput, ProductionTaskLogUncheckedCreateWithoutProductionTaskInput> | ProductionTaskLogCreateWithoutProductionTaskInput[] | ProductionTaskLogUncheckedCreateWithoutProductionTaskInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutProductionTaskInput | ProductionTaskLogCreateOrConnectWithoutProductionTaskInput[]
    createMany?: ProductionTaskLogCreateManyProductionTaskInputEnvelope
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
  }

  export type ProductionTaskLogUncheckedCreateNestedManyWithoutProductionTaskInput = {
    create?: XOR<ProductionTaskLogCreateWithoutProductionTaskInput, ProductionTaskLogUncheckedCreateWithoutProductionTaskInput> | ProductionTaskLogCreateWithoutProductionTaskInput[] | ProductionTaskLogUncheckedCreateWithoutProductionTaskInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutProductionTaskInput | ProductionTaskLogCreateOrConnectWithoutProductionTaskInput[]
    createMany?: ProductionTaskLogCreateManyProductionTaskInputEnvelope
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type ProductionUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProductionCreateWithoutTasksInput, ProductionUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProductionCreateOrConnectWithoutTasksInput
    upsert?: ProductionUpsertWithoutTasksInput
    connect?: ProductionWhereUniqueInput
    update?: XOR<XOR<ProductionUpdateToOneWithWhereWithoutTasksInput, ProductionUpdateWithoutTasksInput>, ProductionUncheckedUpdateWithoutTasksInput>
  }

  export type TaskTemplateUpdateOneWithoutProductionTasksNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutProductionTasksInput, TaskTemplateUncheckedCreateWithoutProductionTasksInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutProductionTasksInput
    upsert?: TaskTemplateUpsertWithoutProductionTasksInput
    disconnect?: TaskTemplateWhereInput | boolean
    delete?: TaskTemplateWhereInput | boolean
    connect?: TaskTemplateWhereUniqueInput
    update?: XOR<XOR<TaskTemplateUpdateToOneWithWhereWithoutProductionTasksInput, TaskTemplateUpdateWithoutProductionTasksInput>, TaskTemplateUncheckedUpdateWithoutProductionTasksInput>
  }

  export type ProductionTaskLogUpdateManyWithoutProductionTaskNestedInput = {
    create?: XOR<ProductionTaskLogCreateWithoutProductionTaskInput, ProductionTaskLogUncheckedCreateWithoutProductionTaskInput> | ProductionTaskLogCreateWithoutProductionTaskInput[] | ProductionTaskLogUncheckedCreateWithoutProductionTaskInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutProductionTaskInput | ProductionTaskLogCreateOrConnectWithoutProductionTaskInput[]
    upsert?: ProductionTaskLogUpsertWithWhereUniqueWithoutProductionTaskInput | ProductionTaskLogUpsertWithWhereUniqueWithoutProductionTaskInput[]
    createMany?: ProductionTaskLogCreateManyProductionTaskInputEnvelope
    set?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    disconnect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    delete?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    update?: ProductionTaskLogUpdateWithWhereUniqueWithoutProductionTaskInput | ProductionTaskLogUpdateWithWhereUniqueWithoutProductionTaskInput[]
    updateMany?: ProductionTaskLogUpdateManyWithWhereWithoutProductionTaskInput | ProductionTaskLogUpdateManyWithWhereWithoutProductionTaskInput[]
    deleteMany?: ProductionTaskLogScalarWhereInput | ProductionTaskLogScalarWhereInput[]
  }

  export type ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskNestedInput = {
    create?: XOR<ProductionTaskLogCreateWithoutProductionTaskInput, ProductionTaskLogUncheckedCreateWithoutProductionTaskInput> | ProductionTaskLogCreateWithoutProductionTaskInput[] | ProductionTaskLogUncheckedCreateWithoutProductionTaskInput[]
    connectOrCreate?: ProductionTaskLogCreateOrConnectWithoutProductionTaskInput | ProductionTaskLogCreateOrConnectWithoutProductionTaskInput[]
    upsert?: ProductionTaskLogUpsertWithWhereUniqueWithoutProductionTaskInput | ProductionTaskLogUpsertWithWhereUniqueWithoutProductionTaskInput[]
    createMany?: ProductionTaskLogCreateManyProductionTaskInputEnvelope
    set?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    disconnect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    delete?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    connect?: ProductionTaskLogWhereUniqueInput | ProductionTaskLogWhereUniqueInput[]
    update?: ProductionTaskLogUpdateWithWhereUniqueWithoutProductionTaskInput | ProductionTaskLogUpdateWithWhereUniqueWithoutProductionTaskInput[]
    updateMany?: ProductionTaskLogUpdateManyWithWhereWithoutProductionTaskInput | ProductionTaskLogUpdateManyWithWhereWithoutProductionTaskInput[]
    deleteMany?: ProductionTaskLogScalarWhereInput | ProductionTaskLogScalarWhereInput[]
  }

  export type ProductionTaskCreateNestedOneWithoutLogsInput = {
    create?: XOR<ProductionTaskCreateWithoutLogsInput, ProductionTaskUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutLogsInput
    connect?: ProductionTaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskLogsInput = {
    create?: XOR<UserCreateWithoutTaskLogsInput, UserUncheckedCreateWithoutTaskLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaskEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskEventType
  }

  export type ProductionTaskUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutLogsInput, ProductionTaskUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutLogsInput
    upsert?: ProductionTaskUpsertWithoutLogsInput
    connect?: ProductionTaskWhereUniqueInput
    update?: XOR<XOR<ProductionTaskUpdateToOneWithWhereWithoutLogsInput, ProductionTaskUpdateWithoutLogsInput>, ProductionTaskUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneWithoutTaskLogsNestedInput = {
    create?: XOR<UserCreateWithoutTaskLogsInput, UserUncheckedCreateWithoutTaskLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskLogsInput
    upsert?: UserUpsertWithoutTaskLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskLogsInput, UserUpdateWithoutTaskLogsInput>, UserUncheckedUpdateWithoutTaskLogsInput>
  }

  export type PieceCreateNestedOneWithoutTaskTemplatePiecesInput = {
    create?: XOR<PieceCreateWithoutTaskTemplatePiecesInput, PieceUncheckedCreateWithoutTaskTemplatePiecesInput>
    connectOrCreate?: PieceCreateOrConnectWithoutTaskTemplatePiecesInput
    connect?: PieceWhereUniqueInput
  }

  export type TaskTemplateCreateNestedOneWithoutPiecesInput = {
    create?: XOR<TaskTemplateCreateWithoutPiecesInput, TaskTemplateUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutPiecesInput
    connect?: TaskTemplateWhereUniqueInput
  }

  export type PieceUpdateOneRequiredWithoutTaskTemplatePiecesNestedInput = {
    create?: XOR<PieceCreateWithoutTaskTemplatePiecesInput, PieceUncheckedCreateWithoutTaskTemplatePiecesInput>
    connectOrCreate?: PieceCreateOrConnectWithoutTaskTemplatePiecesInput
    upsert?: PieceUpsertWithoutTaskTemplatePiecesInput
    connect?: PieceWhereUniqueInput
    update?: XOR<XOR<PieceUpdateToOneWithWhereWithoutTaskTemplatePiecesInput, PieceUpdateWithoutTaskTemplatePiecesInput>, PieceUncheckedUpdateWithoutTaskTemplatePiecesInput>
  }

  export type TaskTemplateUpdateOneRequiredWithoutPiecesNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutPiecesInput, TaskTemplateUncheckedCreateWithoutPiecesInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutPiecesInput
    upsert?: TaskTemplateUpsertWithoutPiecesInput
    connect?: TaskTemplateWhereUniqueInput
    update?: XOR<XOR<TaskTemplateUpdateToOneWithWhereWithoutPiecesInput, TaskTemplateUpdateWithoutPiecesInput>, TaskTemplateUncheckedUpdateWithoutPiecesInput>
  }

  export type SousAssemblageCreateNestedOneWithoutTaskTemplateSousAssemblagesInput = {
    create?: XOR<SousAssemblageCreateWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutTaskTemplateSousAssemblagesInput>
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutTaskTemplateSousAssemblagesInput
    connect?: SousAssemblageWhereUniqueInput
  }

  export type TaskTemplateCreateNestedOneWithoutSousAssemblagesInput = {
    create?: XOR<TaskTemplateCreateWithoutSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousAssemblagesInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutSousAssemblagesInput
    connect?: TaskTemplateWhereUniqueInput
  }

  export type SousAssemblageUpdateOneRequiredWithoutTaskTemplateSousAssemblagesNestedInput = {
    create?: XOR<SousAssemblageCreateWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutTaskTemplateSousAssemblagesInput>
    connectOrCreate?: SousAssemblageCreateOrConnectWithoutTaskTemplateSousAssemblagesInput
    upsert?: SousAssemblageUpsertWithoutTaskTemplateSousAssemblagesInput
    connect?: SousAssemblageWhereUniqueInput
    update?: XOR<XOR<SousAssemblageUpdateToOneWithWhereWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUpdateWithoutTaskTemplateSousAssemblagesInput>, SousAssemblageUncheckedUpdateWithoutTaskTemplateSousAssemblagesInput>
  }

  export type TaskTemplateUpdateOneRequiredWithoutSousAssemblagesNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousAssemblagesInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutSousAssemblagesInput
    upsert?: TaskTemplateUpsertWithoutSousAssemblagesInput
    connect?: TaskTemplateWhereUniqueInput
    update?: XOR<XOR<TaskTemplateUpdateToOneWithWhereWithoutSousAssemblagesInput, TaskTemplateUpdateWithoutSousAssemblagesInput>, TaskTemplateUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type SousSousAssemblageCreateNestedOneWithoutTaskTemplateSousSousAssemblagesInput = {
    create?: XOR<SousSousAssemblageCreateWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutTaskTemplateSousSousAssemblagesInput>
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutTaskTemplateSousSousAssemblagesInput
    connect?: SousSousAssemblageWhereUniqueInput
  }

  export type TaskTemplateCreateNestedOneWithoutSousSousAssemblagesInput = {
    create?: XOR<TaskTemplateCreateWithoutSousSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousSousAssemblagesInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutSousSousAssemblagesInput
    connect?: TaskTemplateWhereUniqueInput
  }

  export type SousSousAssemblageUpdateOneRequiredWithoutTaskTemplateSousSousAssemblagesNestedInput = {
    create?: XOR<SousSousAssemblageCreateWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutTaskTemplateSousSousAssemblagesInput>
    connectOrCreate?: SousSousAssemblageCreateOrConnectWithoutTaskTemplateSousSousAssemblagesInput
    upsert?: SousSousAssemblageUpsertWithoutTaskTemplateSousSousAssemblagesInput
    connect?: SousSousAssemblageWhereUniqueInput
    update?: XOR<XOR<SousSousAssemblageUpdateToOneWithWhereWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUpdateWithoutTaskTemplateSousSousAssemblagesInput>, SousSousAssemblageUncheckedUpdateWithoutTaskTemplateSousSousAssemblagesInput>
  }

  export type TaskTemplateUpdateOneRequiredWithoutSousSousAssemblagesNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutSousSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousSousAssemblagesInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutSousSousAssemblagesInput
    upsert?: TaskTemplateUpsertWithoutSousSousAssemblagesInput
    connect?: TaskTemplateWhereUniqueInput
    update?: XOR<XOR<TaskTemplateUpdateToOneWithWhereWithoutSousSousAssemblagesInput, TaskTemplateUpdateWithoutSousSousAssemblagesInput>, TaskTemplateUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type TaskTemplateCreateNestedOneWithoutLogsInput = {
    create?: XOR<TaskTemplateCreateWithoutLogsInput, TaskTemplateUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutLogsInput
    connect?: TaskTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTemplateLogsInput = {
    create?: XOR<UserCreateWithoutTemplateLogsInput, UserUncheckedCreateWithoutTemplateLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskTemplateUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<TaskTemplateCreateWithoutLogsInput, TaskTemplateUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TaskTemplateCreateOrConnectWithoutLogsInput
    upsert?: TaskTemplateUpsertWithoutLogsInput
    connect?: TaskTemplateWhereUniqueInput
    update?: XOR<XOR<TaskTemplateUpdateToOneWithWhereWithoutLogsInput, TaskTemplateUpdateWithoutLogsInput>, TaskTemplateUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneWithoutTemplateLogsNestedInput = {
    create?: XOR<UserCreateWithoutTemplateLogsInput, UserUncheckedCreateWithoutTemplateLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateLogsInput
    upsert?: UserUpsertWithoutTemplateLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTemplateLogsInput, UserUpdateWithoutTemplateLogsInput>, UserUncheckedUpdateWithoutTemplateLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumPieceEtatFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceEtat | EnumPieceEtatFieldRefInput<$PrismaModel>
    in?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceEtatFilter<$PrismaModel> | $Enums.PieceEtat
  }

  export type NestedEnumPieceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceType | EnumPieceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceTypeFilter<$PrismaModel> | $Enums.PieceType
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPieceEtatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceEtat | EnumPieceEtatFieldRefInput<$PrismaModel>
    in?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceEtat[] | ListEnumPieceEtatFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceEtatWithAggregatesFilter<$PrismaModel> | $Enums.PieceEtat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPieceEtatFilter<$PrismaModel>
    _max?: NestedEnumPieceEtatFilter<$PrismaModel>
  }

  export type NestedEnumPieceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PieceType | EnumPieceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PieceType[] | ListEnumPieceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPieceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PieceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPieceTypeFilter<$PrismaModel>
    _max?: NestedEnumPieceTypeFilter<$PrismaModel>
  }

  export type NestedEnumStockOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.StockOperation | EnumStockOperationFieldRefInput<$PrismaModel>
    in?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumStockOperationFilter<$PrismaModel> | $Enums.StockOperation
  }

  export type NestedEnumStockOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockOperation | EnumStockOperationFieldRefInput<$PrismaModel>
    in?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockOperation[] | ListEnumStockOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumStockOperationWithAggregatesFilter<$PrismaModel> | $Enums.StockOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockOperationFilter<$PrismaModel>
    _max?: NestedEnumStockOperationFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusFilter<$PrismaModel> | $Enums.ProductionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskEventType | EnumTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskEventTypeFilter<$PrismaModel> | $Enums.TaskEventType
  }

  export type NestedEnumTaskEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskEventType | EnumTaskEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskEventType[] | ListEnumTaskEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskEventTypeFilter<$PrismaModel>
  }

  export type ProductionLineCreateWithoutBorneInput = {
    quantity: number
    production: ProductionCreateNestedOneWithoutLinesInput
  }

  export type ProductionLineUncheckedCreateWithoutBorneInput = {
    id?: number
    productionId: number
    quantity: number
  }

  export type ProductionLineCreateOrConnectWithoutBorneInput = {
    where: ProductionLineWhereUniqueInput
    create: XOR<ProductionLineCreateWithoutBorneInput, ProductionLineUncheckedCreateWithoutBorneInput>
  }

  export type ProductionLineCreateManyBorneInputEnvelope = {
    data: ProductionLineCreateManyBorneInput | ProductionLineCreateManyBorneInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplateCreateWithoutBorneInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskCreateNestedManyWithoutTemplateInput
    logs?: TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateWithoutBorneInput = {
    id?: number
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput
    logs?: TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateCreateOrConnectWithoutBorneInput = {
    where: TaskTemplateWhereUniqueInput
    create: XOR<TaskTemplateCreateWithoutBorneInput, TaskTemplateUncheckedCreateWithoutBorneInput>
  }

  export type TaskTemplateCreateManyBorneInputEnvelope = {
    data: TaskTemplateCreateManyBorneInput | TaskTemplateCreateManyBorneInput[]
    skipDuplicates?: boolean
  }

  export type KitCreateWithoutBornesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: KitPieceCreateNestedManyWithoutKitInput
  }

  export type KitUncheckedCreateWithoutBornesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: KitPieceUncheckedCreateNestedManyWithoutKitInput
  }

  export type KitCreateOrConnectWithoutBornesInput = {
    where: KitWhereUniqueInput
    create: XOR<KitCreateWithoutBornesInput, KitUncheckedCreateWithoutBornesInput>
  }

  export type PieceCreateWithoutBornesInput = {
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceCreateNestedManyWithoutPieceInput
  }

  export type PieceUncheckedCreateWithoutBornesInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceUncheckedCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutPieceInput
  }

  export type PieceCreateOrConnectWithoutBornesInput = {
    where: PieceWhereUniqueInput
    create: XOR<PieceCreateWithoutBornesInput, PieceUncheckedCreateWithoutBornesInput>
  }

  export type SousAssemblageCreateWithoutBornesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceCreateNestedManyWithoutSousAssemblageInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutSousAssemblageInput
  }

  export type SousAssemblageUncheckedCreateWithoutBornesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceUncheckedCreateNestedManyWithoutSousAssemblageInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
  }

  export type SousAssemblageCreateOrConnectWithoutBornesInput = {
    where: SousAssemblageWhereUniqueInput
    create: XOR<SousAssemblageCreateWithoutBornesInput, SousAssemblageUncheckedCreateWithoutBornesInput>
  }

  export type SousSousAssemblageCreateWithoutBornesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    pieces?: SousSousAssemblagePieceCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
  }

  export type SousSousAssemblageUncheckedCreateWithoutBornesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    pieces?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
  }

  export type SousSousAssemblageCreateOrConnectWithoutBornesInput = {
    where: SousSousAssemblageWhereUniqueInput
    create: XOR<SousSousAssemblageCreateWithoutBornesInput, SousSousAssemblageUncheckedCreateWithoutBornesInput>
  }

  export type ProductionLineUpsertWithWhereUniqueWithoutBorneInput = {
    where: ProductionLineWhereUniqueInput
    update: XOR<ProductionLineUpdateWithoutBorneInput, ProductionLineUncheckedUpdateWithoutBorneInput>
    create: XOR<ProductionLineCreateWithoutBorneInput, ProductionLineUncheckedCreateWithoutBorneInput>
  }

  export type ProductionLineUpdateWithWhereUniqueWithoutBorneInput = {
    where: ProductionLineWhereUniqueInput
    data: XOR<ProductionLineUpdateWithoutBorneInput, ProductionLineUncheckedUpdateWithoutBorneInput>
  }

  export type ProductionLineUpdateManyWithWhereWithoutBorneInput = {
    where: ProductionLineScalarWhereInput
    data: XOR<ProductionLineUpdateManyMutationInput, ProductionLineUncheckedUpdateManyWithoutBorneInput>
  }

  export type ProductionLineScalarWhereInput = {
    AND?: ProductionLineScalarWhereInput | ProductionLineScalarWhereInput[]
    OR?: ProductionLineScalarWhereInput[]
    NOT?: ProductionLineScalarWhereInput | ProductionLineScalarWhereInput[]
    id?: IntFilter<"ProductionLine"> | number
    productionId?: IntFilter<"ProductionLine"> | number
    borneId?: IntFilter<"ProductionLine"> | number
    quantity?: IntFilter<"ProductionLine"> | number
  }

  export type TaskTemplateUpsertWithWhereUniqueWithoutBorneInput = {
    where: TaskTemplateWhereUniqueInput
    update: XOR<TaskTemplateUpdateWithoutBorneInput, TaskTemplateUncheckedUpdateWithoutBorneInput>
    create: XOR<TaskTemplateCreateWithoutBorneInput, TaskTemplateUncheckedCreateWithoutBorneInput>
  }

  export type TaskTemplateUpdateWithWhereUniqueWithoutBorneInput = {
    where: TaskTemplateWhereUniqueInput
    data: XOR<TaskTemplateUpdateWithoutBorneInput, TaskTemplateUncheckedUpdateWithoutBorneInput>
  }

  export type TaskTemplateUpdateManyWithWhereWithoutBorneInput = {
    where: TaskTemplateScalarWhereInput
    data: XOR<TaskTemplateUpdateManyMutationInput, TaskTemplateUncheckedUpdateManyWithoutBorneInput>
  }

  export type TaskTemplateScalarWhereInput = {
    AND?: TaskTemplateScalarWhereInput | TaskTemplateScalarWhereInput[]
    OR?: TaskTemplateScalarWhereInput[]
    NOT?: TaskTemplateScalarWhereInput | TaskTemplateScalarWhereInput[]
    id?: IntFilter<"TaskTemplate"> | number
    borneId?: IntNullableFilter<"TaskTemplate"> | number | null
    label?: StringFilter<"TaskTemplate"> | string
    description?: StringNullableFilter<"TaskTemplate"> | string | null
    order?: IntNullableFilter<"TaskTemplate"> | number | null
    estimatedMinutesPerUnit?: IntNullableFilter<"TaskTemplate"> | number | null
    active?: BoolFilter<"TaskTemplate"> | boolean
  }

  export type KitUpsertWithWhereUniqueWithoutBornesInput = {
    where: KitWhereUniqueInput
    update: XOR<KitUpdateWithoutBornesInput, KitUncheckedUpdateWithoutBornesInput>
    create: XOR<KitCreateWithoutBornesInput, KitUncheckedCreateWithoutBornesInput>
  }

  export type KitUpdateWithWhereUniqueWithoutBornesInput = {
    where: KitWhereUniqueInput
    data: XOR<KitUpdateWithoutBornesInput, KitUncheckedUpdateWithoutBornesInput>
  }

  export type KitUpdateManyWithWhereWithoutBornesInput = {
    where: KitScalarWhereInput
    data: XOR<KitUpdateManyMutationInput, KitUncheckedUpdateManyWithoutBornesInput>
  }

  export type KitScalarWhereInput = {
    AND?: KitScalarWhereInput | KitScalarWhereInput[]
    OR?: KitScalarWhereInput[]
    NOT?: KitScalarWhereInput | KitScalarWhereInput[]
    id?: IntFilter<"Kit"> | number
    nom?: StringFilter<"Kit"> | string
    reference?: StringFilter<"Kit"> | string
    photo?: StringNullableFilter<"Kit"> | string | null
    emplacement?: StringFilter<"Kit"> | string
    createdAt?: DateTimeFilter<"Kit"> | Date | string
    updatedAt?: DateTimeFilter<"Kit"> | Date | string
    archived?: BoolFilter<"Kit"> | boolean
    nombre?: IntFilter<"Kit"> | number
    seuilAlerte?: IntFilter<"Kit"> | number
    etat?: EnumPieceEtatFilter<"Kit"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"Kit"> | string | null
    type?: EnumPieceTypeFilter<"Kit"> | $Enums.PieceType
    version?: StringFilter<"Kit"> | string
  }

  export type PieceUpsertWithWhereUniqueWithoutBornesInput = {
    where: PieceWhereUniqueInput
    update: XOR<PieceUpdateWithoutBornesInput, PieceUncheckedUpdateWithoutBornesInput>
    create: XOR<PieceCreateWithoutBornesInput, PieceUncheckedCreateWithoutBornesInput>
  }

  export type PieceUpdateWithWhereUniqueWithoutBornesInput = {
    where: PieceWhereUniqueInput
    data: XOR<PieceUpdateWithoutBornesInput, PieceUncheckedUpdateWithoutBornesInput>
  }

  export type PieceUpdateManyWithWhereWithoutBornesInput = {
    where: PieceScalarWhereInput
    data: XOR<PieceUpdateManyMutationInput, PieceUncheckedUpdateManyWithoutBornesInput>
  }

  export type PieceScalarWhereInput = {
    AND?: PieceScalarWhereInput | PieceScalarWhereInput[]
    OR?: PieceScalarWhereInput[]
    NOT?: PieceScalarWhereInput | PieceScalarWhereInput[]
    id?: IntFilter<"Piece"> | number
    nom?: StringFilter<"Piece"> | string
    reference?: StringFilter<"Piece"> | string
    nombre?: IntFilter<"Piece"> | number
    photo?: StringNullableFilter<"Piece"> | string | null
    emplacement?: StringFilter<"Piece"> | string
    createdAt?: DateTimeFilter<"Piece"> | Date | string
    updatedAt?: DateTimeFilter<"Piece"> | Date | string
    archived?: BoolFilter<"Piece"> | boolean
    seuilAlerte?: IntFilter<"Piece"> | number
    etat?: EnumPieceEtatFilter<"Piece"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"Piece"> | string | null
    type?: EnumPieceTypeFilter<"Piece"> | $Enums.PieceType
    version?: StringFilter<"Piece"> | string
  }

  export type SousAssemblageUpsertWithWhereUniqueWithoutBornesInput = {
    where: SousAssemblageWhereUniqueInput
    update: XOR<SousAssemblageUpdateWithoutBornesInput, SousAssemblageUncheckedUpdateWithoutBornesInput>
    create: XOR<SousAssemblageCreateWithoutBornesInput, SousAssemblageUncheckedCreateWithoutBornesInput>
  }

  export type SousAssemblageUpdateWithWhereUniqueWithoutBornesInput = {
    where: SousAssemblageWhereUniqueInput
    data: XOR<SousAssemblageUpdateWithoutBornesInput, SousAssemblageUncheckedUpdateWithoutBornesInput>
  }

  export type SousAssemblageUpdateManyWithWhereWithoutBornesInput = {
    where: SousAssemblageScalarWhereInput
    data: XOR<SousAssemblageUpdateManyMutationInput, SousAssemblageUncheckedUpdateManyWithoutBornesInput>
  }

  export type SousAssemblageScalarWhereInput = {
    AND?: SousAssemblageScalarWhereInput | SousAssemblageScalarWhereInput[]
    OR?: SousAssemblageScalarWhereInput[]
    NOT?: SousAssemblageScalarWhereInput | SousAssemblageScalarWhereInput[]
    id?: IntFilter<"SousAssemblage"> | number
    nom?: StringFilter<"SousAssemblage"> | string
    reference?: StringFilter<"SousAssemblage"> | string
    photo?: StringNullableFilter<"SousAssemblage"> | string | null
    emplacement?: StringFilter<"SousAssemblage"> | string
    createdAt?: DateTimeFilter<"SousAssemblage"> | Date | string
    updatedAt?: DateTimeFilter<"SousAssemblage"> | Date | string
    archived?: BoolFilter<"SousAssemblage"> | boolean
    nombre?: IntFilter<"SousAssemblage"> | number
    seuilAlerte?: IntFilter<"SousAssemblage"> | number
    etat?: EnumPieceEtatFilter<"SousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"SousAssemblage"> | string | null
    type?: EnumPieceTypeFilter<"SousAssemblage"> | $Enums.PieceType
    version?: StringFilter<"SousAssemblage"> | string
  }

  export type SousSousAssemblageUpsertWithWhereUniqueWithoutBornesInput = {
    where: SousSousAssemblageWhereUniqueInput
    update: XOR<SousSousAssemblageUpdateWithoutBornesInput, SousSousAssemblageUncheckedUpdateWithoutBornesInput>
    create: XOR<SousSousAssemblageCreateWithoutBornesInput, SousSousAssemblageUncheckedCreateWithoutBornesInput>
  }

  export type SousSousAssemblageUpdateWithWhereUniqueWithoutBornesInput = {
    where: SousSousAssemblageWhereUniqueInput
    data: XOR<SousSousAssemblageUpdateWithoutBornesInput, SousSousAssemblageUncheckedUpdateWithoutBornesInput>
  }

  export type SousSousAssemblageUpdateManyWithWhereWithoutBornesInput = {
    where: SousSousAssemblageScalarWhereInput
    data: XOR<SousSousAssemblageUpdateManyMutationInput, SousSousAssemblageUncheckedUpdateManyWithoutBornesInput>
  }

  export type SousSousAssemblageScalarWhereInput = {
    AND?: SousSousAssemblageScalarWhereInput | SousSousAssemblageScalarWhereInput[]
    OR?: SousSousAssemblageScalarWhereInput[]
    NOT?: SousSousAssemblageScalarWhereInput | SousSousAssemblageScalarWhereInput[]
    id?: IntFilter<"SousSousAssemblage"> | number
    nom?: StringFilter<"SousSousAssemblage"> | string
    reference?: StringFilter<"SousSousAssemblage"> | string
    photo?: StringNullableFilter<"SousSousAssemblage"> | string | null
    emplacement?: StringFilter<"SousSousAssemblage"> | string
    createdAt?: DateTimeFilter<"SousSousAssemblage"> | Date | string
    updatedAt?: DateTimeFilter<"SousSousAssemblage"> | Date | string
    archived?: BoolFilter<"SousSousAssemblage"> | boolean
    nombre?: IntFilter<"SousSousAssemblage"> | number
    seuilAlerte?: IntFilter<"SousSousAssemblage"> | number
    etat?: EnumPieceEtatFilter<"SousSousAssemblage"> | $Enums.PieceEtat
    numero?: StringNullableFilter<"SousSousAssemblage"> | string | null
    type?: EnumPieceTypeFilter<"SousSousAssemblage"> | $Enums.PieceType
    version?: StringFilter<"SousSousAssemblage"> | string
  }

  export type ProductionTaskCreateWithoutAssignedToInput = {
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    production: ProductionCreateNestedOneWithoutTasksInput
    template?: TaskTemplateCreateNestedOneWithoutProductionTasksInput
    logs?: ProductionTaskLogCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskUncheckedCreateWithoutAssignedToInput = {
    id?: number
    productionId: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    logs?: ProductionTaskLogUncheckedCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskCreateOrConnectWithoutAssignedToInput = {
    where: ProductionTaskWhereUniqueInput
    create: XOR<ProductionTaskCreateWithoutAssignedToInput, ProductionTaskUncheckedCreateWithoutAssignedToInput>
  }

  export type ProductionTaskCreateManyAssignedToInputEnvelope = {
    data: ProductionTaskCreateManyAssignedToInput | ProductionTaskCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type ProductionTaskLogCreateWithoutUserInput = {
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
    productionTask: ProductionTaskCreateNestedOneWithoutLogsInput
  }

  export type ProductionTaskLogUncheckedCreateWithoutUserInput = {
    id?: number
    productionTaskId: number
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
  }

  export type ProductionTaskLogCreateOrConnectWithoutUserInput = {
    where: ProductionTaskLogWhereUniqueInput
    create: XOR<ProductionTaskLogCreateWithoutUserInput, ProductionTaskLogUncheckedCreateWithoutUserInput>
  }

  export type ProductionTaskLogCreateManyUserInputEnvelope = {
    data: ProductionTaskLogCreateManyUserInput | ProductionTaskLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StockLogCreateWithoutUserInput = {
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt?: Date | string
  }

  export type StockLogUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt?: Date | string
  }

  export type StockLogCreateOrConnectWithoutUserInput = {
    where: StockLogWhereUniqueInput
    create: XOR<StockLogCreateWithoutUserInput, StockLogUncheckedCreateWithoutUserInput>
  }

  export type StockLogCreateManyUserInputEnvelope = {
    data: StockLogCreateManyUserInput | StockLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplateLogCreateWithoutUserInput = {
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
    taskTemplate: TaskTemplateCreateNestedOneWithoutLogsInput
  }

  export type TaskTemplateLogUncheckedCreateWithoutUserInput = {
    id?: number
    taskTemplateId: number
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
  }

  export type TaskTemplateLogCreateOrConnectWithoutUserInput = {
    where: TaskTemplateLogWhereUniqueInput
    create: XOR<TaskTemplateLogCreateWithoutUserInput, TaskTemplateLogUncheckedCreateWithoutUserInput>
  }

  export type TaskTemplateLogCreateManyUserInputEnvelope = {
    data: TaskTemplateLogCreateManyUserInput | TaskTemplateLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductionTaskUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ProductionTaskWhereUniqueInput
    update: XOR<ProductionTaskUpdateWithoutAssignedToInput, ProductionTaskUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ProductionTaskCreateWithoutAssignedToInput, ProductionTaskUncheckedCreateWithoutAssignedToInput>
  }

  export type ProductionTaskUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ProductionTaskWhereUniqueInput
    data: XOR<ProductionTaskUpdateWithoutAssignedToInput, ProductionTaskUncheckedUpdateWithoutAssignedToInput>
  }

  export type ProductionTaskUpdateManyWithWhereWithoutAssignedToInput = {
    where: ProductionTaskScalarWhereInput
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type ProductionTaskScalarWhereInput = {
    AND?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
    OR?: ProductionTaskScalarWhereInput[]
    NOT?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
    id?: IntFilter<"ProductionTask"> | number
    productionId?: IntFilter<"ProductionTask"> | number
    taskTemplateId?: IntNullableFilter<"ProductionTask"> | number | null
    label?: StringFilter<"ProductionTask"> | string
    description?: StringNullableFilter<"ProductionTask"> | string | null
    isDone?: BoolFilter<"ProductionTask"> | boolean
    totalSeconds?: IntFilter<"ProductionTask"> | number
    running?: BoolFilter<"ProductionTask"> | boolean
    lastStartedAt?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    assignedToId?: IntNullableFilter<"ProductionTask"> | number | null
  }

  export type ProductionTaskLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductionTaskLogWhereUniqueInput
    update: XOR<ProductionTaskLogUpdateWithoutUserInput, ProductionTaskLogUncheckedUpdateWithoutUserInput>
    create: XOR<ProductionTaskLogCreateWithoutUserInput, ProductionTaskLogUncheckedCreateWithoutUserInput>
  }

  export type ProductionTaskLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductionTaskLogWhereUniqueInput
    data: XOR<ProductionTaskLogUpdateWithoutUserInput, ProductionTaskLogUncheckedUpdateWithoutUserInput>
  }

  export type ProductionTaskLogUpdateManyWithWhereWithoutUserInput = {
    where: ProductionTaskLogScalarWhereInput
    data: XOR<ProductionTaskLogUpdateManyMutationInput, ProductionTaskLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductionTaskLogScalarWhereInput = {
    AND?: ProductionTaskLogScalarWhereInput | ProductionTaskLogScalarWhereInput[]
    OR?: ProductionTaskLogScalarWhereInput[]
    NOT?: ProductionTaskLogScalarWhereInput | ProductionTaskLogScalarWhereInput[]
    id?: IntFilter<"ProductionTaskLog"> | number
    productionTaskId?: IntFilter<"ProductionTaskLog"> | number
    userId?: IntNullableFilter<"ProductionTaskLog"> | number | null
    eventType?: EnumTaskEventTypeFilter<"ProductionTaskLog"> | $Enums.TaskEventType
    createdAt?: DateTimeFilter<"ProductionTaskLog"> | Date | string
    note?: StringNullableFilter<"ProductionTaskLog"> | string | null
  }

  export type StockLogUpsertWithWhereUniqueWithoutUserInput = {
    where: StockLogWhereUniqueInput
    update: XOR<StockLogUpdateWithoutUserInput, StockLogUncheckedUpdateWithoutUserInput>
    create: XOR<StockLogCreateWithoutUserInput, StockLogUncheckedCreateWithoutUserInput>
  }

  export type StockLogUpdateWithWhereUniqueWithoutUserInput = {
    where: StockLogWhereUniqueInput
    data: XOR<StockLogUpdateWithoutUserInput, StockLogUncheckedUpdateWithoutUserInput>
  }

  export type StockLogUpdateManyWithWhereWithoutUserInput = {
    where: StockLogScalarWhereInput
    data: XOR<StockLogUpdateManyMutationInput, StockLogUncheckedUpdateManyWithoutUserInput>
  }

  export type StockLogScalarWhereInput = {
    AND?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
    OR?: StockLogScalarWhereInput[]
    NOT?: StockLogScalarWhereInput | StockLogScalarWhereInput[]
    id?: IntFilter<"StockLog"> | number
    type?: StringFilter<"StockLog"> | string
    itemId?: IntFilter<"StockLog"> | number
    quantity?: IntFilter<"StockLog"> | number
    operation?: EnumStockOperationFilter<"StockLog"> | $Enums.StockOperation
    createdAt?: DateTimeFilter<"StockLog"> | Date | string
    userId?: IntNullableFilter<"StockLog"> | number | null
  }

  export type TaskTemplateLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskTemplateLogWhereUniqueInput
    update: XOR<TaskTemplateLogUpdateWithoutUserInput, TaskTemplateLogUncheckedUpdateWithoutUserInput>
    create: XOR<TaskTemplateLogCreateWithoutUserInput, TaskTemplateLogUncheckedCreateWithoutUserInput>
  }

  export type TaskTemplateLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskTemplateLogWhereUniqueInput
    data: XOR<TaskTemplateLogUpdateWithoutUserInput, TaskTemplateLogUncheckedUpdateWithoutUserInput>
  }

  export type TaskTemplateLogUpdateManyWithWhereWithoutUserInput = {
    where: TaskTemplateLogScalarWhereInput
    data: XOR<TaskTemplateLogUpdateManyMutationInput, TaskTemplateLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskTemplateLogScalarWhereInput = {
    AND?: TaskTemplateLogScalarWhereInput | TaskTemplateLogScalarWhereInput[]
    OR?: TaskTemplateLogScalarWhereInput[]
    NOT?: TaskTemplateLogScalarWhereInput | TaskTemplateLogScalarWhereInput[]
    id?: IntFilter<"TaskTemplateLog"> | number
    taskTemplateId?: IntFilter<"TaskTemplateLog"> | number
    userId?: IntNullableFilter<"TaskTemplateLog"> | number | null
    createdAt?: DateTimeFilter<"TaskTemplateLog"> | Date | string
    note?: StringNullableFilter<"TaskTemplateLog"> | string | null
    eventType?: EnumTaskEventTypeFilter<"TaskTemplateLog"> | $Enums.TaskEventType
  }

  export type KitPieceCreateWithoutPieceInput = {
    nombre?: number
    kit: KitCreateNestedOneWithoutPiecesInput
  }

  export type KitPieceUncheckedCreateWithoutPieceInput = {
    id?: number
    kitId: number
    nombre?: number
  }

  export type KitPieceCreateOrConnectWithoutPieceInput = {
    where: KitPieceWhereUniqueInput
    create: XOR<KitPieceCreateWithoutPieceInput, KitPieceUncheckedCreateWithoutPieceInput>
  }

  export type KitPieceCreateManyPieceInputEnvelope = {
    data: KitPieceCreateManyPieceInput | KitPieceCreateManyPieceInput[]
    skipDuplicates?: boolean
  }

  export type SousAssemblagePieceCreateWithoutPieceInput = {
    nombre?: number
    sousAssemblage: SousAssemblageCreateNestedOneWithoutPiecesInput
  }

  export type SousAssemblagePieceUncheckedCreateWithoutPieceInput = {
    id?: number
    sousAssemblageId: number
    nombre?: number
  }

  export type SousAssemblagePieceCreateOrConnectWithoutPieceInput = {
    where: SousAssemblagePieceWhereUniqueInput
    create: XOR<SousAssemblagePieceCreateWithoutPieceInput, SousAssemblagePieceUncheckedCreateWithoutPieceInput>
  }

  export type SousAssemblagePieceCreateManyPieceInputEnvelope = {
    data: SousAssemblagePieceCreateManyPieceInput | SousAssemblagePieceCreateManyPieceInput[]
    skipDuplicates?: boolean
  }

  export type SousSousAssemblagePieceCreateWithoutPieceInput = {
    nombre?: number
    sousSousAssemblage: SousSousAssemblageCreateNestedOneWithoutPiecesInput
  }

  export type SousSousAssemblagePieceUncheckedCreateWithoutPieceInput = {
    id?: number
    sousSousAssemblageId: number
    nombre?: number
  }

  export type SousSousAssemblagePieceCreateOrConnectWithoutPieceInput = {
    where: SousSousAssemblagePieceWhereUniqueInput
    create: XOR<SousSousAssemblagePieceCreateWithoutPieceInput, SousSousAssemblagePieceUncheckedCreateWithoutPieceInput>
  }

  export type SousSousAssemblagePieceCreateManyPieceInputEnvelope = {
    data: SousSousAssemblagePieceCreateManyPieceInput | SousSousAssemblagePieceCreateManyPieceInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplatePieceCreateWithoutPieceInput = {
    quantity?: number
    taskTemplate: TaskTemplateCreateNestedOneWithoutPiecesInput
  }

  export type TaskTemplatePieceUncheckedCreateWithoutPieceInput = {
    id?: number
    taskTemplateId: number
    quantity?: number
  }

  export type TaskTemplatePieceCreateOrConnectWithoutPieceInput = {
    where: TaskTemplatePieceWhereUniqueInput
    create: XOR<TaskTemplatePieceCreateWithoutPieceInput, TaskTemplatePieceUncheckedCreateWithoutPieceInput>
  }

  export type TaskTemplatePieceCreateManyPieceInputEnvelope = {
    data: TaskTemplatePieceCreateManyPieceInput | TaskTemplatePieceCreateManyPieceInput[]
    skipDuplicates?: boolean
  }

  export type BorneCreateWithoutPiecesInput = {
    nom: string
    productionLines?: ProductionLineCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateCreateNestedManyWithoutBorneInput
    kits?: KitCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateWithoutPiecesInput = {
    id?: number
    nom: string
    productionLines?: ProductionLineUncheckedCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateUncheckedCreateNestedManyWithoutBorneInput
    kits?: KitUncheckedCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageUncheckedCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneCreateOrConnectWithoutPiecesInput = {
    where: BorneWhereUniqueInput
    create: XOR<BorneCreateWithoutPiecesInput, BorneUncheckedCreateWithoutPiecesInput>
  }

  export type KitPieceUpsertWithWhereUniqueWithoutPieceInput = {
    where: KitPieceWhereUniqueInput
    update: XOR<KitPieceUpdateWithoutPieceInput, KitPieceUncheckedUpdateWithoutPieceInput>
    create: XOR<KitPieceCreateWithoutPieceInput, KitPieceUncheckedCreateWithoutPieceInput>
  }

  export type KitPieceUpdateWithWhereUniqueWithoutPieceInput = {
    where: KitPieceWhereUniqueInput
    data: XOR<KitPieceUpdateWithoutPieceInput, KitPieceUncheckedUpdateWithoutPieceInput>
  }

  export type KitPieceUpdateManyWithWhereWithoutPieceInput = {
    where: KitPieceScalarWhereInput
    data: XOR<KitPieceUpdateManyMutationInput, KitPieceUncheckedUpdateManyWithoutPieceInput>
  }

  export type KitPieceScalarWhereInput = {
    AND?: KitPieceScalarWhereInput | KitPieceScalarWhereInput[]
    OR?: KitPieceScalarWhereInput[]
    NOT?: KitPieceScalarWhereInput | KitPieceScalarWhereInput[]
    id?: IntFilter<"KitPiece"> | number
    kitId?: IntFilter<"KitPiece"> | number
    pieceId?: IntFilter<"KitPiece"> | number
    nombre?: IntFilter<"KitPiece"> | number
  }

  export type SousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput = {
    where: SousAssemblagePieceWhereUniqueInput
    update: XOR<SousAssemblagePieceUpdateWithoutPieceInput, SousAssemblagePieceUncheckedUpdateWithoutPieceInput>
    create: XOR<SousAssemblagePieceCreateWithoutPieceInput, SousAssemblagePieceUncheckedCreateWithoutPieceInput>
  }

  export type SousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput = {
    where: SousAssemblagePieceWhereUniqueInput
    data: XOR<SousAssemblagePieceUpdateWithoutPieceInput, SousAssemblagePieceUncheckedUpdateWithoutPieceInput>
  }

  export type SousAssemblagePieceUpdateManyWithWhereWithoutPieceInput = {
    where: SousAssemblagePieceScalarWhereInput
    data: XOR<SousAssemblagePieceUpdateManyMutationInput, SousAssemblagePieceUncheckedUpdateManyWithoutPieceInput>
  }

  export type SousAssemblagePieceScalarWhereInput = {
    AND?: SousAssemblagePieceScalarWhereInput | SousAssemblagePieceScalarWhereInput[]
    OR?: SousAssemblagePieceScalarWhereInput[]
    NOT?: SousAssemblagePieceScalarWhereInput | SousAssemblagePieceScalarWhereInput[]
    id?: IntFilter<"SousAssemblagePiece"> | number
    sousAssemblageId?: IntFilter<"SousAssemblagePiece"> | number
    pieceId?: IntFilter<"SousAssemblagePiece"> | number
    nombre?: IntFilter<"SousAssemblagePiece"> | number
  }

  export type SousSousAssemblagePieceUpsertWithWhereUniqueWithoutPieceInput = {
    where: SousSousAssemblagePieceWhereUniqueInput
    update: XOR<SousSousAssemblagePieceUpdateWithoutPieceInput, SousSousAssemblagePieceUncheckedUpdateWithoutPieceInput>
    create: XOR<SousSousAssemblagePieceCreateWithoutPieceInput, SousSousAssemblagePieceUncheckedCreateWithoutPieceInput>
  }

  export type SousSousAssemblagePieceUpdateWithWhereUniqueWithoutPieceInput = {
    where: SousSousAssemblagePieceWhereUniqueInput
    data: XOR<SousSousAssemblagePieceUpdateWithoutPieceInput, SousSousAssemblagePieceUncheckedUpdateWithoutPieceInput>
  }

  export type SousSousAssemblagePieceUpdateManyWithWhereWithoutPieceInput = {
    where: SousSousAssemblagePieceScalarWhereInput
    data: XOR<SousSousAssemblagePieceUpdateManyMutationInput, SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceInput>
  }

  export type SousSousAssemblagePieceScalarWhereInput = {
    AND?: SousSousAssemblagePieceScalarWhereInput | SousSousAssemblagePieceScalarWhereInput[]
    OR?: SousSousAssemblagePieceScalarWhereInput[]
    NOT?: SousSousAssemblagePieceScalarWhereInput | SousSousAssemblagePieceScalarWhereInput[]
    id?: IntFilter<"SousSousAssemblagePiece"> | number
    sousSousAssemblageId?: IntFilter<"SousSousAssemblagePiece"> | number
    pieceId?: IntFilter<"SousSousAssemblagePiece"> | number
    nombre?: IntFilter<"SousSousAssemblagePiece"> | number
  }

  export type TaskTemplatePieceUpsertWithWhereUniqueWithoutPieceInput = {
    where: TaskTemplatePieceWhereUniqueInput
    update: XOR<TaskTemplatePieceUpdateWithoutPieceInput, TaskTemplatePieceUncheckedUpdateWithoutPieceInput>
    create: XOR<TaskTemplatePieceCreateWithoutPieceInput, TaskTemplatePieceUncheckedCreateWithoutPieceInput>
  }

  export type TaskTemplatePieceUpdateWithWhereUniqueWithoutPieceInput = {
    where: TaskTemplatePieceWhereUniqueInput
    data: XOR<TaskTemplatePieceUpdateWithoutPieceInput, TaskTemplatePieceUncheckedUpdateWithoutPieceInput>
  }

  export type TaskTemplatePieceUpdateManyWithWhereWithoutPieceInput = {
    where: TaskTemplatePieceScalarWhereInput
    data: XOR<TaskTemplatePieceUpdateManyMutationInput, TaskTemplatePieceUncheckedUpdateManyWithoutPieceInput>
  }

  export type TaskTemplatePieceScalarWhereInput = {
    AND?: TaskTemplatePieceScalarWhereInput | TaskTemplatePieceScalarWhereInput[]
    OR?: TaskTemplatePieceScalarWhereInput[]
    NOT?: TaskTemplatePieceScalarWhereInput | TaskTemplatePieceScalarWhereInput[]
    id?: IntFilter<"TaskTemplatePiece"> | number
    taskTemplateId?: IntFilter<"TaskTemplatePiece"> | number
    pieceId?: IntFilter<"TaskTemplatePiece"> | number
    quantity?: IntFilter<"TaskTemplatePiece"> | number
  }

  export type BorneUpsertWithWhereUniqueWithoutPiecesInput = {
    where: BorneWhereUniqueInput
    update: XOR<BorneUpdateWithoutPiecesInput, BorneUncheckedUpdateWithoutPiecesInput>
    create: XOR<BorneCreateWithoutPiecesInput, BorneUncheckedCreateWithoutPiecesInput>
  }

  export type BorneUpdateWithWhereUniqueWithoutPiecesInput = {
    where: BorneWhereUniqueInput
    data: XOR<BorneUpdateWithoutPiecesInput, BorneUncheckedUpdateWithoutPiecesInput>
  }

  export type BorneUpdateManyWithWhereWithoutPiecesInput = {
    where: BorneScalarWhereInput
    data: XOR<BorneUpdateManyMutationInput, BorneUncheckedUpdateManyWithoutPiecesInput>
  }

  export type BorneScalarWhereInput = {
    AND?: BorneScalarWhereInput | BorneScalarWhereInput[]
    OR?: BorneScalarWhereInput[]
    NOT?: BorneScalarWhereInput | BorneScalarWhereInput[]
    id?: IntFilter<"Borne"> | number
    nom?: StringFilter<"Borne"> | string
  }

  export type SousAssemblagePieceCreateWithoutSousAssemblageInput = {
    nombre?: number
    piece: PieceCreateNestedOneWithoutSousAssemblagesInput
  }

  export type SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput = {
    id?: number
    pieceId: number
    nombre?: number
  }

  export type SousAssemblagePieceCreateOrConnectWithoutSousAssemblageInput = {
    where: SousAssemblagePieceWhereUniqueInput
    create: XOR<SousAssemblagePieceCreateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput>
  }

  export type SousAssemblagePieceCreateManySousAssemblageInputEnvelope = {
    data: SousAssemblagePieceCreateManySousAssemblageInput | SousAssemblagePieceCreateManySousAssemblageInput[]
    skipDuplicates?: boolean
  }

  export type SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput = {
    nombre?: number
    sousSousAssemblage: SousSousAssemblageCreateNestedOneWithoutSousAssemblagesInput
  }

  export type SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput = {
    id?: number
    sousSousAssemblageId: number
    nombre?: number
  }

  export type SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    create: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageCreateManySousAssemblageInputEnvelope = {
    data: SousAssemblageSousSousAssemblageCreateManySousAssemblageInput | SousAssemblageSousSousAssemblageCreateManySousAssemblageInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput = {
    quantity?: number
    taskTemplate: TaskTemplateCreateNestedOneWithoutSousAssemblagesInput
  }

  export type TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput = {
    id?: number
    taskTemplateId: number
    quantity?: number
  }

  export type TaskTemplateSousAssemblageCreateOrConnectWithoutSousAssemblageInput = {
    where: TaskTemplateSousAssemblageWhereUniqueInput
    create: XOR<TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput>
  }

  export type TaskTemplateSousAssemblageCreateManySousAssemblageInputEnvelope = {
    data: TaskTemplateSousAssemblageCreateManySousAssemblageInput | TaskTemplateSousAssemblageCreateManySousAssemblageInput[]
    skipDuplicates?: boolean
  }

  export type BorneCreateWithoutSousAssemblagesInput = {
    nom: string
    productionLines?: ProductionLineCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateCreateNestedManyWithoutBorneInput
    kits?: KitCreateNestedManyWithoutBornesInput
    pieces?: PieceCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateWithoutSousAssemblagesInput = {
    id?: number
    nom: string
    productionLines?: ProductionLineUncheckedCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateUncheckedCreateNestedManyWithoutBorneInput
    kits?: KitUncheckedCreateNestedManyWithoutBornesInput
    pieces?: PieceUncheckedCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneCreateOrConnectWithoutSousAssemblagesInput = {
    where: BorneWhereUniqueInput
    create: XOR<BorneCreateWithoutSousAssemblagesInput, BorneUncheckedCreateWithoutSousAssemblagesInput>
  }

  export type SousAssemblagePieceUpsertWithWhereUniqueWithoutSousAssemblageInput = {
    where: SousAssemblagePieceWhereUniqueInput
    update: XOR<SousAssemblagePieceUpdateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedUpdateWithoutSousAssemblageInput>
    create: XOR<SousAssemblagePieceCreateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedCreateWithoutSousAssemblageInput>
  }

  export type SousAssemblagePieceUpdateWithWhereUniqueWithoutSousAssemblageInput = {
    where: SousAssemblagePieceWhereUniqueInput
    data: XOR<SousAssemblagePieceUpdateWithoutSousAssemblageInput, SousAssemblagePieceUncheckedUpdateWithoutSousAssemblageInput>
  }

  export type SousAssemblagePieceUpdateManyWithWhereWithoutSousAssemblageInput = {
    where: SousAssemblagePieceScalarWhereInput
    data: XOR<SousAssemblagePieceUpdateManyMutationInput, SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    update: XOR<SousAssemblageSousSousAssemblageUpdateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedUpdateWithoutSousAssemblageInput>
    create: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    data: XOR<SousAssemblageSousSousAssemblageUpdateWithoutSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedUpdateWithoutSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageScalarWhereInput
    data: XOR<SousAssemblageSousSousAssemblageUpdateManyMutationInput, SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageScalarWhereInput = {
    AND?: SousAssemblageSousSousAssemblageScalarWhereInput | SousAssemblageSousSousAssemblageScalarWhereInput[]
    OR?: SousAssemblageSousSousAssemblageScalarWhereInput[]
    NOT?: SousAssemblageSousSousAssemblageScalarWhereInput | SousAssemblageSousSousAssemblageScalarWhereInput[]
    id?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousAssemblageId?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    sousSousAssemblageId?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
    nombre?: IntFilter<"SousAssemblageSousSousAssemblage"> | number
  }

  export type TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutSousAssemblageInput = {
    where: TaskTemplateSousAssemblageWhereUniqueInput
    update: XOR<TaskTemplateSousAssemblageUpdateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedUpdateWithoutSousAssemblageInput>
    create: XOR<TaskTemplateSousAssemblageCreateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedCreateWithoutSousAssemblageInput>
  }

  export type TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutSousAssemblageInput = {
    where: TaskTemplateSousAssemblageWhereUniqueInput
    data: XOR<TaskTemplateSousAssemblageUpdateWithoutSousAssemblageInput, TaskTemplateSousAssemblageUncheckedUpdateWithoutSousAssemblageInput>
  }

  export type TaskTemplateSousAssemblageUpdateManyWithWhereWithoutSousAssemblageInput = {
    where: TaskTemplateSousAssemblageScalarWhereInput
    data: XOR<TaskTemplateSousAssemblageUpdateManyMutationInput, TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageInput>
  }

  export type TaskTemplateSousAssemblageScalarWhereInput = {
    AND?: TaskTemplateSousAssemblageScalarWhereInput | TaskTemplateSousAssemblageScalarWhereInput[]
    OR?: TaskTemplateSousAssemblageScalarWhereInput[]
    NOT?: TaskTemplateSousAssemblageScalarWhereInput | TaskTemplateSousAssemblageScalarWhereInput[]
    id?: IntFilter<"TaskTemplateSousAssemblage"> | number
    taskTemplateId?: IntFilter<"TaskTemplateSousAssemblage"> | number
    sousAssemblageId?: IntFilter<"TaskTemplateSousAssemblage"> | number
    quantity?: IntFilter<"TaskTemplateSousAssemblage"> | number
  }

  export type BorneUpsertWithWhereUniqueWithoutSousAssemblagesInput = {
    where: BorneWhereUniqueInput
    update: XOR<BorneUpdateWithoutSousAssemblagesInput, BorneUncheckedUpdateWithoutSousAssemblagesInput>
    create: XOR<BorneCreateWithoutSousAssemblagesInput, BorneUncheckedCreateWithoutSousAssemblagesInput>
  }

  export type BorneUpdateWithWhereUniqueWithoutSousAssemblagesInput = {
    where: BorneWhereUniqueInput
    data: XOR<BorneUpdateWithoutSousAssemblagesInput, BorneUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type BorneUpdateManyWithWhereWithoutSousAssemblagesInput = {
    where: BorneScalarWhereInput
    data: XOR<BorneUpdateManyMutationInput, BorneUncheckedUpdateManyWithoutSousAssemblagesInput>
  }

  export type SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput = {
    nombre?: number
    sousAssemblage: SousAssemblageCreateNestedOneWithoutSousSousAssemblagesInput
  }

  export type SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput = {
    id?: number
    sousAssemblageId: number
    nombre?: number
  }

  export type SousAssemblageSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    create: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInputEnvelope = {
    data: SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInput | SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInput[]
    skipDuplicates?: boolean
  }

  export type SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput = {
    nombre?: number
    piece: PieceCreateNestedOneWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput = {
    id?: number
    pieceId: number
    nombre?: number
  }

  export type SousSousAssemblagePieceCreateOrConnectWithoutSousSousAssemblageInput = {
    where: SousSousAssemblagePieceWhereUniqueInput
    create: XOR<SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput>
  }

  export type SousSousAssemblagePieceCreateManySousSousAssemblageInputEnvelope = {
    data: SousSousAssemblagePieceCreateManySousSousAssemblageInput | SousSousAssemblagePieceCreateManySousSousAssemblageInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput = {
    quantity?: number
    taskTemplate: TaskTemplateCreateNestedOneWithoutSousSousAssemblagesInput
  }

  export type TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput = {
    id?: number
    taskTemplateId: number
    quantity?: number
  }

  export type TaskTemplateSousSousAssemblageCreateOrConnectWithoutSousSousAssemblageInput = {
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    create: XOR<TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput>
  }

  export type TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInputEnvelope = {
    data: TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInput | TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInput[]
    skipDuplicates?: boolean
  }

  export type BorneCreateWithoutSousSousAssemblagesInput = {
    nom: string
    productionLines?: ProductionLineCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateCreateNestedManyWithoutBorneInput
    kits?: KitCreateNestedManyWithoutBornesInput
    pieces?: PieceCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateWithoutSousSousAssemblagesInput = {
    id?: number
    nom: string
    productionLines?: ProductionLineUncheckedCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateUncheckedCreateNestedManyWithoutBorneInput
    kits?: KitUncheckedCreateNestedManyWithoutBornesInput
    pieces?: PieceUncheckedCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneCreateOrConnectWithoutSousSousAssemblagesInput = {
    where: BorneWhereUniqueInput
    create: XOR<BorneCreateWithoutSousSousAssemblagesInput, BorneUncheckedCreateWithoutSousSousAssemblagesInput>
  }

  export type SousAssemblageSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    update: XOR<SousAssemblageSousSousAssemblageUpdateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedUpdateWithoutSousSousAssemblageInput>
    create: XOR<SousAssemblageSousSousAssemblageCreateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageWhereUniqueInput
    data: XOR<SousAssemblageSousSousAssemblageUpdateWithoutSousSousAssemblageInput, SousAssemblageSousSousAssemblageUncheckedUpdateWithoutSousSousAssemblageInput>
  }

  export type SousAssemblageSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput = {
    where: SousAssemblageSousSousAssemblageScalarWhereInput
    data: XOR<SousAssemblageSousSousAssemblageUpdateManyMutationInput, SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageInput>
  }

  export type SousSousAssemblagePieceUpsertWithWhereUniqueWithoutSousSousAssemblageInput = {
    where: SousSousAssemblagePieceWhereUniqueInput
    update: XOR<SousSousAssemblagePieceUpdateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedUpdateWithoutSousSousAssemblageInput>
    create: XOR<SousSousAssemblagePieceCreateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedCreateWithoutSousSousAssemblageInput>
  }

  export type SousSousAssemblagePieceUpdateWithWhereUniqueWithoutSousSousAssemblageInput = {
    where: SousSousAssemblagePieceWhereUniqueInput
    data: XOR<SousSousAssemblagePieceUpdateWithoutSousSousAssemblageInput, SousSousAssemblagePieceUncheckedUpdateWithoutSousSousAssemblageInput>
  }

  export type SousSousAssemblagePieceUpdateManyWithWhereWithoutSousSousAssemblageInput = {
    where: SousSousAssemblagePieceScalarWhereInput
    data: XOR<SousSousAssemblagePieceUpdateManyMutationInput, SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageInput>
  }

  export type TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutSousSousAssemblageInput = {
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    update: XOR<TaskTemplateSousSousAssemblageUpdateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedUpdateWithoutSousSousAssemblageInput>
    create: XOR<TaskTemplateSousSousAssemblageCreateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutSousSousAssemblageInput>
  }

  export type TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutSousSousAssemblageInput = {
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    data: XOR<TaskTemplateSousSousAssemblageUpdateWithoutSousSousAssemblageInput, TaskTemplateSousSousAssemblageUncheckedUpdateWithoutSousSousAssemblageInput>
  }

  export type TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutSousSousAssemblageInput = {
    where: TaskTemplateSousSousAssemblageScalarWhereInput
    data: XOR<TaskTemplateSousSousAssemblageUpdateManyMutationInput, TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageInput>
  }

  export type TaskTemplateSousSousAssemblageScalarWhereInput = {
    AND?: TaskTemplateSousSousAssemblageScalarWhereInput | TaskTemplateSousSousAssemblageScalarWhereInput[]
    OR?: TaskTemplateSousSousAssemblageScalarWhereInput[]
    NOT?: TaskTemplateSousSousAssemblageScalarWhereInput | TaskTemplateSousSousAssemblageScalarWhereInput[]
    id?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    taskTemplateId?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    sousSousAssemblageId?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
    quantity?: IntFilter<"TaskTemplateSousSousAssemblage"> | number
  }

  export type BorneUpsertWithWhereUniqueWithoutSousSousAssemblagesInput = {
    where: BorneWhereUniqueInput
    update: XOR<BorneUpdateWithoutSousSousAssemblagesInput, BorneUncheckedUpdateWithoutSousSousAssemblagesInput>
    create: XOR<BorneCreateWithoutSousSousAssemblagesInput, BorneUncheckedCreateWithoutSousSousAssemblagesInput>
  }

  export type BorneUpdateWithWhereUniqueWithoutSousSousAssemblagesInput = {
    where: BorneWhereUniqueInput
    data: XOR<BorneUpdateWithoutSousSousAssemblagesInput, BorneUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type BorneUpdateManyWithWhereWithoutSousSousAssemblagesInput = {
    where: BorneScalarWhereInput
    data: XOR<BorneUpdateManyMutationInput, BorneUncheckedUpdateManyWithoutSousSousAssemblagesInput>
  }

  export type KitPieceCreateWithoutKitInput = {
    nombre?: number
    piece: PieceCreateNestedOneWithoutKitsInput
  }

  export type KitPieceUncheckedCreateWithoutKitInput = {
    id?: number
    pieceId: number
    nombre?: number
  }

  export type KitPieceCreateOrConnectWithoutKitInput = {
    where: KitPieceWhereUniqueInput
    create: XOR<KitPieceCreateWithoutKitInput, KitPieceUncheckedCreateWithoutKitInput>
  }

  export type KitPieceCreateManyKitInputEnvelope = {
    data: KitPieceCreateManyKitInput | KitPieceCreateManyKitInput[]
    skipDuplicates?: boolean
  }

  export type BorneCreateWithoutKitsInput = {
    nom: string
    productionLines?: ProductionLineCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateCreateNestedManyWithoutBorneInput
    pieces?: PieceCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateWithoutKitsInput = {
    id?: number
    nom: string
    productionLines?: ProductionLineUncheckedCreateNestedManyWithoutBorneInput
    taskTemplates?: TaskTemplateUncheckedCreateNestedManyWithoutBorneInput
    pieces?: PieceUncheckedCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageUncheckedCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneCreateOrConnectWithoutKitsInput = {
    where: BorneWhereUniqueInput
    create: XOR<BorneCreateWithoutKitsInput, BorneUncheckedCreateWithoutKitsInput>
  }

  export type KitPieceUpsertWithWhereUniqueWithoutKitInput = {
    where: KitPieceWhereUniqueInput
    update: XOR<KitPieceUpdateWithoutKitInput, KitPieceUncheckedUpdateWithoutKitInput>
    create: XOR<KitPieceCreateWithoutKitInput, KitPieceUncheckedCreateWithoutKitInput>
  }

  export type KitPieceUpdateWithWhereUniqueWithoutKitInput = {
    where: KitPieceWhereUniqueInput
    data: XOR<KitPieceUpdateWithoutKitInput, KitPieceUncheckedUpdateWithoutKitInput>
  }

  export type KitPieceUpdateManyWithWhereWithoutKitInput = {
    where: KitPieceScalarWhereInput
    data: XOR<KitPieceUpdateManyMutationInput, KitPieceUncheckedUpdateManyWithoutKitInput>
  }

  export type BorneUpsertWithWhereUniqueWithoutKitsInput = {
    where: BorneWhereUniqueInput
    update: XOR<BorneUpdateWithoutKitsInput, BorneUncheckedUpdateWithoutKitsInput>
    create: XOR<BorneCreateWithoutKitsInput, BorneUncheckedCreateWithoutKitsInput>
  }

  export type BorneUpdateWithWhereUniqueWithoutKitsInput = {
    where: BorneWhereUniqueInput
    data: XOR<BorneUpdateWithoutKitsInput, BorneUncheckedUpdateWithoutKitsInput>
  }

  export type BorneUpdateManyWithWhereWithoutKitsInput = {
    where: BorneScalarWhereInput
    data: XOR<BorneUpdateManyMutationInput, BorneUncheckedUpdateManyWithoutKitsInput>
  }

  export type PieceCreateWithoutSousAssemblagesInput = {
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceCreateNestedManyWithoutPieceInput
    bornes?: BorneCreateNestedManyWithoutPiecesInput
  }

  export type PieceUncheckedCreateWithoutSousAssemblagesInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceUncheckedCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutPieceInput
    bornes?: BorneUncheckedCreateNestedManyWithoutPiecesInput
  }

  export type PieceCreateOrConnectWithoutSousAssemblagesInput = {
    where: PieceWhereUniqueInput
    create: XOR<PieceCreateWithoutSousAssemblagesInput, PieceUncheckedCreateWithoutSousAssemblagesInput>
  }

  export type SousAssemblageCreateWithoutPiecesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousSousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageUncheckedCreateWithoutPiecesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageCreateOrConnectWithoutPiecesInput = {
    where: SousAssemblageWhereUniqueInput
    create: XOR<SousAssemblageCreateWithoutPiecesInput, SousAssemblageUncheckedCreateWithoutPiecesInput>
  }

  export type PieceUpsertWithoutSousAssemblagesInput = {
    update: XOR<PieceUpdateWithoutSousAssemblagesInput, PieceUncheckedUpdateWithoutSousAssemblagesInput>
    create: XOR<PieceCreateWithoutSousAssemblagesInput, PieceUncheckedCreateWithoutSousAssemblagesInput>
    where?: PieceWhereInput
  }

  export type PieceUpdateToOneWithWhereWithoutSousAssemblagesInput = {
    where?: PieceWhereInput
    data: XOR<PieceUpdateWithoutSousAssemblagesInput, PieceUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type PieceUpdateWithoutSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUpdateManyWithoutPieceNestedInput
    bornes?: BorneUpdateManyWithoutPiecesNestedInput
  }

  export type PieceUncheckedUpdateWithoutSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUncheckedUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedUpdateManyWithoutPieceNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutPiecesNestedInput
  }

  export type SousAssemblageUpsertWithoutPiecesInput = {
    update: XOR<SousAssemblageUpdateWithoutPiecesInput, SousAssemblageUncheckedUpdateWithoutPiecesInput>
    create: XOR<SousAssemblageCreateWithoutPiecesInput, SousAssemblageUncheckedCreateWithoutPiecesInput>
    where?: SousAssemblageWhereInput
  }

  export type SousAssemblageUpdateToOneWithWhereWithoutPiecesInput = {
    where?: SousAssemblageWhereInput
    data: XOR<SousAssemblageUpdateWithoutPiecesInput, SousAssemblageUncheckedUpdateWithoutPiecesInput>
  }

  export type SousAssemblageUpdateWithoutPiecesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageUncheckedUpdateWithoutPiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type PieceCreateWithoutSousSousAssemblagesInput = {
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceCreateNestedManyWithoutPieceInput
    bornes?: BorneCreateNestedManyWithoutPiecesInput
  }

  export type PieceUncheckedCreateWithoutSousSousAssemblagesInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceUncheckedCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutPieceInput
    bornes?: BorneUncheckedCreateNestedManyWithoutPiecesInput
  }

  export type PieceCreateOrConnectWithoutSousSousAssemblagesInput = {
    where: PieceWhereUniqueInput
    create: XOR<PieceCreateWithoutSousSousAssemblagesInput, PieceUncheckedCreateWithoutSousSousAssemblagesInput>
  }

  export type SousSousAssemblageCreateWithoutPiecesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageUncheckedCreateWithoutPiecesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageCreateOrConnectWithoutPiecesInput = {
    where: SousSousAssemblageWhereUniqueInput
    create: XOR<SousSousAssemblageCreateWithoutPiecesInput, SousSousAssemblageUncheckedCreateWithoutPiecesInput>
  }

  export type PieceUpsertWithoutSousSousAssemblagesInput = {
    update: XOR<PieceUpdateWithoutSousSousAssemblagesInput, PieceUncheckedUpdateWithoutSousSousAssemblagesInput>
    create: XOR<PieceCreateWithoutSousSousAssemblagesInput, PieceUncheckedCreateWithoutSousSousAssemblagesInput>
    where?: PieceWhereInput
  }

  export type PieceUpdateToOneWithWhereWithoutSousSousAssemblagesInput = {
    where?: PieceWhereInput
    data: XOR<PieceUpdateWithoutSousSousAssemblagesInput, PieceUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type PieceUpdateWithoutSousSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUpdateManyWithoutPieceNestedInput
    bornes?: BorneUpdateManyWithoutPiecesNestedInput
  }

  export type PieceUncheckedUpdateWithoutSousSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUncheckedUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedUpdateManyWithoutPieceNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutPiecesNestedInput
  }

  export type SousSousAssemblageUpsertWithoutPiecesInput = {
    update: XOR<SousSousAssemblageUpdateWithoutPiecesInput, SousSousAssemblageUncheckedUpdateWithoutPiecesInput>
    create: XOR<SousSousAssemblageCreateWithoutPiecesInput, SousSousAssemblageUncheckedCreateWithoutPiecesInput>
    where?: SousSousAssemblageWhereInput
  }

  export type SousSousAssemblageUpdateToOneWithWhereWithoutPiecesInput = {
    where?: SousSousAssemblageWhereInput
    data: XOR<SousSousAssemblageUpdateWithoutPiecesInput, SousSousAssemblageUncheckedUpdateWithoutPiecesInput>
  }

  export type SousSousAssemblageUpdateWithoutPiecesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type SousSousAssemblageUncheckedUpdateWithoutPiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type SousAssemblageCreateWithoutSousSousAssemblagesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageUncheckedCreateWithoutSousSousAssemblagesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceUncheckedCreateNestedManyWithoutSousAssemblageInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageCreateOrConnectWithoutSousSousAssemblagesInput = {
    where: SousAssemblageWhereUniqueInput
    create: XOR<SousAssemblageCreateWithoutSousSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutSousSousAssemblagesInput>
  }

  export type SousSousAssemblageCreateWithoutSousAssemblagesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousSousAssemblagePieceCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageUncheckedCreateWithoutSousAssemblagesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageCreateOrConnectWithoutSousAssemblagesInput = {
    where: SousSousAssemblageWhereUniqueInput
    create: XOR<SousSousAssemblageCreateWithoutSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutSousAssemblagesInput>
  }

  export type SousAssemblageUpsertWithoutSousSousAssemblagesInput = {
    update: XOR<SousAssemblageUpdateWithoutSousSousAssemblagesInput, SousAssemblageUncheckedUpdateWithoutSousSousAssemblagesInput>
    create: XOR<SousAssemblageCreateWithoutSousSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutSousSousAssemblagesInput>
    where?: SousAssemblageWhereInput
  }

  export type SousAssemblageUpdateToOneWithWhereWithoutSousSousAssemblagesInput = {
    where?: SousAssemblageWhereInput
    data: XOR<SousAssemblageUpdateWithoutSousSousAssemblagesInput, SousAssemblageUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type SousAssemblageUpdateWithoutSousSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageUncheckedUpdateWithoutSousSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type SousSousAssemblageUpsertWithoutSousAssemblagesInput = {
    update: XOR<SousSousAssemblageUpdateWithoutSousAssemblagesInput, SousSousAssemblageUncheckedUpdateWithoutSousAssemblagesInput>
    create: XOR<SousSousAssemblageCreateWithoutSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutSousAssemblagesInput>
    where?: SousSousAssemblageWhereInput
  }

  export type SousSousAssemblageUpdateToOneWithWhereWithoutSousAssemblagesInput = {
    where?: SousSousAssemblageWhereInput
    data: XOR<SousSousAssemblageUpdateWithoutSousAssemblagesInput, SousSousAssemblageUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type SousSousAssemblageUpdateWithoutSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousSousAssemblagePieceUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type SousSousAssemblageUncheckedUpdateWithoutSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type KitCreateWithoutPiecesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    bornes?: BorneCreateNestedManyWithoutKitsInput
  }

  export type KitUncheckedCreateWithoutPiecesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    bornes?: BorneUncheckedCreateNestedManyWithoutKitsInput
  }

  export type KitCreateOrConnectWithoutPiecesInput = {
    where: KitWhereUniqueInput
    create: XOR<KitCreateWithoutPiecesInput, KitUncheckedCreateWithoutPiecesInput>
  }

  export type PieceCreateWithoutKitsInput = {
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblagePieceCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceCreateNestedManyWithoutPieceInput
    bornes?: BorneCreateNestedManyWithoutPiecesInput
  }

  export type PieceUncheckedCreateWithoutKitsInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutPieceInput
    bornes?: BorneUncheckedCreateNestedManyWithoutPiecesInput
  }

  export type PieceCreateOrConnectWithoutKitsInput = {
    where: PieceWhereUniqueInput
    create: XOR<PieceCreateWithoutKitsInput, PieceUncheckedCreateWithoutKitsInput>
  }

  export type KitUpsertWithoutPiecesInput = {
    update: XOR<KitUpdateWithoutPiecesInput, KitUncheckedUpdateWithoutPiecesInput>
    create: XOR<KitCreateWithoutPiecesInput, KitUncheckedCreateWithoutPiecesInput>
    where?: KitWhereInput
  }

  export type KitUpdateToOneWithWhereWithoutPiecesInput = {
    where?: KitWhereInput
    data: XOR<KitUpdateWithoutPiecesInput, KitUncheckedUpdateWithoutPiecesInput>
  }

  export type KitUpdateWithoutPiecesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    bornes?: BorneUpdateManyWithoutKitsNestedInput
  }

  export type KitUncheckedUpdateWithoutPiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    bornes?: BorneUncheckedUpdateManyWithoutKitsNestedInput
  }

  export type PieceUpsertWithoutKitsInput = {
    update: XOR<PieceUpdateWithoutKitsInput, PieceUncheckedUpdateWithoutKitsInput>
    create: XOR<PieceCreateWithoutKitsInput, PieceUncheckedCreateWithoutKitsInput>
    where?: PieceWhereInput
  }

  export type PieceUpdateToOneWithWhereWithoutKitsInput = {
    where?: PieceWhereInput
    data: XOR<PieceUpdateWithoutKitsInput, PieceUncheckedUpdateWithoutKitsInput>
  }

  export type PieceUpdateWithoutKitsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblagePieceUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUpdateManyWithoutPieceNestedInput
    bornes?: BorneUpdateManyWithoutPiecesNestedInput
  }

  export type PieceUncheckedUpdateWithoutKitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedUpdateManyWithoutPieceNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutPiecesNestedInput
  }

  export type UserCreateWithoutStockLogsInput = {
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskCreateNestedManyWithoutAssignedToInput
    taskLogs?: ProductionTaskLogCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStockLogsInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskUncheckedCreateNestedManyWithoutAssignedToInput
    taskLogs?: ProductionTaskLogUncheckedCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStockLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockLogsInput, UserUncheckedCreateWithoutStockLogsInput>
  }

  export type UserUpsertWithoutStockLogsInput = {
    update: XOR<UserUpdateWithoutStockLogsInput, UserUncheckedUpdateWithoutStockLogsInput>
    create: XOR<UserCreateWithoutStockLogsInput, UserUncheckedCreateWithoutStockLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockLogsInput, UserUncheckedUpdateWithoutStockLogsInput>
  }

  export type UserUpdateWithoutStockLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUpdateManyWithoutAssignedToNestedInput
    taskLogs?: ProductionTaskLogUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStockLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    taskLogs?: ProductionTaskLogUncheckedUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductionTaskCreateWithoutTemplateInput = {
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTasksInput
    production: ProductionCreateNestedOneWithoutTasksInput
    logs?: ProductionTaskLogCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskUncheckedCreateWithoutTemplateInput = {
    id?: number
    productionId: number
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
    logs?: ProductionTaskLogUncheckedCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskCreateOrConnectWithoutTemplateInput = {
    where: ProductionTaskWhereUniqueInput
    create: XOR<ProductionTaskCreateWithoutTemplateInput, ProductionTaskUncheckedCreateWithoutTemplateInput>
  }

  export type ProductionTaskCreateManyTemplateInputEnvelope = {
    data: ProductionTaskCreateManyTemplateInput | ProductionTaskCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type BorneCreateWithoutTaskTemplatesInput = {
    nom: string
    productionLines?: ProductionLineCreateNestedManyWithoutBorneInput
    kits?: KitCreateNestedManyWithoutBornesInput
    pieces?: PieceCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateWithoutTaskTemplatesInput = {
    id?: number
    nom: string
    productionLines?: ProductionLineUncheckedCreateNestedManyWithoutBorneInput
    kits?: KitUncheckedCreateNestedManyWithoutBornesInput
    pieces?: PieceUncheckedCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageUncheckedCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneCreateOrConnectWithoutTaskTemplatesInput = {
    where: BorneWhereUniqueInput
    create: XOR<BorneCreateWithoutTaskTemplatesInput, BorneUncheckedCreateWithoutTaskTemplatesInput>
  }

  export type TaskTemplateLogCreateWithoutTaskTemplateInput = {
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
    user?: UserCreateNestedOneWithoutTemplateLogsInput
  }

  export type TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput = {
    id?: number
    userId?: number | null
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
  }

  export type TaskTemplateLogCreateOrConnectWithoutTaskTemplateInput = {
    where: TaskTemplateLogWhereUniqueInput
    create: XOR<TaskTemplateLogCreateWithoutTaskTemplateInput, TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplateLogCreateManyTaskTemplateInputEnvelope = {
    data: TaskTemplateLogCreateManyTaskTemplateInput | TaskTemplateLogCreateManyTaskTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplatePieceCreateWithoutTaskTemplateInput = {
    quantity?: number
    piece: PieceCreateNestedOneWithoutTaskTemplatePiecesInput
  }

  export type TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput = {
    id?: number
    pieceId: number
    quantity?: number
  }

  export type TaskTemplatePieceCreateOrConnectWithoutTaskTemplateInput = {
    where: TaskTemplatePieceWhereUniqueInput
    create: XOR<TaskTemplatePieceCreateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplatePieceCreateManyTaskTemplateInputEnvelope = {
    data: TaskTemplatePieceCreateManyTaskTemplateInput | TaskTemplatePieceCreateManyTaskTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput = {
    quantity?: number
    sousAssemblage: SousAssemblageCreateNestedOneWithoutTaskTemplateSousAssemblagesInput
  }

  export type TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput = {
    id?: number
    sousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousAssemblageCreateOrConnectWithoutTaskTemplateInput = {
    where: TaskTemplateSousAssemblageWhereUniqueInput
    create: XOR<TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousAssemblageCreateManyTaskTemplateInputEnvelope = {
    data: TaskTemplateSousAssemblageCreateManyTaskTemplateInput | TaskTemplateSousAssemblageCreateManyTaskTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput = {
    quantity?: number
    sousSousAssemblage: SousSousAssemblageCreateNestedOneWithoutTaskTemplateSousSousAssemblagesInput
  }

  export type TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput = {
    id?: number
    sousSousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousSousAssemblageCreateOrConnectWithoutTaskTemplateInput = {
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    create: XOR<TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousSousAssemblageCreateManyTaskTemplateInputEnvelope = {
    data: TaskTemplateSousSousAssemblageCreateManyTaskTemplateInput | TaskTemplateSousSousAssemblageCreateManyTaskTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ProductionTaskUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ProductionTaskWhereUniqueInput
    update: XOR<ProductionTaskUpdateWithoutTemplateInput, ProductionTaskUncheckedUpdateWithoutTemplateInput>
    create: XOR<ProductionTaskCreateWithoutTemplateInput, ProductionTaskUncheckedCreateWithoutTemplateInput>
  }

  export type ProductionTaskUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ProductionTaskWhereUniqueInput
    data: XOR<ProductionTaskUpdateWithoutTemplateInput, ProductionTaskUncheckedUpdateWithoutTemplateInput>
  }

  export type ProductionTaskUpdateManyWithWhereWithoutTemplateInput = {
    where: ProductionTaskScalarWhereInput
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyWithoutTemplateInput>
  }

  export type BorneUpsertWithoutTaskTemplatesInput = {
    update: XOR<BorneUpdateWithoutTaskTemplatesInput, BorneUncheckedUpdateWithoutTaskTemplatesInput>
    create: XOR<BorneCreateWithoutTaskTemplatesInput, BorneUncheckedCreateWithoutTaskTemplatesInput>
    where?: BorneWhereInput
  }

  export type BorneUpdateToOneWithWhereWithoutTaskTemplatesInput = {
    where?: BorneWhereInput
    data: XOR<BorneUpdateWithoutTaskTemplatesInput, BorneUncheckedUpdateWithoutTaskTemplatesInput>
  }

  export type BorneUpdateWithoutTaskTemplatesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUpdateManyWithoutBorneNestedInput
    kits?: KitUpdateManyWithoutBornesNestedInput
    pieces?: PieceUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateWithoutTaskTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUncheckedUpdateManyWithoutBorneNestedInput
    kits?: KitUncheckedUpdateManyWithoutBornesNestedInput
    pieces?: PieceUncheckedUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type TaskTemplateLogUpsertWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplateLogWhereUniqueInput
    update: XOR<TaskTemplateLogUpdateWithoutTaskTemplateInput, TaskTemplateLogUncheckedUpdateWithoutTaskTemplateInput>
    create: XOR<TaskTemplateLogCreateWithoutTaskTemplateInput, TaskTemplateLogUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplateLogUpdateWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplateLogWhereUniqueInput
    data: XOR<TaskTemplateLogUpdateWithoutTaskTemplateInput, TaskTemplateLogUncheckedUpdateWithoutTaskTemplateInput>
  }

  export type TaskTemplateLogUpdateManyWithWhereWithoutTaskTemplateInput = {
    where: TaskTemplateLogScalarWhereInput
    data: XOR<TaskTemplateLogUpdateManyMutationInput, TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateInput>
  }

  export type TaskTemplatePieceUpsertWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplatePieceWhereUniqueInput
    update: XOR<TaskTemplatePieceUpdateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedUpdateWithoutTaskTemplateInput>
    create: XOR<TaskTemplatePieceCreateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplatePieceUpdateWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplatePieceWhereUniqueInput
    data: XOR<TaskTemplatePieceUpdateWithoutTaskTemplateInput, TaskTemplatePieceUncheckedUpdateWithoutTaskTemplateInput>
  }

  export type TaskTemplatePieceUpdateManyWithWhereWithoutTaskTemplateInput = {
    where: TaskTemplatePieceScalarWhereInput
    data: XOR<TaskTemplatePieceUpdateManyMutationInput, TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplateSousAssemblageWhereUniqueInput
    update: XOR<TaskTemplateSousAssemblageUpdateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedUpdateWithoutTaskTemplateInput>
    create: XOR<TaskTemplateSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplateSousAssemblageWhereUniqueInput
    data: XOR<TaskTemplateSousAssemblageUpdateWithoutTaskTemplateInput, TaskTemplateSousAssemblageUncheckedUpdateWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput = {
    where: TaskTemplateSousAssemblageScalarWhereInput
    data: XOR<TaskTemplateSousAssemblageUpdateManyMutationInput, TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousSousAssemblageUpsertWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    update: XOR<TaskTemplateSousSousAssemblageUpdateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedUpdateWithoutTaskTemplateInput>
    create: XOR<TaskTemplateSousSousAssemblageCreateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedCreateWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousSousAssemblageUpdateWithWhereUniqueWithoutTaskTemplateInput = {
    where: TaskTemplateSousSousAssemblageWhereUniqueInput
    data: XOR<TaskTemplateSousSousAssemblageUpdateWithoutTaskTemplateInput, TaskTemplateSousSousAssemblageUncheckedUpdateWithoutTaskTemplateInput>
  }

  export type TaskTemplateSousSousAssemblageUpdateManyWithWhereWithoutTaskTemplateInput = {
    where: TaskTemplateSousSousAssemblageScalarWhereInput
    data: XOR<TaskTemplateSousSousAssemblageUpdateManyMutationInput, TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateInput>
  }

  export type ProductionLineCreateWithoutProductionInput = {
    quantity: number
    borne: BorneCreateNestedOneWithoutProductionLinesInput
  }

  export type ProductionLineUncheckedCreateWithoutProductionInput = {
    id?: number
    borneId: number
    quantity: number
  }

  export type ProductionLineCreateOrConnectWithoutProductionInput = {
    where: ProductionLineWhereUniqueInput
    create: XOR<ProductionLineCreateWithoutProductionInput, ProductionLineUncheckedCreateWithoutProductionInput>
  }

  export type ProductionLineCreateManyProductionInputEnvelope = {
    data: ProductionLineCreateManyProductionInput | ProductionLineCreateManyProductionInput[]
    skipDuplicates?: boolean
  }

  export type ProductionTaskCreateWithoutProductionInput = {
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTasksInput
    template?: TaskTemplateCreateNestedOneWithoutProductionTasksInput
    logs?: ProductionTaskLogCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskUncheckedCreateWithoutProductionInput = {
    id?: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
    logs?: ProductionTaskLogUncheckedCreateNestedManyWithoutProductionTaskInput
  }

  export type ProductionTaskCreateOrConnectWithoutProductionInput = {
    where: ProductionTaskWhereUniqueInput
    create: XOR<ProductionTaskCreateWithoutProductionInput, ProductionTaskUncheckedCreateWithoutProductionInput>
  }

  export type ProductionTaskCreateManyProductionInputEnvelope = {
    data: ProductionTaskCreateManyProductionInput | ProductionTaskCreateManyProductionInput[]
    skipDuplicates?: boolean
  }

  export type ProductionLineUpsertWithWhereUniqueWithoutProductionInput = {
    where: ProductionLineWhereUniqueInput
    update: XOR<ProductionLineUpdateWithoutProductionInput, ProductionLineUncheckedUpdateWithoutProductionInput>
    create: XOR<ProductionLineCreateWithoutProductionInput, ProductionLineUncheckedCreateWithoutProductionInput>
  }

  export type ProductionLineUpdateWithWhereUniqueWithoutProductionInput = {
    where: ProductionLineWhereUniqueInput
    data: XOR<ProductionLineUpdateWithoutProductionInput, ProductionLineUncheckedUpdateWithoutProductionInput>
  }

  export type ProductionLineUpdateManyWithWhereWithoutProductionInput = {
    where: ProductionLineScalarWhereInput
    data: XOR<ProductionLineUpdateManyMutationInput, ProductionLineUncheckedUpdateManyWithoutProductionInput>
  }

  export type ProductionTaskUpsertWithWhereUniqueWithoutProductionInput = {
    where: ProductionTaskWhereUniqueInput
    update: XOR<ProductionTaskUpdateWithoutProductionInput, ProductionTaskUncheckedUpdateWithoutProductionInput>
    create: XOR<ProductionTaskCreateWithoutProductionInput, ProductionTaskUncheckedCreateWithoutProductionInput>
  }

  export type ProductionTaskUpdateWithWhereUniqueWithoutProductionInput = {
    where: ProductionTaskWhereUniqueInput
    data: XOR<ProductionTaskUpdateWithoutProductionInput, ProductionTaskUncheckedUpdateWithoutProductionInput>
  }

  export type ProductionTaskUpdateManyWithWhereWithoutProductionInput = {
    where: ProductionTaskScalarWhereInput
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyWithoutProductionInput>
  }

  export type BorneCreateWithoutProductionLinesInput = {
    nom: string
    taskTemplates?: TaskTemplateCreateNestedManyWithoutBorneInput
    kits?: KitCreateNestedManyWithoutBornesInput
    pieces?: PieceCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageCreateNestedManyWithoutBornesInput
  }

  export type BorneUncheckedCreateWithoutProductionLinesInput = {
    id?: number
    nom: string
    taskTemplates?: TaskTemplateUncheckedCreateNestedManyWithoutBorneInput
    kits?: KitUncheckedCreateNestedManyWithoutBornesInput
    pieces?: PieceUncheckedCreateNestedManyWithoutBornesInput
    sousAssemblages?: SousAssemblageUncheckedCreateNestedManyWithoutBornesInput
    sousSousAssemblages?: SousSousAssemblageUncheckedCreateNestedManyWithoutBornesInput
  }

  export type BorneCreateOrConnectWithoutProductionLinesInput = {
    where: BorneWhereUniqueInput
    create: XOR<BorneCreateWithoutProductionLinesInput, BorneUncheckedCreateWithoutProductionLinesInput>
  }

  export type ProductionCreateWithoutLinesInput = {
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    tasks?: ProductionTaskCreateNestedManyWithoutProductionInput
  }

  export type ProductionUncheckedCreateWithoutLinesInput = {
    id?: number
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    tasks?: ProductionTaskUncheckedCreateNestedManyWithoutProductionInput
  }

  export type ProductionCreateOrConnectWithoutLinesInput = {
    where: ProductionWhereUniqueInput
    create: XOR<ProductionCreateWithoutLinesInput, ProductionUncheckedCreateWithoutLinesInput>
  }

  export type BorneUpsertWithoutProductionLinesInput = {
    update: XOR<BorneUpdateWithoutProductionLinesInput, BorneUncheckedUpdateWithoutProductionLinesInput>
    create: XOR<BorneCreateWithoutProductionLinesInput, BorneUncheckedCreateWithoutProductionLinesInput>
    where?: BorneWhereInput
  }

  export type BorneUpdateToOneWithWhereWithoutProductionLinesInput = {
    where?: BorneWhereInput
    data: XOR<BorneUpdateWithoutProductionLinesInput, BorneUncheckedUpdateWithoutProductionLinesInput>
  }

  export type BorneUpdateWithoutProductionLinesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    taskTemplates?: TaskTemplateUpdateManyWithoutBorneNestedInput
    kits?: KitUpdateManyWithoutBornesNestedInput
    pieces?: PieceUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateWithoutProductionLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    taskTemplates?: TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput
    kits?: KitUncheckedUpdateManyWithoutBornesNestedInput
    pieces?: PieceUncheckedUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type ProductionUpsertWithoutLinesInput = {
    update: XOR<ProductionUpdateWithoutLinesInput, ProductionUncheckedUpdateWithoutLinesInput>
    create: XOR<ProductionCreateWithoutLinesInput, ProductionUncheckedCreateWithoutLinesInput>
    where?: ProductionWhereInput
  }

  export type ProductionUpdateToOneWithWhereWithoutLinesInput = {
    where?: ProductionWhereInput
    data: XOR<ProductionUpdateWithoutLinesInput, ProductionUncheckedUpdateWithoutLinesInput>
  }

  export type ProductionUpdateWithoutLinesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: ProductionTaskUpdateManyWithoutProductionNestedInput
  }

  export type ProductionUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: ProductionTaskUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type UserCreateWithoutAssignedTasksInput = {
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskLogs?: ProductionTaskLogCreateNestedManyWithoutUserInput
    stockLogs?: StockLogCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taskLogs?: ProductionTaskLogUncheckedCreateNestedManyWithoutUserInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type ProductionCreateWithoutTasksInput = {
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    lines?: ProductionLineCreateNestedManyWithoutProductionInput
  }

  export type ProductionUncheckedCreateWithoutTasksInput = {
    id?: number
    nom: string
    reference?: string | null
    description?: string | null
    status?: $Enums.ProductionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    lines?: ProductionLineUncheckedCreateNestedManyWithoutProductionInput
  }

  export type ProductionCreateOrConnectWithoutTasksInput = {
    where: ProductionWhereUniqueInput
    create: XOR<ProductionCreateWithoutTasksInput, ProductionUncheckedCreateWithoutTasksInput>
  }

  export type TaskTemplateCreateWithoutProductionTasksInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    borne?: BorneCreateNestedOneWithoutTaskTemplatesInput
    logs?: TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateWithoutProductionTasksInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    logs?: TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateCreateOrConnectWithoutProductionTasksInput = {
    where: TaskTemplateWhereUniqueInput
    create: XOR<TaskTemplateCreateWithoutProductionTasksInput, TaskTemplateUncheckedCreateWithoutProductionTasksInput>
  }

  export type ProductionTaskLogCreateWithoutProductionTaskInput = {
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
    user?: UserCreateNestedOneWithoutTaskLogsInput
  }

  export type ProductionTaskLogUncheckedCreateWithoutProductionTaskInput = {
    id?: number
    userId?: number | null
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
  }

  export type ProductionTaskLogCreateOrConnectWithoutProductionTaskInput = {
    where: ProductionTaskLogWhereUniqueInput
    create: XOR<ProductionTaskLogCreateWithoutProductionTaskInput, ProductionTaskLogUncheckedCreateWithoutProductionTaskInput>
  }

  export type ProductionTaskLogCreateManyProductionTaskInputEnvelope = {
    data: ProductionTaskLogCreateManyProductionTaskInput | ProductionTaskLogCreateManyProductionTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskLogs?: ProductionTaskLogUpdateManyWithoutUserNestedInput
    stockLogs?: StockLogUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskLogs?: ProductionTaskLogUncheckedUpdateManyWithoutUserNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductionUpsertWithoutTasksInput = {
    update: XOR<ProductionUpdateWithoutTasksInput, ProductionUncheckedUpdateWithoutTasksInput>
    create: XOR<ProductionCreateWithoutTasksInput, ProductionUncheckedCreateWithoutTasksInput>
    where?: ProductionWhereInput
  }

  export type ProductionUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProductionWhereInput
    data: XOR<ProductionUpdateWithoutTasksInput, ProductionUncheckedUpdateWithoutTasksInput>
  }

  export type ProductionUpdateWithoutTasksInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: ProductionLineUpdateManyWithoutProductionNestedInput
  }

  export type ProductionUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: ProductionLineUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type TaskTemplateUpsertWithoutProductionTasksInput = {
    update: XOR<TaskTemplateUpdateWithoutProductionTasksInput, TaskTemplateUncheckedUpdateWithoutProductionTasksInput>
    create: XOR<TaskTemplateCreateWithoutProductionTasksInput, TaskTemplateUncheckedCreateWithoutProductionTasksInput>
    where?: TaskTemplateWhereInput
  }

  export type TaskTemplateUpdateToOneWithWhereWithoutProductionTasksInput = {
    where?: TaskTemplateWhereInput
    data: XOR<TaskTemplateUpdateWithoutProductionTasksInput, TaskTemplateUncheckedUpdateWithoutProductionTasksInput>
  }

  export type TaskTemplateUpdateWithoutProductionTasksInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    borne?: BorneUpdateOneWithoutTaskTemplatesNestedInput
    logs?: TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateWithoutProductionTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logs?: TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type ProductionTaskLogUpsertWithWhereUniqueWithoutProductionTaskInput = {
    where: ProductionTaskLogWhereUniqueInput
    update: XOR<ProductionTaskLogUpdateWithoutProductionTaskInput, ProductionTaskLogUncheckedUpdateWithoutProductionTaskInput>
    create: XOR<ProductionTaskLogCreateWithoutProductionTaskInput, ProductionTaskLogUncheckedCreateWithoutProductionTaskInput>
  }

  export type ProductionTaskLogUpdateWithWhereUniqueWithoutProductionTaskInput = {
    where: ProductionTaskLogWhereUniqueInput
    data: XOR<ProductionTaskLogUpdateWithoutProductionTaskInput, ProductionTaskLogUncheckedUpdateWithoutProductionTaskInput>
  }

  export type ProductionTaskLogUpdateManyWithWhereWithoutProductionTaskInput = {
    where: ProductionTaskLogScalarWhereInput
    data: XOR<ProductionTaskLogUpdateManyMutationInput, ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskInput>
  }

  export type ProductionTaskCreateWithoutLogsInput = {
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTasksInput
    production: ProductionCreateNestedOneWithoutTasksInput
    template?: TaskTemplateCreateNestedOneWithoutProductionTasksInput
  }

  export type ProductionTaskUncheckedCreateWithoutLogsInput = {
    id?: number
    productionId: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
  }

  export type ProductionTaskCreateOrConnectWithoutLogsInput = {
    where: ProductionTaskWhereUniqueInput
    create: XOR<ProductionTaskCreateWithoutLogsInput, ProductionTaskUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutTaskLogsInput = {
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskCreateNestedManyWithoutAssignedToInput
    stockLogs?: StockLogCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskLogsInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskUncheckedCreateNestedManyWithoutAssignedToInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutUserInput
    templateLogs?: TaskTemplateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskLogsInput, UserUncheckedCreateWithoutTaskLogsInput>
  }

  export type ProductionTaskUpsertWithoutLogsInput = {
    update: XOR<ProductionTaskUpdateWithoutLogsInput, ProductionTaskUncheckedUpdateWithoutLogsInput>
    create: XOR<ProductionTaskCreateWithoutLogsInput, ProductionTaskUncheckedCreateWithoutLogsInput>
    where?: ProductionTaskWhereInput
  }

  export type ProductionTaskUpdateToOneWithWhereWithoutLogsInput = {
    where?: ProductionTaskWhereInput
    data: XOR<ProductionTaskUpdateWithoutLogsInput, ProductionTaskUncheckedUpdateWithoutLogsInput>
  }

  export type ProductionTaskUpdateWithoutLogsInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTasksNestedInput
    production?: ProductionUpdateOneRequiredWithoutTasksNestedInput
    template?: TaskTemplateUpdateOneWithoutProductionTasksNestedInput
  }

  export type ProductionTaskUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutTaskLogsInput = {
    update: XOR<UserUpdateWithoutTaskLogsInput, UserUncheckedUpdateWithoutTaskLogsInput>
    create: XOR<UserCreateWithoutTaskLogsInput, UserUncheckedCreateWithoutTaskLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskLogsInput, UserUncheckedUpdateWithoutTaskLogsInput>
  }

  export type UserUpdateWithoutTaskLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUpdateManyWithoutAssignedToNestedInput
    stockLogs?: StockLogUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutUserNestedInput
    templateLogs?: TaskTemplateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PieceCreateWithoutTaskTemplatePiecesInput = {
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceCreateNestedManyWithoutPieceInput
    bornes?: BorneCreateNestedManyWithoutPiecesInput
  }

  export type PieceUncheckedCreateWithoutTaskTemplatePiecesInput = {
    id?: number
    nom: string
    reference: string
    nombre?: number
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    kits?: KitPieceUncheckedCreateNestedManyWithoutPieceInput
    sousAssemblages?: SousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutPieceInput
    bornes?: BorneUncheckedCreateNestedManyWithoutPiecesInput
  }

  export type PieceCreateOrConnectWithoutTaskTemplatePiecesInput = {
    where: PieceWhereUniqueInput
    create: XOR<PieceCreateWithoutTaskTemplatePiecesInput, PieceUncheckedCreateWithoutTaskTemplatePiecesInput>
  }

  export type TaskTemplateCreateWithoutPiecesInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskCreateNestedManyWithoutTemplateInput
    borne?: BorneCreateNestedOneWithoutTaskTemplatesInput
    logs?: TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateWithoutPiecesInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput
    logs?: TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateCreateOrConnectWithoutPiecesInput = {
    where: TaskTemplateWhereUniqueInput
    create: XOR<TaskTemplateCreateWithoutPiecesInput, TaskTemplateUncheckedCreateWithoutPiecesInput>
  }

  export type PieceUpsertWithoutTaskTemplatePiecesInput = {
    update: XOR<PieceUpdateWithoutTaskTemplatePiecesInput, PieceUncheckedUpdateWithoutTaskTemplatePiecesInput>
    create: XOR<PieceCreateWithoutTaskTemplatePiecesInput, PieceUncheckedCreateWithoutTaskTemplatePiecesInput>
    where?: PieceWhereInput
  }

  export type PieceUpdateToOneWithWhereWithoutTaskTemplatePiecesInput = {
    where?: PieceWhereInput
    data: XOR<PieceUpdateWithoutTaskTemplatePiecesInput, PieceUncheckedUpdateWithoutTaskTemplatePiecesInput>
  }

  export type PieceUpdateWithoutTaskTemplatePiecesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUpdateManyWithoutPieceNestedInput
    bornes?: BorneUpdateManyWithoutPiecesNestedInput
  }

  export type PieceUncheckedUpdateWithoutTaskTemplatePiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUncheckedUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutPiecesNestedInput
  }

  export type TaskTemplateUpsertWithoutPiecesInput = {
    update: XOR<TaskTemplateUpdateWithoutPiecesInput, TaskTemplateUncheckedUpdateWithoutPiecesInput>
    create: XOR<TaskTemplateCreateWithoutPiecesInput, TaskTemplateUncheckedCreateWithoutPiecesInput>
    where?: TaskTemplateWhereInput
  }

  export type TaskTemplateUpdateToOneWithWhereWithoutPiecesInput = {
    where?: TaskTemplateWhereInput
    data: XOR<TaskTemplateUpdateWithoutPiecesInput, TaskTemplateUncheckedUpdateWithoutPiecesInput>
  }

  export type TaskTemplateUpdateWithoutPiecesInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUpdateManyWithoutTemplateNestedInput
    borne?: BorneUpdateOneWithoutTaskTemplatesNestedInput
    logs?: TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateWithoutPiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput
    logs?: TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type SousAssemblageCreateWithoutTaskTemplateSousAssemblagesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceCreateNestedManyWithoutSousAssemblageInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageUncheckedCreateWithoutTaskTemplateSousAssemblagesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    pieces?: SousAssemblagePieceUncheckedCreateNestedManyWithoutSousAssemblageInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousAssemblagesInput
  }

  export type SousAssemblageCreateOrConnectWithoutTaskTemplateSousAssemblagesInput = {
    where: SousAssemblageWhereUniqueInput
    create: XOR<SousAssemblageCreateWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutTaskTemplateSousAssemblagesInput>
  }

  export type TaskTemplateCreateWithoutSousAssemblagesInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskCreateNestedManyWithoutTemplateInput
    borne?: BorneCreateNestedOneWithoutTaskTemplatesInput
    logs?: TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateWithoutSousAssemblagesInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput
    logs?: TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateCreateOrConnectWithoutSousAssemblagesInput = {
    where: TaskTemplateWhereUniqueInput
    create: XOR<TaskTemplateCreateWithoutSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousAssemblagesInput>
  }

  export type SousAssemblageUpsertWithoutTaskTemplateSousAssemblagesInput = {
    update: XOR<SousAssemblageUpdateWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUncheckedUpdateWithoutTaskTemplateSousAssemblagesInput>
    create: XOR<SousAssemblageCreateWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUncheckedCreateWithoutTaskTemplateSousAssemblagesInput>
    where?: SousAssemblageWhereInput
  }

  export type SousAssemblageUpdateToOneWithWhereWithoutTaskTemplateSousAssemblagesInput = {
    where?: SousAssemblageWhereInput
    data: XOR<SousAssemblageUpdateWithoutTaskTemplateSousAssemblagesInput, SousAssemblageUncheckedUpdateWithoutTaskTemplateSousAssemblagesInput>
  }

  export type SousAssemblageUpdateWithoutTaskTemplateSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUpdateManyWithoutSousAssemblageNestedInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageUncheckedUpdateWithoutTaskTemplateSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageNestedInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousAssemblagesNestedInput
  }

  export type TaskTemplateUpsertWithoutSousAssemblagesInput = {
    update: XOR<TaskTemplateUpdateWithoutSousAssemblagesInput, TaskTemplateUncheckedUpdateWithoutSousAssemblagesInput>
    create: XOR<TaskTemplateCreateWithoutSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousAssemblagesInput>
    where?: TaskTemplateWhereInput
  }

  export type TaskTemplateUpdateToOneWithWhereWithoutSousAssemblagesInput = {
    where?: TaskTemplateWhereInput
    data: XOR<TaskTemplateUpdateWithoutSousAssemblagesInput, TaskTemplateUncheckedUpdateWithoutSousAssemblagesInput>
  }

  export type TaskTemplateUpdateWithoutSousAssemblagesInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUpdateManyWithoutTemplateNestedInput
    borne?: BorneUpdateOneWithoutTaskTemplatesNestedInput
    logs?: TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateWithoutSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput
    logs?: TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type SousSousAssemblageCreateWithoutTaskTemplateSousSousAssemblagesInput = {
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageCreateNestedManyWithoutSousSousAssemblageInput
    pieces?: SousSousAssemblagePieceCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageUncheckedCreateWithoutTaskTemplateSousSousAssemblagesInput = {
    id?: number
    nom: string
    reference: string
    photo?: string | null
    emplacement: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    nombre?: number
    seuilAlerte?: number
    etat?: $Enums.PieceEtat
    numero?: string | null
    type?: $Enums.PieceType
    version?: string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    pieces?: SousSousAssemblagePieceUncheckedCreateNestedManyWithoutSousSousAssemblageInput
    bornes?: BorneUncheckedCreateNestedManyWithoutSousSousAssemblagesInput
  }

  export type SousSousAssemblageCreateOrConnectWithoutTaskTemplateSousSousAssemblagesInput = {
    where: SousSousAssemblageWhereUniqueInput
    create: XOR<SousSousAssemblageCreateWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutTaskTemplateSousSousAssemblagesInput>
  }

  export type TaskTemplateCreateWithoutSousSousAssemblagesInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskCreateNestedManyWithoutTemplateInput
    borne?: BorneCreateNestedOneWithoutTaskTemplatesInput
    logs?: TaskTemplateLogCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateWithoutSousSousAssemblagesInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput
    logs?: TaskTemplateLogUncheckedCreateNestedManyWithoutTaskTemplateInput
    pieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateCreateOrConnectWithoutSousSousAssemblagesInput = {
    where: TaskTemplateWhereUniqueInput
    create: XOR<TaskTemplateCreateWithoutSousSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousSousAssemblagesInput>
  }

  export type SousSousAssemblageUpsertWithoutTaskTemplateSousSousAssemblagesInput = {
    update: XOR<SousSousAssemblageUpdateWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUncheckedUpdateWithoutTaskTemplateSousSousAssemblagesInput>
    create: XOR<SousSousAssemblageCreateWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUncheckedCreateWithoutTaskTemplateSousSousAssemblagesInput>
    where?: SousSousAssemblageWhereInput
  }

  export type SousSousAssemblageUpdateToOneWithWhereWithoutTaskTemplateSousSousAssemblagesInput = {
    where?: SousSousAssemblageWhereInput
    data: XOR<SousSousAssemblageUpdateWithoutTaskTemplateSousSousAssemblagesInput, SousSousAssemblageUncheckedUpdateWithoutTaskTemplateSousSousAssemblagesInput>
  }

  export type SousSousAssemblageUpdateWithoutTaskTemplateSousSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    pieces?: SousSousAssemblagePieceUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type SousSousAssemblageUncheckedUpdateWithoutTaskTemplateSousSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    pieces?: SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    bornes?: BorneUncheckedUpdateManyWithoutSousSousAssemblagesNestedInput
  }

  export type TaskTemplateUpsertWithoutSousSousAssemblagesInput = {
    update: XOR<TaskTemplateUpdateWithoutSousSousAssemblagesInput, TaskTemplateUncheckedUpdateWithoutSousSousAssemblagesInput>
    create: XOR<TaskTemplateCreateWithoutSousSousAssemblagesInput, TaskTemplateUncheckedCreateWithoutSousSousAssemblagesInput>
    where?: TaskTemplateWhereInput
  }

  export type TaskTemplateUpdateToOneWithWhereWithoutSousSousAssemblagesInput = {
    where?: TaskTemplateWhereInput
    data: XOR<TaskTemplateUpdateWithoutSousSousAssemblagesInput, TaskTemplateUncheckedUpdateWithoutSousSousAssemblagesInput>
  }

  export type TaskTemplateUpdateWithoutSousSousAssemblagesInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUpdateManyWithoutTemplateNestedInput
    borne?: BorneUpdateOneWithoutTaskTemplatesNestedInput
    logs?: TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateWithoutSousSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput
    logs?: TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateCreateWithoutLogsInput = {
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskCreateNestedManyWithoutTemplateInput
    borne?: BorneCreateNestedOneWithoutTaskTemplatesInput
    pieces?: TaskTemplatePieceCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateUncheckedCreateWithoutLogsInput = {
    id?: number
    borneId?: number | null
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutTemplateInput
    pieces?: TaskTemplatePieceUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedCreateNestedManyWithoutTaskTemplateInput
  }

  export type TaskTemplateCreateOrConnectWithoutLogsInput = {
    where: TaskTemplateWhereUniqueInput
    create: XOR<TaskTemplateCreateWithoutLogsInput, TaskTemplateUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutTemplateLogsInput = {
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskCreateNestedManyWithoutAssignedToInput
    taskLogs?: ProductionTaskLogCreateNestedManyWithoutUserInput
    stockLogs?: StockLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTemplateLogsInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTasks?: ProductionTaskUncheckedCreateNestedManyWithoutAssignedToInput
    taskLogs?: ProductionTaskLogUncheckedCreateNestedManyWithoutUserInput
    stockLogs?: StockLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTemplateLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemplateLogsInput, UserUncheckedCreateWithoutTemplateLogsInput>
  }

  export type TaskTemplateUpsertWithoutLogsInput = {
    update: XOR<TaskTemplateUpdateWithoutLogsInput, TaskTemplateUncheckedUpdateWithoutLogsInput>
    create: XOR<TaskTemplateCreateWithoutLogsInput, TaskTemplateUncheckedCreateWithoutLogsInput>
    where?: TaskTemplateWhereInput
  }

  export type TaskTemplateUpdateToOneWithWhereWithoutLogsInput = {
    where?: TaskTemplateWhereInput
    data: XOR<TaskTemplateUpdateWithoutLogsInput, TaskTemplateUncheckedUpdateWithoutLogsInput>
  }

  export type TaskTemplateUpdateWithoutLogsInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUpdateManyWithoutTemplateNestedInput
    borne?: BorneUpdateOneWithoutTaskTemplatesNestedInput
    pieces?: TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput
    pieces?: TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type UserUpsertWithoutTemplateLogsInput = {
    update: XOR<UserUpdateWithoutTemplateLogsInput, UserUncheckedUpdateWithoutTemplateLogsInput>
    create: XOR<UserCreateWithoutTemplateLogsInput, UserUncheckedCreateWithoutTemplateLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTemplateLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTemplateLogsInput, UserUncheckedUpdateWithoutTemplateLogsInput>
  }

  export type UserUpdateWithoutTemplateLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUpdateManyWithoutAssignedToNestedInput
    taskLogs?: ProductionTaskLogUpdateManyWithoutUserNestedInput
    stockLogs?: StockLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTemplateLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: ProductionTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    taskLogs?: ProductionTaskLogUncheckedUpdateManyWithoutUserNestedInput
    stockLogs?: StockLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductionLineCreateManyBorneInput = {
    id?: number
    productionId: number
    quantity: number
  }

  export type TaskTemplateCreateManyBorneInput = {
    id?: number
    label: string
    description?: string | null
    order?: number | null
    estimatedMinutesPerUnit?: number | null
    active?: boolean
  }

  export type ProductionLineUpdateWithoutBorneInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    production?: ProductionUpdateOneRequiredWithoutLinesNestedInput
  }

  export type ProductionLineUncheckedUpdateWithoutBorneInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionLineUncheckedUpdateManyWithoutBorneInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateUpdateWithoutBorneInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUpdateManyWithoutTemplateNestedInput
    logs?: TaskTemplateLogUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateWithoutBorneInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutTemplateNestedInput
    logs?: TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateNestedInput
    pieces?: TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
    sousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateNestedInput
  }

  export type TaskTemplateUncheckedUpdateManyWithoutBorneInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedMinutesPerUnit?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KitUpdateWithoutBornesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: KitPieceUpdateManyWithoutKitNestedInput
  }

  export type KitUncheckedUpdateWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: KitPieceUncheckedUpdateManyWithoutKitNestedInput
  }

  export type KitUncheckedUpdateManyWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type PieceUpdateWithoutBornesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUpdateManyWithoutPieceNestedInput
  }

  export type PieceUncheckedUpdateWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    kits?: KitPieceUncheckedUpdateManyWithoutPieceNestedInput
    sousAssemblages?: SousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    sousSousAssemblages?: SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceNestedInput
    taskTemplatePieces?: TaskTemplatePieceUncheckedUpdateManyWithoutPieceNestedInput
  }

  export type PieceUncheckedUpdateManyWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nombre?: IntFieldUpdateOperationsInput | number
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousAssemblageUpdateWithoutBornesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUpdateManyWithoutSousAssemblageNestedInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUpdateManyWithoutSousAssemblageNestedInput
  }

  export type SousAssemblageUncheckedUpdateWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    pieces?: SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageNestedInput
    sousSousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
    taskTemplateSousAssemblages?: TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageNestedInput
  }

  export type SousAssemblageUncheckedUpdateManyWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type SousSousAssemblageUpdateWithoutBornesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
    pieces?: SousSousAssemblagePieceUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUpdateManyWithoutSousSousAssemblageNestedInput
  }

  export type SousSousAssemblageUncheckedUpdateWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
    sousAssemblages?: SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    pieces?: SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
    taskTemplateSousSousAssemblages?: TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageNestedInput
  }

  export type SousSousAssemblageUncheckedUpdateManyWithoutBornesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    nombre?: IntFieldUpdateOperationsInput | number
    seuilAlerte?: IntFieldUpdateOperationsInput | number
    etat?: EnumPieceEtatFieldUpdateOperationsInput | $Enums.PieceEtat
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPieceTypeFieldUpdateOperationsInput | $Enums.PieceType
    version?: StringFieldUpdateOperationsInput | string
  }

  export type ProductionTaskCreateManyAssignedToInput = {
    id?: number
    productionId: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
  }

  export type ProductionTaskLogCreateManyUserInput = {
    id?: number
    productionTaskId: number
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
  }

  export type StockLogCreateManyUserInput = {
    id?: number
    type: string
    itemId: number
    quantity: number
    operation: $Enums.StockOperation
    createdAt?: Date | string
  }

  export type TaskTemplateLogCreateManyUserInput = {
    id?: number
    taskTemplateId: number
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
  }

  export type ProductionTaskUpdateWithoutAssignedToInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    production?: ProductionUpdateOneRequiredWithoutTasksNestedInput
    template?: TaskTemplateUpdateOneWithoutProductionTasksNestedInput
    logs?: ProductionTaskLogUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductionTaskLogUpdateWithoutUserInput = {
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    productionTask?: ProductionTaskUpdateOneRequiredWithoutLogsNestedInput
  }

  export type ProductionTaskLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionTaskId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionTaskLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionTaskId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockLogUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    operation?: EnumStockOperationFieldUpdateOperationsInput | $Enums.StockOperation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTemplateLogUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutLogsNestedInput
  }

  export type TaskTemplateLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type TaskTemplateLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type KitPieceCreateManyPieceInput = {
    id?: number
    kitId: number
    nombre?: number
  }

  export type SousAssemblagePieceCreateManyPieceInput = {
    id?: number
    sousAssemblageId: number
    nombre?: number
  }

  export type SousSousAssemblagePieceCreateManyPieceInput = {
    id?: number
    sousSousAssemblageId: number
    nombre?: number
  }

  export type TaskTemplatePieceCreateManyPieceInput = {
    id?: number
    taskTemplateId: number
    quantity?: number
  }

  export type KitPieceUpdateWithoutPieceInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    kit?: KitUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type KitPieceUncheckedUpdateWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    kitId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type KitPieceUncheckedUpdateManyWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    kitId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblagePieceUpdateWithoutPieceInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    sousAssemblage?: SousAssemblageUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type SousAssemblagePieceUncheckedUpdateWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblagePieceUncheckedUpdateManyWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceUpdateWithoutPieceInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    sousSousAssemblage?: SousSousAssemblageUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type SousSousAssemblagePieceUncheckedUpdateWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceUncheckedUpdateManyWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplatePieceUpdateWithoutPieceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutPiecesNestedInput
  }

  export type TaskTemplatePieceUncheckedUpdateWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplatePieceUncheckedUpdateManyWithoutPieceInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type BorneUpdateWithoutPiecesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUpdateManyWithoutBorneNestedInput
    kits?: KitUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateWithoutPiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUncheckedUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput
    kits?: KitUncheckedUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateManyWithoutPiecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type SousAssemblagePieceCreateManySousAssemblageInput = {
    id?: number
    pieceId: number
    nombre?: number
  }

  export type SousAssemblageSousSousAssemblageCreateManySousAssemblageInput = {
    id?: number
    sousSousAssemblageId: number
    nombre?: number
  }

  export type TaskTemplateSousAssemblageCreateManySousAssemblageInput = {
    id?: number
    taskTemplateId: number
    quantity?: number
  }

  export type SousAssemblagePieceUpdateWithoutSousAssemblageInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblagePieceUncheckedUpdateWithoutSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblagePieceUncheckedUpdateManyWithoutSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblageSousSousAssemblageUpdateWithoutSousAssemblageInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    sousSousAssemblage?: SousSousAssemblageUpdateOneRequiredWithoutSousAssemblagesNestedInput
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateWithoutSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageUpdateWithoutSousAssemblageInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutSousAssemblagesNestedInput
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateWithoutSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateManyWithoutSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type BorneUpdateWithoutSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUpdateManyWithoutBorneNestedInput
    kits?: KitUpdateManyWithoutBornesNestedInput
    pieces?: PieceUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateWithoutSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUncheckedUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput
    kits?: KitUncheckedUpdateManyWithoutBornesNestedInput
    pieces?: PieceUncheckedUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateManyWithoutSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type SousAssemblageSousSousAssemblageCreateManySousSousAssemblageInput = {
    id?: number
    sousAssemblageId: number
    nombre?: number
  }

  export type SousSousAssemblagePieceCreateManySousSousAssemblageInput = {
    id?: number
    pieceId: number
    nombre?: number
  }

  export type TaskTemplateSousSousAssemblageCreateManySousSousAssemblageInput = {
    id?: number
    taskTemplateId: number
    quantity?: number
  }

  export type SousAssemblageSousSousAssemblageUpdateWithoutSousSousAssemblageInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    sousAssemblage?: SousAssemblageUpdateOneRequiredWithoutSousSousAssemblagesNestedInput
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateWithoutSousSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousAssemblageSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceUpdateWithoutSousSousAssemblageInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutSousSousAssemblagesNestedInput
  }

  export type SousSousAssemblagePieceUncheckedUpdateWithoutSousSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type SousSousAssemblagePieceUncheckedUpdateManyWithoutSousSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageUpdateWithoutSousSousAssemblageInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    taskTemplate?: TaskTemplateUpdateOneRequiredWithoutSousSousAssemblagesNestedInput
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateWithoutSousSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutSousSousAssemblageInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type BorneUpdateWithoutSousSousAssemblagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUpdateManyWithoutBorneNestedInput
    kits?: KitUpdateManyWithoutBornesNestedInput
    pieces?: PieceUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateWithoutSousSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUncheckedUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput
    kits?: KitUncheckedUpdateManyWithoutBornesNestedInput
    pieces?: PieceUncheckedUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateManyWithoutSousSousAssemblagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type KitPieceCreateManyKitInput = {
    id?: number
    pieceId: number
    nombre?: number
  }

  export type KitPieceUpdateWithoutKitInput = {
    nombre?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutKitsNestedInput
  }

  export type KitPieceUncheckedUpdateWithoutKitInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type KitPieceUncheckedUpdateManyWithoutKitInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    nombre?: IntFieldUpdateOperationsInput | number
  }

  export type BorneUpdateWithoutKitsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUpdateManyWithoutBorneNestedInput
    pieces?: PieceUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateWithoutKitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    productionLines?: ProductionLineUncheckedUpdateManyWithoutBorneNestedInput
    taskTemplates?: TaskTemplateUncheckedUpdateManyWithoutBorneNestedInput
    pieces?: PieceUncheckedUpdateManyWithoutBornesNestedInput
    sousAssemblages?: SousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
    sousSousAssemblages?: SousSousAssemblageUncheckedUpdateManyWithoutBornesNestedInput
  }

  export type BorneUncheckedUpdateManyWithoutKitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type ProductionTaskCreateManyTemplateInput = {
    id?: number
    productionId: number
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
  }

  export type TaskTemplateLogCreateManyTaskTemplateInput = {
    id?: number
    userId?: number | null
    createdAt?: Date | string
    note?: string | null
    eventType: $Enums.TaskEventType
  }

  export type TaskTemplatePieceCreateManyTaskTemplateInput = {
    id?: number
    pieceId: number
    quantity?: number
  }

  export type TaskTemplateSousAssemblageCreateManyTaskTemplateInput = {
    id?: number
    sousAssemblageId: number
    quantity?: number
  }

  export type TaskTemplateSousSousAssemblageCreateManyTaskTemplateInput = {
    id?: number
    sousSousAssemblageId: number
    quantity?: number
  }

  export type ProductionTaskUpdateWithoutTemplateInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTasksNestedInput
    production?: ProductionUpdateOneRequiredWithoutTasksNestedInput
    logs?: ProductionTaskLogUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskTemplateLogUpdateWithoutTaskTemplateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    user?: UserUpdateOneWithoutTemplateLogsNestedInput
  }

  export type TaskTemplateLogUncheckedUpdateWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type TaskTemplateLogUncheckedUpdateManyWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
  }

  export type TaskTemplatePieceUpdateWithoutTaskTemplateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    piece?: PieceUpdateOneRequiredWithoutTaskTemplatePiecesNestedInput
  }

  export type TaskTemplatePieceUncheckedUpdateWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplatePieceUncheckedUpdateManyWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pieceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageUpdateWithoutTaskTemplateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sousAssemblage?: SousAssemblageUpdateOneRequiredWithoutTaskTemplateSousAssemblagesNestedInput
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousAssemblageUncheckedUpdateManyWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageUpdateWithoutTaskTemplateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sousSousAssemblage?: SousSousAssemblageUpdateOneRequiredWithoutTaskTemplateSousSousAssemblagesNestedInput
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TaskTemplateSousSousAssemblageUncheckedUpdateManyWithoutTaskTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sousSousAssemblageId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionLineCreateManyProductionInput = {
    id?: number
    borneId: number
    quantity: number
  }

  export type ProductionTaskCreateManyProductionInput = {
    id?: number
    taskTemplateId?: number | null
    label: string
    description?: string | null
    isDone?: boolean
    totalSeconds?: number
    running?: boolean
    lastStartedAt?: Date | string | null
    assignedToId?: number | null
  }

  export type ProductionLineUpdateWithoutProductionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    borne?: BorneUpdateOneRequiredWithoutProductionLinesNestedInput
  }

  export type ProductionLineUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionLineUncheckedUpdateManyWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    borneId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductionTaskUpdateWithoutProductionInput = {
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTasksNestedInput
    template?: TaskTemplateUpdateOneWithoutProductionTasksNestedInput
    logs?: ProductionTaskLogUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    logs?: ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateManyWithoutProductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: BoolFieldUpdateOperationsInput | boolean
    totalSeconds?: IntFieldUpdateOperationsInput | number
    running?: BoolFieldUpdateOperationsInput | boolean
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductionTaskLogCreateManyProductionTaskInput = {
    id?: number
    userId?: number | null
    eventType: $Enums.TaskEventType
    createdAt?: Date | string
    note?: string | null
  }

  export type ProductionTaskLogUpdateWithoutProductionTaskInput = {
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutTaskLogsNestedInput
  }

  export type ProductionTaskLogUncheckedUpdateWithoutProductionTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionTaskLogUncheckedUpdateManyWithoutProductionTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumTaskEventTypeFieldUpdateOperationsInput | $Enums.TaskEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}